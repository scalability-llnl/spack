#!/bin/sh
# shellcheck disable=SC2086
# shellcheck disable=SC2223
#
# Copyright 2013-2021 Lawrence Livermore National Security, LLC and other
# Spack Project Developers. See the top-level COPYRIGHT file for details.
#
# SPDX-License-Identifier: (Apache-2.0 OR MIT)

#
# Spack compiler wrapper script.
#
# Compiler commands go through this compiler wrapper in Spack builds.
# The compiler wrapper is a thin layer around the standard compilers.
# It enables several key pieces of functionality:
#
# 1. It allows Spack to swap compilers into and out of builds easily.
# 2. It adds several options to the compile line so that spack
#    packages can find their dependencies at build time and run time:
#      -I and/or -isystem arguments for dependency /include directories.
#      -L                 arguments for dependency /lib directories.
#      -Wl,-rpath         arguments for dependency /lib directories.
#

# Error and exit if any undefined variable is dereferenced.
set -u
# We also declare each variable as readonly after the final time it is modified.

# Justification for the shellcheck ignores declared at the top of this file:
# - SC2086 (double quote variable dereferences to avoid word splitting): we
#   intentionally perform word splitting due to the lack of arrays in POSIX sh,
#   and we always explicitly set IFS before doing so. See the functions
#   alarm_bell() and generate_array_from_expansion() for documentation of our
#   hacky implementation of arrays.
# - SC2223 (quote default variable assignments): we only ever perform default
#   variable assignments with ${xxx:=yyy} on the right-hand side of an
#   invocation of the ':' function, which ignores its arguments.

# Print a message to stderr and exit with status 1.
die() {
    printf '%s\n' "ERROR: $1" >&2
    exit 1
}

# Override `echo` with this facsimile to avoid strange errors across shells.
#
# `printf` is the only way to portably write arbitrary strings, since the
# behavior of `echo -n` is explicitly undefined by POSIX (see "Printing the
# value of a variable" in https://www.etalabs.net/sh_tricks.html). Since there
# is no shellcheck rule to disable `echo`, we redefine it here to immediately
# error out in case it is added to this script later by accident.
echo() {
    die "'echo' is not portable across shells; use \"printf '%s\n'\" instead!"
}

# This is a newline-delimited string of environment variable names that need to
# be set before the script runs. They are set by routines in
# spack.build_environment as part of the package installation process.
readonly parameters="\
SPACK_ENV_PATH
SPACK_DEBUG_LOG_DIR
SPACK_DEBUG_LOG_ID
SPACK_COMPILER_SPEC
SPACK_CC_RPATH_ARG
SPACK_CXX_RPATH_ARG
SPACK_F77_RPATH_ARG
SPACK_FC_RPATH_ARG
SPACK_DTAGS_TO_STRIP
SPACK_LINKER_ARG
SPACK_SHORT_SPEC
SPACK_SYSTEM_DIRS"

#
# Optional parameters that aren't required to be set:
#
# Boolean (true/false/custom) if we want to add debug flags:
# - SPACK_ADD_DEBUG_FLAGS
# If a custom debugging flag is requested, it will be defined here:
# - SPACK_DEBUG_FLAGS
# These compiler input variables are checked for sanity later:
# - SPACK_CC, SPACK_CXX, SPACK_F77, SPACK_FC
# The default compiler flags are passed from these variables:
# - SPACK_CFLAGS, SPACK_CXXFLAGS, SPACK_FFLAGS, SPACK_LDFLAGS, SPACK_LDLIBS
# Debug env var is optional; set to "TRUE" for debug logging:
# - SPACK_DEBUG
# This variable is set when unit testing the compiler script:
# - SPACK_TEST_COMMAND
# This is set when we want to add uarch target args:
# - SPACK_TARGET_ARGS
# This is set when we want to add DTAG arguments:
# - SPACK_DTAGS_TO_ADD


# Exit with error if the parameter given by the name in $1 is unset or empty.
#
# Also declare the parameter as readonly.
check_param_is_empty_or_unset() {
    param_name="$1"
    eval ": \${${param_name}:?Spack compiler must be run from Spack! Input '\$${param_name}' is missing.}"
    eval "readonly $param_name"
}

# Ensure all required parameters are set before doing anything else.
for param in $parameters; do
    check_param_is_empty_or_unset "$param"
done

# Save original command for debug logging.
readonly input_command="$*"

# Test whether a path $1 is equal to any entry of $2->$#.
path_contained_in_nonrecursive() {
    path_to_check="$1"
    shift
    for dir_to_test; do
        case "${dir_to_test%/}" in
            "${path_to_check%/}")
                return 0
                ;;
        esac
    done
    return 1
}

# Test whether a path $1 is contained within $SPACK_SYSTEM_DIRS.
#
# This test determines which directories are considered "system" directories so
# we can correctly classify include directories into -I and -isystem
# arguments later.
is_system_dir() {
    path_to_check="$1"
    IFS=':'
    path_contained_in_nonrecursive "$path_to_check" $SPACK_SYSTEM_DIRS
}

# Remove any entries of $2->$# which are contained in $1.
filter_out_paths_from_another_set_of_paths() {
    paths_to_avoid="$1"
    shift
    IFS=':'
    for candidate; do
        case "$candidate" in
            '')
                continue
                ;;
            *)
                if ! path_contained_in_nonrecursive "$candidate" $paths_to_avoid; then
                    printf '%s:' "$candidate"
                fi
                ;;
        esac
    done
}

# Since our "arrays" are going to be stored as strings, we need to scrub each
# element to avoid errors parsing them out later. This method *should* be
# unnecessary if the rest of the code is correct, but it's a good backstop.
is_empty_or_whitespace() {
    case "$1" in
        ''|' ')
            return 0
            ;;
    esac
    return 1
}

# We store arrays as strings delimited by the alarm bell character '\a', or
# '\007' in octal. There's no particular reason to use the octal version here.
#
# We expect that no legitimate arguments will contain the alarm bell
# character. This seems safe since it seems unlikely that a build system would
# want to use it to ping the user, as there are many better methods of
# sending notifications. It might be worth it to explicitly check for
# the alarm bell character, but that might incur a performance cost (?).
alarm_bell() {
    printf '\007'
}

# This is a helper method that should only be called by the array utility
# methods below. Our technique of delimiting arrays via alarm bells may become
# cumbersome if we constantly need to process extraneous bells out of strings.
#
# To invert the result of this method, set IFS="$(alarm_bell)."
bell_delimited() {
    printf '%s\007' "$@"
}

# Produce a string containing the elements of the $1 array, separated by $2.
#
# This method produces a command line suitable for printing into a log file, or
# to stdout if $SPACK_TEST_COMMAND='dump-args' is set. It should **NOT** be used
# to produce the command line to exec -- we instead set $IFS to the alarm bell
# and exec our args array directly.
join_array_elements() {
    array="$1"
    joiner="$2"
    IFS="$(alarm_bell)"
    printf '%s' "$array" | tr '\007' "$joiner"
}

# Iterate over $@, filter out blank arguments, and delimit the result by the
# alarm bell.
#
# Filtering out blank arguments covers up any mistakes we may make in setting or
# parsing environment variables, and enables initializing arrays as the empty
# string. This makes it easier to avoid e.g. adding a blank '-l' argument to the
# final command line by accident if no libraries were provided to the linker.
generate_array_from_expansion() {
    for element; do
        if is_empty_or_whitespace "$element"; then
            continue
        fi
        bell_delimited "$element"
    done
}

# Append the variadic string arguments $2->$# to the array provided in $1.
#
# $1 is allowed to be empty, along with $2->$#. This method will then produce
# the empty string, which is interpreted as an empty array.
append() {
    base="$1"
    shift
    IFS="$(alarm_bell)"
    generate_array_from_expansion $base
    generate_array_from_expansion "$@"
}

# Prepend the string argument $1 to the array in $2.
#
# $1 must be a non-empty string, but $2 is allowed to be an empty array.
prepend() {
    new_element="$1"
    base="$2"
    if is_empty_or_whitespace "$new_element"; then
        die "Expected initial element to be non-empty (base was: $base)"
    fi
    bell_delimited "$new_element"
    IFS="$(alarm_bell)"
    generate_array_from_expansion $base
}

# Concatenate the array in $1 (left) with the array in $2 (right).
#
# Both $1 and $2 are allowed to be empty.
concatenate() {
    left="$1"
    right="$2"
    IFS="$(alarm_bell)"
    generate_array_from_expansion $left
    generate_array_from_expansion $right
}

# Prefix each element of the array in $1 with the string $2.
#
# $1 may be an empty array, but $2 must be a non-empty string.
prefix_array_elements() {
    inputs="$1"
    prefix="$2"
    if is_empty_or_whitespace "$prefix"; then
        die "Expected prefix string to be non-empty (inputs were: $inputs)"
    fi
    IFS="$(alarm_bell)"
    for element in $inputs; do
        if is_empty_or_whitespace "$element"; then
            continue
        fi
        printf '%s' "$prefix"
        bell_delimited "$element"
    done
}

# Produce command line arguments to include each element of $1 as a directory
# for the C preprocessor to search for header files in.
include_dir_prefix_elements() {
    inputs="$1"
    prefix_array_elements "$inputs" '-I'
}

# Produce command line arguments to include each element of $1 as a directory
# for the linker to search for libraries in.
lib_dir_prefix_elements() {
    inputs="$1"
    prefix_array_elements "$inputs" '-L'
}

# Produce command line arguments to include each element of $1 as the name of
# a library to link against.
lib_name_prefix_elements() {
    inputs="$1"
    prefix_array_elements "$inputs" '-l'
}

# Produce a command line which alternates between the string $2 and each element
# of the array $1.
#
# $1 may be an empty array, but $2 must be a non-empty string.
prefix_discrete_arg_array_elements() {
    inputs="$1"
    prefix_discrete_arg="$2"
    if is_empty_or_whitespace "$prefix_discrete_arg"; then
        die "Expected discrete prefix to be non-empty (inputs were: $inputs)"
    fi
    IFS="$(alarm_bell)"
    for element in $inputs; do
        if is_empty_or_whitespace "$element"; then
            continue
        fi
        bell_delimited "$prefix_discrete_arg"
        bell_delimited "$element"
    done
}

# Produce command line arguments to include each element of $1 as the name of
# a system include directory.
system_include_dir_prefix_elements() {
    inputs="$1"
    prefix_discrete_arg_array_elements "$inputs" '-isystem'
}

# Produce an array which strips the prefix string $2 from each element of $1.
#
# $1 may be an empty array, but $2 must be a non-empty string. This method also
# errors if any element of $1 does *not* begin with the string $2.
remove_prefix_from_array_elements() {
    inputs="$1"
    prefix="$2"
    if is_empty_or_whitespace "$prefix"; then
        die "Expected prefix to remove to be non-empty (inputs were: $inputs)"
    fi
    IFS="$(alarm_bell)"
    for element in $inputs; do
        if is_empty_or_whitespace "$element"; then
            continue
        fi
        stripped="${element#$prefix}"
        case "$stripped" in
            "$element")
                die "Expected element to begin with '$prefix', but was $element"
                ;;
        esac
        bell_delimited "$stripped"
    done
}

#
# Check if optional parameters are defined.

# Define true/false/custom variables we can use in parameter expansions.
readonly True='true'
readonly False='false'
readonly Custom='custom'

# Determine whether $1 is equal to $True, $False, or $Custom.
is_valid_tribool() {
    value="$1"
    case "$value" in
        "$True"|"$False"|"$Custom")
            return 0
            ;;
    esac
    return 1
}

# Determine whether $1 is equal to $True or $False.
is_valid_bool() {
    value="$1"
    case "$value" in
        "$True"|"$False")
            return 0
            ;;
    esac
    return 1
}

# If we aren't asking for debug flags, don't add them.
: ${SPACK_ADD_DEBUG_FLAGS:="$False"}
readonly SPACK_ADD_DEBUG_FLAGS

if ! is_valid_tribool "$SPACK_ADD_DEBUG_FLAGS"; then
    die "\$SPACK_ADD_DEBUG_FLAGS, if defined, must be one of '$True' '$False', or '$Custom' (was: $SPACK_ADD_DEBUG_FLAGS)."
fi

# Figure out the type of compiler, the language, and the mode so that
# the compiler script knows what to do.
#
# Possible languages are C, C++, Fortran 77, and Fortran 90.
# 'command' is set based on the input command to $SPACK_[CC|CXX|F77|F90]
#
# 'mode' is set to one of:
#    vcheck  version check
#    cpp     preprocess
#    cc      compile
#    as      assemble
#    ld      link
#    ccld    compile & link

command="${0##*/}"
case "$command" in
    cpp)
        mode=cpp
        debug_flags='-g'
        ;;
    cc|c89|c99|gcc|clang|armclang|icc|icx|pgcc|nvc|xlc|xlc_r|fcc)
        command="$SPACK_CC"
        comp='CC'
        lang_flags='C'
        debug_flags='-g'
        ;;
    c++|CC|g++|clang++|armclang++|icpc|icpx|pgc++|nvc++|xlc++|xlc++_r|FCC)
        command="$SPACK_CXX"
        comp='CXX'
        lang_flags='CXX'
        debug_flags='-g'
        ;;
    ftn|f90|fc|f95|gfortran|flang|armflang|ifort|ifx|pgfortran|nvfortran|xlf90|xlf90_r|nagfor|frt)
        command="$SPACK_FC"
        comp='FC'
        lang_flags='F'
        debug_flags='-g'
        ;;
    f77|xlf|xlf_r|pgf77)
        command="$SPACK_F77"
        comp='F77'
        lang_flags='F'
        debug_flags='-g'
        ;;
    ld|ld.gold|ld.lld)
        mode='ld'
        ;;
    *)
        # Check that at least one of the known commands was actually selected,
        # otherwise we don't know what to execute.
        die "Unknown command '$command' selected. Compiler was: $SPACK_COMPILER_SPEC."
        ;;
esac
readonly command
: ${comp:='CC'}
readonly comp
: ${lang_flags:=''}
readonly lang_flags
: ${debug_flags:=''}
readonly debug_flags

# If any of the arguments below are present, then the mode is vcheck.
# In vcheck mode, nothing is added in terms of extra search paths or
# libraries.
case "${mode:-}" in
    ''|ld)
        for arg; do
            case "$arg" in
                -v|-V|--version|-dumpversion)
                    mode='vcheck'
                    break
                    ;;
            esac
        done
        ;;
esac

# Finish setting up the mode.
case "${mode:-}" in
    '')
        mode='ccld'
        for arg; do
            case "$arg" in
                -E)
                    mode='cpp'
                    break
                    ;;
                -S)
                    mode='as'
                    break
                    ;;
                -c)
                    mode='cc'
                    break
                    ;;
            esac
        done
        ;;
esac
readonly mode

# These variables are needed to ensure we set RPATH instead of RUNPATH
# (or the opposite, depending on the configuration in config.yaml)
#
# Documentation on this mechanism is lacking at best. A few sources
# of information are (note that some of them take explicitly the
# opposite stance that Spack does):
# - http://blog.qt.io/blog/2011/10/28/rpath-and-runpath/
# - https://wiki.debian.org/RpathIssue
#
# The only discussion that seems to exist on enabling new dynamic tags by
# default on ld is the following:
# - https://sourceware.org/ml/binutils/2013-01/msg00307.html
#
# The relevant variables are:
# - $SPACK_DTAGS_TO_ADD
# - $SPACK_DTAGS_TO_STRIP
# - $SPACK_LINKER_ARG
#

# Set up $rpath variable according to the compiler name.
readonly rpath="$(eval "printf '%s' \"\$SPACK_${comp}_RPATH_ARG\"")"

: ${SPACK_TEST_COMMAND:=''}
readonly SPACK_TEST_COMMAND
# Dump the mode and exit if the command is dump-mode.
case "$SPACK_TEST_COMMAND" in
    dump-mode)
        printf '%s\n' "$mode"
        exit
        ;;
esac

# Filter '.' and Spack environment directories out of $PATH so that this script
# doesn't just call itself.
readonly filtered_path="$(IFS=':'; filter_out_paths_from_another_set_of_paths "$SPACK_ENV_PATH" $PATH)"
# Remove the trailing ':' before putting it back in $PATH.
readonly PATH="${filtered_path%:}"

case "$mode" in
    vcheck)
        exec "$command" "$@"
        ;;
esac

# Darwin's linker has a -r argument that merges object files together.
# It doesn't work with -rpath, so $add_rpaths controls whether they are added.
case "$mode" in
    ld|ccld)
        case "$SPACK_SHORT_SPEC" in
            *darwin*)
                for arg; do
                    case "${arg}~${mode}" in
                        -r~ld|-r~ccld|-Wl,-r~ccld)
                            add_rpaths="$False"
                            break
                            ;;
                    esac
                done
                ;;
        esac
        ;;
esac
: ${add_rpaths:="$True"}
readonly add_rpaths

# This check allows us to safely perform checks with `!=` later.
if ! is_valid_bool "$add_rpaths"; then
    die "\$add_rpaths must be '$True' or '$False', but was '$add_rpaths'."
fi

# Return whether the $add_rpaths variable was *not* set to $False.
should_add_rpaths() {
    case "$add_rpaths" in
        "$False")
            return 1
            ;;
    esac
    return 0
}

# Parse the command line arguments.
#
# We extract -L, -I, -isystem and -Wl,-rpath arguments from the
# command line and recombine them with Spack arguments later.  We
# parse these out so that we can make sure that system paths come
# last, that package arguments come first, and that Spack arguments
# are injected properly.
#
# All other arguments, including -l arguments, are treated as
# 'other_args' and left in their original order.  This ensures that
# --start-group, --end-group, and other order-sensitive flags continue to
# work as the caller expects.
#
# The libs variable is initialized here for completeness, and it is also
# used later to inject flags supplied via `ldlibs` on the command
# line. These come into the wrappers via SPACK_LDLIBS.
#
includes=''
libdirs=''
rpaths=''
system_includes=''
system_libdirs=''
system_rpaths=''
libs=''
other_args=''
isystem_system_includes=''
isystem_includes=''

while [ $# -ne 0 ]; do

    # An RPATH to be added after the case statement.
    rp=''

    # Multiple consecutive spaces in the command line can result in
    # blank arguments, so we remove those here.
    case "$1" in
        '')
            shift
            continue
            ;;
    esac

    case "$1" in
        -isystem*)
            arg="${1#-isystem}"
            isystem_was_used="$True"
            case "$arg" in '') shift; arg="$1";; esac
            if is_system_dir "$arg"; then
                isystem_system_includes="$(append "$isystem_system_includes" "$arg")"
            else
                isystem_includes="$(append "$isystem_includes" "$arg")"
            fi
            ;;
        -I*)
            arg="${1#-I}"
            case "$arg" in '') shift; arg="$1";; esac
            if is_system_dir "$arg"; then
                system_includes="$(append "$system_includes" "$arg")"
            else
                includes="$(append "$includes" "$arg")"
            fi
            ;;
        -L*)
            arg="${1#-L}"
            case "$arg" in '') shift; arg="$1";; esac
            if is_system_dir "$arg"; then
                system_libdirs="$(append "$system_libdirs" "$arg")"
            else
                libdirs="$(append "$libdirs" "$arg")"
            fi
            ;;
        -l*)
            # -loopopt=0 is generated erroneously in autoconf <= 2.69,
            # and passed by ifx to the linker, which confuses it with a
            # library. Filter it out.
            # TODO: generalize filtering of args with an env var, so that
            # TODO: we do not have to special case this here.
            case "$mode" in
                ld|ccld)
                    case "${1#-loopopt}" in
                        "$1")
                        ;;
                        *)
                            shift
                            continue
                            ;;
                    esac
                    ;;
            esac
            arg="${1#-l}"
            case "$arg" in '') shift; arg="$1";; esac
            other_args="$(append "$other_args" "-l$arg")"
            ;;
        -Wl,*)
            arg="${1#-Wl,}"
            case "$arg" in '') shift; arg="$1";; esac
            case "$arg" in
                -rpath=*)
                    rp="${arg#-rpath=}"
                    ;;
                --rpath=*)
                    rp="${arg#--rpath=}"
                    ;;
                -rpath,*)
                    rp="${arg#-rpath,}"
                    ;;
                --rpath,*)
                    rp="${arg#--rpath,}"
                    ;;
                -rpath|--rpath)
                    shift; arg="$1"
                    case "$arg" in
                        -Wl,*)
                            rp="${arg#-Wl,}"
                            ;;
                        *)
                            die "-Wl,-rpath was not followed by -Wl,* (was: $arg)"
                            ;;
                    esac
                    ;;
                "$SPACK_DTAGS_TO_STRIP")
                    :  # We want to explicitly remove this flag.
                    ;;
                *)
                    other_args="$(append "$other_args" "-Wl,$arg")"
                    ;;
            esac
            ;;
        -Xlinker,*)
            arg="${1#-Xlinker,}"
            case "$arg" in '') shift; arg="$1";; esac
            case "$arg" in
                -rpath=*)
                    rp="${arg#-rpath=}"
                    ;;
                --rpath=*)
                    rp="${arg#--rpath=}"
                    ;;
                -rpath|--rpath)
                    shift; arg="$1"
                    case "$arg" in
                        -Xlinker,*)
                            rp="${arg#-Xlinker,}"
                            ;;
                        *)
                            die "-Xlinker,-rpath was not followed by -Xlinker,* (was: $arg)"
                            ;;
                    esac
                    ;;
                *)
                    other_args="$(append "$other_args" "-Xlinker,$arg")"
                    ;;
            esac
            ;;
        -Xlinker)
            case "$2" in
                -rpath)
                    case "$3" in
                        -Xlinker)
                        ;;
                        *)
                            die "'-Xlinker -rpath' was not followed by -Xlinker (was: $3)"
                            ;;
                    esac
                    shift 3;
                    rp="$1"
                    ;;
                "$SPACK_DTAGS_TO_STRIP")
                    # We want to explicitly remove this flag. This 'shift'
                    # unshifts '-Xlinker', while the 'shift' at the bottom of
                    # the loop will unshift the second argument we want
                    # to strip.
                    shift
                    ;;
                *)
                    other_args="$(append "$other_args" "$1")"
                    ;;
            esac
            ;;
        *)
            case "$1" in
                "$SPACK_DTAGS_TO_STRIP")
                # We want to explicitly remove this flag.
                ;;
                *)
                    other_args="$(append "$other_args" "$1")"
                    ;;
            esac
            ;;
    esac

    # Test rpaths against system directories in one place.
    case "$rp" in
        '')
        ;;
        *)
            if is_system_dir "$rp"; then
                system_rpaths="$(append "$system_rpaths" "$rp")"
            else
                rpaths="$(append "$rpaths" "$rp")"
            fi
            ;;
    esac
    shift
done
readonly isystem_system_includes
readonly isystem_includes
readonly system_includes
readonly includes
readonly system_libdirs
readonly other_args
readonly system_rpaths
: ${isystem_was_used="$False"}
readonly isystem_was_used

if ! is_valid_bool "$isystem_was_used"; then
    die "\$isystem_was_used must be '$True' or '$False', but was '$isystem_was_used'."
fi

# Return whether any -isystem args were provided to the original command line.
was_isystem_used() {
    case "$isystem_was_used" in
        "$True")
            return 0
            ;;
    esac
    return 1
}

#
# Add flags from Spack's cppflags, cflags, cxxflags, fcflags, fflags, and
# ldflags. We stick to the order that gmake puts the flags in by default.
#
# See the gmake manual on implicit rules for details:
# https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html
#
flags=''

# Add debug flags.
case "$SPACK_ADD_DEBUG_FLAGS" in
    "$True")
        case "$debug_flags" in
            '')
            ;;
            *)
                flags="$(append "$flags" "$debug_flags")"
                ;;
        esac
        ;;
    "$Custom")
        # If a custom flag is requested, derive from the environment.
        # shellcheck disable=SC2153
        readonly spack_debug_flags="$(IFS=' '; generate_array_from_expansion $SPACK_DEBUG_FLAGS)"
        flags="$(concatenate "$flags" "$spack_debug_flags")"
        ;;
esac

# Fortran flags come before CPPFLAGS.
case "$mode" in
    cc|ccld)
        case "$lang_flags" in
            F)
                flags="$(IFS=' '; append "$flags" ${SPACK_FFLAGS:-})"
                ;;
        esac
        ;;
esac

# C preprocessor flags come before any C/CXX flags.
case "$mode" in
    cpp|as|cc|ccld)
        flags="$(IFS=' '; append "$flags" ${SPACK_CPPFLAGS:-})"
        ;;
esac

# Add C and C++ flags.
case "$mode" in
    cc|ccld)
        case "$lang_flags" in
            C)
                flags="$(IFS=' '; append "$flags" ${SPACK_CFLAGS:-})"
                ;;
            CXX)
                flags="$(IFS=' '; append "$flags" ${SPACK_CXXFLAGS:-})"
                ;;
        esac
        if [ ! -z "$SPACK_TARGET_ARGS" ]; then
            readonly spack_target_args="$(IFS=' '; generate_array_from_expansion $SPACK_TARGET_ARGS)"
            flags="$(concatenate "$spack_target_args" "$flags")"
        fi
        ;;
esac

# Add linker flags.
case "$mode" in
    ld|ccld)
        flags="$(IFS=' '; append "$flags" ${SPACK_LDFLAGS:-})"

        # On macOS insert headerpad_max_install_names linker flag.
        case "$SPACK_SHORT_SPEC" in
            *darwin*)
                case "$mode" in
                    ld)
                        flags="$(append "$flags" '-headerpad_max_install_names')"
                        ;;
                    ccld)
                        flags="$(append "$flags" '-Wl,-headerpad_max_install_names')"
                        ;;
                esac
                ;;
        esac

        readonly rpath_dirs="$(IFS=':'; generate_array_from_expansion $SPACK_RPATH_DIRS)"
        if should_add_rpaths; then
            # Append RPATH directories. Note that in the case of the top-level
            # package these directories may not exist yet. For dependencies it
            # is assumed that paths have already been confirmed.
            rpaths="$(concatenate "$rpaths" "$rpath_dirs")"
        fi

        readonly link_dirs="$(IFS=':'; generate_array_from_expansion $SPACK_LINK_DIRS)"
        libdirs="$(concatenate "$libdirs" "$link_dirs")"

        # Set extra RPATHs.
        readonly extra_rpaths="$(IFS=':'; generate_array_from_expansion ${SPACK_COMPILER_EXTRA_RPATHS:-})"
        libdirs="$(concatenate "$libdirs" "$extra_rpaths")"
        if should_add_rpaths; then
            rpaths="$(concatenate "$rpaths" "$extra_rpaths")"
        fi

        # Set implicit RPATHs.
        readonly implicit_rpaths="$(IFS=':'; generate_array_from_expansion ${SPACK_COMPILER_IMPLICIT_RPATHS:-})"
        if should_add_rpaths; then
            rpaths="$(concatenate "$rpaths" "$implicit_rpaths")"
        fi

        # Add SPACK_LDLIBS to args.
        readonly spack_ldlibs="$(IFS=' '; generate_array_from_expansion ${SPACK_LDLIBS:-})"
        libs="$(concatenate "$libs" "$(remove_prefix_from_array_elements "$spack_ldlibs" '-l')")"
        ;;
esac
readonly libdirs
readonly rpaths
readonly libs
readonly flags

#
# Finally, reassemble the command line.
#

# These are the in-order flags assembled earlier.
args="$flags"

# Includes and system includes first. Insert include directories just prior to
# any system include directories.

args="$(concatenate "$args" "$(include_dir_prefix_elements "$includes")")"
args="$(concatenate "$args" "$(system_include_dir_prefix_elements "$isystem_includes")")"

# shellcheck disable=SC2153
readonly spack_include_dirs="$(IFS=':'; generate_array_from_expansion $SPACK_INCLUDE_DIRS)"
case "$mode" in
    cpp|cc|as|ccld)
        if was_isystem_used; then
            args="$(concatenate "$args" "$(system_include_dir_prefix_elements "$spack_include_dirs")")"
        else
            args="$(concatenate "$args" "$(include_dir_prefix_elements "$spack_include_dirs")")"
        fi
        ;;
esac

args="$(concatenate "$args" "$(include_dir_prefix_elements "$system_includes")")"
args="$(concatenate "$args" "$(system_include_dir_prefix_elements "$isystem_system_includes")")"

# Add library search paths.
args="$(concatenate "$args" "$(lib_dir_prefix_elements "$libdirs")")"
args="$(concatenate "$args" "$(lib_dir_prefix_elements "$system_libdirs")")"

# Add RPATH arguments.
case "$mode" in
    ccld)
        if [ ! -z "$SPACK_DTAGS_TO_ADD" ]; then
            args="$(append "$args" "${SPACK_LINKER_ARG}${SPACK_DTAGS_TO_ADD}")"
        fi
        args="$(concatenate "$args" "$(prefix_array_elements "$rpaths" "$rpath")")"
        args="$(concatenate "$args" "$(prefix_array_elements "$system_rpaths" "$rpath")")"
        ;;
    ld)
        if [ ! -z "$SPACK_DTAGS_TO_ADD" ]; then
            args="$(append "$args" "$SPACK_DTAGS_TO_ADD")"
        fi
        args="$(concatenate "$args" "$(prefix_discrete_arg_array_elements "$rpaths" '-rpath')")"
        args="$(concatenate "$args" "$(prefix_discrete_arg_array_elements "$system_rpaths" '-rpath')")"
        ;;
esac

# Add any other arguments from the input command.
args="$(concatenate "$args" "$other_args")"

# Inject SPACK_LDLIBS, if supplied.
args="$(concatenate "$args" "$(lib_name_prefix_elements "$libs")")"
readonly args

full_command="$(prepend "$command" "$args")"

# Prepend the ccache binary if we're using ccache.
case "${SPACK_CCACHE_BINARY:-}" in
    '')
    ;;
    *)
        case "$lang_flags" in
            C|CXX)  # ccache only supports C languages.
                full_command="$(prepend "$SPACK_CCACHE_BINARY" "$full_command")"
                # This is a workaround for the stage dir being a temp folder.
                # See #3761#issuecomment-294352232.
                export CCACHE_NOHASHDIR=yes
                ;;
        esac
        ;;
esac
readonly full_command

# Dump the full command and exit if the caller supplies
# $SPACK_TEST_COMMAND='dump-args'.
case "$SPACK_TEST_COMMAND" in
    dump-args)
        readonly newline_command_string="$(join_array_elements "$full_command" '\n')"
        printf '%s\n' "$newline_command_string"
        exit
        ;;
    dump-env-*)
        readonly varname="${SPACK_TEST_COMMAND#dump-env-}"
        eval "printf '%s\n' \"\$0: \$varname: \$$varname\""
        ;;
    '')
        ;;
    *)
        die "Unknown test command: '$SPACK_TEST_COMMAND'."
        ;;
esac

#
# Write the input and output commands to debug logs if it's asked for.
#
case "${SPACK_DEBUG:-}" in
    TRUE)
        readonly input_log="${SPACK_DEBUG_LOG_DIR}/spack-cc-$SPACK_DEBUG_LOG_ID.in.log"
        readonly output_log="${SPACK_DEBUG_LOG_DIR}/spack-cc-$SPACK_DEBUG_LOG_ID.out.log"
        printf '%s\n' "[${mode}] ${command} ${input_command}" >> "$input_log"
        readonly spaced_command_string="$(join_array_elements "$full_command" ' ')"
        printf '%s\n' "[${mode}] ${spaced_command_string}" >> "$output_log"
        ;;
esac

# Our "array" is just a string split by the alarm bell character, and we can
# avoid any quoting issues by using strictly the alarm bell to split the array
# before execing it.
IFS="$(alarm_bell)"
exec $full_command
