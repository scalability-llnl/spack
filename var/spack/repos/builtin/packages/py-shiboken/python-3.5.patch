--- a/popenasync.py	2014-04-24 01:27:23.000000000 -0500
+++ b/popenasync.py	2022-01-17 14:24:39.000000000 -0600
@@ -23,22 +23,22 @@
 else:
     null_byte = '\x00'
 
-if subprocess.mswindows:
+if subprocess._mswindows:
     if sys.version_info >= (3,):
         # Test date should be in ascii.
         def encode(s):
             return s.encode('ascii')
-        
+
         def decode(b):
             return b.decode('ascii')
     else:
         # Strings only; do nothing
         def encode(s):
             return s
-        
+
         def decode(b):
             return b
-        
+
     try:
         import ctypes
         from ctypes.wintypes import DWORD
@@ -66,13 +66,13 @@
             else:
                 success = ctypes.windll.kernel32.PeekNamedPipe(handle, None, desired_bytes, None, ctypes.byref(c_avail), ctypes.byref(c_message))
                 return "", c_avail.value, c_message.value
-                
+
     except ImportError:
         from win32file import ReadFile, WriteFile
         from win32pipe import PeekNamedPipe
         from win32api import TerminateProcess
     import msvcrt
-    
+
 else:
     from signal import SIGINT, SIGTERM, SIGKILL
     import select
@@ -87,16 +87,16 @@
 class Popen(subprocess.Popen):
     def __init__(self, *args, **kwargs):
         subprocess.Popen.__init__(self, *args, **kwargs)
-    
+
     def recv(self, maxsize=None):
         return self._recv('stdout', maxsize)
-    
+
     def recv_err(self, maxsize=None):
         return self._recv('stderr', maxsize)
 
     def send_recv(self, input='', maxsize=None):
         return self.send(input), self.recv(maxsize), self.recv_err(maxsize)
-    
+
     def read_async(self,  wait=.1, e=1, tr=5, stderr=0):
         if tr < 1:
             tr = 1
@@ -118,21 +118,21 @@
             else:
                 time.sleep(max((x-time.time())/tr, 0))
         return ''.join(y)
-        
+
     def send_all(self, data):
         while len(data):
             sent = self.send(data)
             if sent is None:
                 raise Exception("Other end disconnected!")
             data = buffer(data, sent)
-    
+
     def get_conn_maxsize(self, which, maxsize):
         if maxsize is None:
             maxsize = 1024
         elif maxsize < 1:
             maxsize = 1
         return getattr(self, which), maxsize
-    
+
     def _close(self, which):
         conn = getattr(self, which)
         flags = fcntl.fcntl(conn, fcntl.F_GETFL)
@@ -141,13 +141,13 @@
         assert conn.read() == ''
         getattr(self, which).close()
         setattr(self, which, None)
-    
-    if subprocess.mswindows:
+
+    if subprocess._mswindows:
         def kill(self):
             # Recipes
             #http://me.in-berlin.de/doc/python/faq/windows.html#how-do-i-emulate-os-kill-in-windows
             #http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/347462
-            
+
             """kill function for Win32"""
             TerminateProcess(int(self._handle), 0) # returns None
 
@@ -171,7 +171,7 @@
             conn, maxsize = self.get_conn_maxsize(which, maxsize)
             if conn is None:
                 return None
-            
+
             try:
                 x = msvcrt.get_osfhandle(conn.fileno())
                 (read, nAvail, nMessage) = PeekNamedPipe(x, 0)
@@ -185,7 +185,7 @@
                 if geterror()[0] in (109, errno.ESHUTDOWN):
                     return self._close(which)
                 raise
-            
+
             if self.universal_newlines:
                 # Translate newlines. For Python 3.x assume read is text.
                 # If bytes then another solution is needed.
@@ -200,7 +200,7 @@
 
                 killed_pid, stat = os.waitpid(self.pid, os.WNOHANG)
                 if killed_pid != 0: return
-                
+
         def send(self, input):
             if not self.stdin:
                 return None
@@ -221,15 +221,15 @@
             conn, maxsize = self.get_conn_maxsize(which, maxsize)
             if conn is None:
                 return None
-            
+
             flags = fcntl.fcntl(conn, fcntl.F_GETFL)
             if not conn.closed:
                 fcntl.fcntl(conn, fcntl.F_SETFL, flags| os.O_NONBLOCK)
-            
+
             try:
                 if not select.select([conn], [], [], 0)[0]:
                     return ''
-                
+
                 try:
                     r = conn.read(maxsize)
                 except IOError as e:
@@ -238,7 +238,7 @@
                     raise
                 if not r:
                     return self._close(which)
-    
+
                 if self.universal_newlines:
                     r = r.replace("\r\n", "\n").replace("\r", "\n")
                 return r
@@ -251,7 +251,7 @@
 def proc_in_time_or_kill(cmd, time_out, wd = None, env = None):
     proc = Popen (
         cmd, cwd = wd, env = env,
-        stdin = subprocess.PIPE, stdout = subprocess.PIPE, 
+        stdin = subprocess.PIPE, stdout = subprocess.PIPE,
         stderr = subprocess.STDOUT, universal_newlines = 1
     )
 
@@ -281,7 +281,7 @@
         ret_code, response = proc_in_time_or_kill(
             [sys.executable, '-c', 'while 1: pass'], time_out = 1
         )
-        
+
         self.assert_( 'rocess timed out' in ret_code )
         self.assert_( 'successfully terminated' in ret_code )
 
@@ -292,7 +292,7 @@
         shell, commands, tail = ('cmd', ('echo "hello"', 'echo "HELLO WORLD"'), '\r\n')
     else:
         shell, commands, tail = ('sh', ('ls', 'echo HELLO WORLD'), '\n')
-    
+
     a = Popen(shell, stdin=PIPE, stdout=PIPE)
     sys.stdout.write(a.read_async())
     sys.stdout.write(" ")
@@ -305,7 +305,7 @@
     a.wait()
 
 ################################################################################
-    
+
 if __name__ == '__main__':
     if 1: unittest.main()
     else: _example()
