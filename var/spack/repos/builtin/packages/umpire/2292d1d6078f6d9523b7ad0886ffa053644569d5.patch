From 2292d1d6078f6d9523b7ad0886ffa053644569d5 Mon Sep 17 00:00:00 2001
From: Alan Dayton <dayton8@llnl.gov>
Date: Tue, 14 Feb 2023 16:06:35 -0800
Subject: [PATCH] Prefix fmt macros to avoid conflicts

---
 src/tpl/umpire/fmt/args.h       |  18 +-
 src/tpl/umpire/fmt/chrono.h     | 228 ++++-----
 src/tpl/umpire/fmt/color.h      | 132 ++---
 src/tpl/umpire/fmt/compile.h    | 124 ++---
 src/tpl/umpire/fmt/core.h       | 604 +++++++++++------------
 src/tpl/umpire/fmt/fmt.hpp      |   6 +-
 src/tpl/umpire/fmt/format-inl.h | 330 ++++++-------
 src/tpl/umpire/fmt/format.h     | 842 ++++++++++++++++----------------
 src/tpl/umpire/fmt/locale.h     |  12 +-
 src/tpl/umpire/fmt/os.h         | 134 ++---
 src/tpl/umpire/fmt/ostream.h    |  22 +-
 src/tpl/umpire/fmt/printf.h     |  50 +-
 src/tpl/umpire/fmt/ranges.h     |  74 +--
 13 files changed, 1288 insertions(+), 1288 deletions(-)

diff --git a/src/tpl/umpire/fmt/args.h b/src/tpl/umpire/fmt/args.h
index 24dbec930..33fa9fc5c 100644
--- a/src/tpl/umpire/fmt/args.h
+++ b/src/tpl/umpire/fmt/args.h
@@ -5,8 +5,8 @@
 //
 // For the license information refer to format.h.
 
-#ifndef FMT_ARGS_H_
-#define FMT_ARGS_H_
+#ifndef UMPIRE_FMT_ARGS_H_
+#define UMPIRE_FMT_ARGS_H_
 
 #include <functional>  // std::reference_wrapper
 #include <memory>      // std::unique_ptr
@@ -14,7 +14,7 @@
 
 #include "core.h"
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 
 namespace detail {
 
@@ -40,10 +40,10 @@ class dynamic_arg_list {
     T value;
 
     template <typename Arg>
-    FMT_CONSTEXPR typed_node(const Arg& arg) : value(arg) {}
+    UMPIRE_FMT_CONSTEXPR typed_node(const Arg& arg) : value(arg) {}
 
     template <typename Char>
-    FMT_CONSTEXPR typed_node(const basic_string_view<Char>& arg)
+    UMPIRE_FMT_CONSTEXPR typed_node(const basic_string_view<Char>& arg)
         : value(arg.data(), arg.size()) {}
   };
 
@@ -72,7 +72,7 @@ class dynamic_arg_list {
  */
 template <typename Context>
 class dynamic_format_arg_store
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
+#if UMPIRE_FMT_GCC_VERSION && UMPIRE_FMT_GCC_VERSION < 409
     // Workaround a GCC template argument substitution bug.
     : public basic_format_args<Context>
 #endif
@@ -220,13 +220,13 @@ class dynamic_format_arg_store
     \endrst
   */
   void reserve(size_t new_cap, size_t new_cap_named) {
-    FMT_ASSERT(new_cap >= new_cap_named,
+    UMPIRE_FMT_ASSERT(new_cap >= new_cap_named,
                "Set of arguments includes set of named arguments");
     data_.reserve(new_cap);
     named_info_.reserve(new_cap_named);
   }
 };
 
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_ARGS_H_
+#endif  // UMPIRE_FMT_ARGS_H_
diff --git a/src/tpl/umpire/fmt/chrono.h b/src/tpl/umpire/fmt/chrono.h
index e7909e7b5..7772d9aae 100644
--- a/src/tpl/umpire/fmt/chrono.h
+++ b/src/tpl/umpire/fmt/chrono.h
@@ -5,8 +5,8 @@
 //
 // For the license information refer to format.h.
 
-#ifndef FMT_CHRONO_H_
-#define FMT_CHRONO_H_
+#ifndef UMPIRE_FMT_CHRONO_H_
+#define UMPIRE_FMT_CHRONO_H_
 
 #include <algorithm>
 #include <chrono>
@@ -17,13 +17,13 @@
 #include "format.h"
 #include "locale.h"
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 
 // Enable safe chrono durations, unless explicitly disabled.
-#ifndef FMT_SAFE_DURATION_CAST
-#  define FMT_SAFE_DURATION_CAST 1
+#ifndef UMPIRE_FMT_SAFE_DURATION_CAST
+#  define UMPIRE_FMT_SAFE_DURATION_CAST 1
 #endif
-#if FMT_SAFE_DURATION_CAST
+#if UMPIRE_FMT_SAFE_DURATION_CAST
 
 // For conversion between std::chrono::durations without undefined
 // behaviour or erroneous results.
@@ -34,10 +34,10 @@ FMT_BEGIN_NAMESPACE
 namespace safe_duration_cast {
 
 template <typename To, typename From,
-          FMT_ENABLE_IF(!std::is_same<From, To>::value &&
+          UMPIRE_FMT_ENABLE_IF(!std::is_same<From, To>::value &&
                         std::numeric_limits<From>::is_signed ==
                             std::numeric_limits<To>::is_signed)>
-FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
+UMPIRE_FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
   ec = 0;
   using F = std::numeric_limits<From>;
   using T = std::numeric_limits<To>;
@@ -63,10 +63,10 @@ FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
  * can't be converted to To without loss, ec is set.
  */
 template <typename To, typename From,
-          FMT_ENABLE_IF(!std::is_same<From, To>::value &&
+          UMPIRE_FMT_ENABLE_IF(!std::is_same<From, To>::value &&
                         std::numeric_limits<From>::is_signed !=
                             std::numeric_limits<To>::is_signed)>
-FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
+UMPIRE_FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
   ec = 0;
   using F = std::numeric_limits<From>;
   using T = std::numeric_limits<To>;
@@ -96,8 +96,8 @@ FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
 }
 
 template <typename To, typename From,
-          FMT_ENABLE_IF(std::is_same<From, To>::value)>
-FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
+          UMPIRE_FMT_ENABLE_IF(std::is_same<From, To>::value)>
+UMPIRE_FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
   ec = 0;
   return from;
 }  // function
@@ -117,8 +117,8 @@ FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
  */
 // clang-format on
 template <typename To, typename From,
-          FMT_ENABLE_IF(!std::is_same<From, To>::value)>
-FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
+          UMPIRE_FMT_ENABLE_IF(!std::is_same<From, To>::value)>
+UMPIRE_FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
   ec = 0;
   using T = std::numeric_limits<To>;
   static_assert(std::is_floating_point<From>::value, "From must be floating");
@@ -139,8 +139,8 @@ FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
 }  // function
 
 template <typename To, typename From,
-          FMT_ENABLE_IF(std::is_same<From, To>::value)>
-FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
+          UMPIRE_FMT_ENABLE_IF(std::is_same<From, To>::value)>
+UMPIRE_FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
   ec = 0;
   static_assert(std::is_floating_point<From>::value, "From must be floating");
   return from;
@@ -150,8 +150,8 @@ FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
  * safe duration cast between integral durations
  */
 template <typename To, typename FromRep, typename FromPeriod,
-          FMT_ENABLE_IF(std::is_integral<FromRep>::value),
-          FMT_ENABLE_IF(std::is_integral<typename To::rep>::value)>
+          UMPIRE_FMT_ENABLE_IF(std::is_integral<FromRep>::value),
+          UMPIRE_FMT_ENABLE_IF(std::is_integral<typename To::rep>::value)>
 To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
                       int& ec) {
   using From = std::chrono::duration<FromRep, FromPeriod>;
@@ -201,8 +201,8 @@ To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
  * safe duration_cast between floating point durations
  */
 template <typename To, typename FromRep, typename FromPeriod,
-          FMT_ENABLE_IF(std::is_floating_point<FromRep>::value),
-          FMT_ENABLE_IF(std::is_floating_point<typename To::rep>::value)>
+          UMPIRE_FMT_ENABLE_IF(std::is_floating_point<FromRep>::value),
+          UMPIRE_FMT_ENABLE_IF(std::is_floating_point<typename To::rep>::value)>
 To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
                       int& ec) {
   using From = std::chrono::duration<FromRep, FromPeriod>;
@@ -279,11 +279,11 @@ To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
 #endif
 
 // Prevents expansion of a preceding token as a function-style macro.
-// Usage: f FMT_NOMACRO()
-#define FMT_NOMACRO
+// Usage: f UMPIRE_FMT_NOMACRO()
+#define UMPIRE_FMT_NOMACRO
 
 namespace detail {
-inline null<> localtime_r FMT_NOMACRO(...) { return null<>(); }
+inline null<> localtime_r UMPIRE_FMT_NOMACRO(...) { return null<>(); }
 inline null<> localtime_s(...) { return null<>(); }
 inline null<> gmtime_r(...) { return null<>(); }
 inline null<> gmtime_s(...) { return null<>(); }
@@ -315,7 +315,7 @@ inline std::tm localtime(std::time_t time) {
 
     bool fallback(int res) { return res == 0; }
 
-#if !FMT_MSC_VER
+#if !UMPIRE_FMT_MSC_VER
     bool fallback(detail::null<>) {
       using namespace umpire::fmt::detail;
       std::tm* tm = std::localtime(&time_);
@@ -326,7 +326,7 @@ inline std::tm localtime(std::time_t time) {
   };
   dispatcher lt(time);
   // Too big time values may be unsupported.
-  if (!lt.run()) FMT_THROW(format_error("time_t value out of range"));
+  if (!lt.run()) UMPIRE_FMT_THROW(format_error("time_t value out of range"));
   return lt.tm_;
 }
 
@@ -361,7 +361,7 @@ inline std::tm gmtime(std::time_t time) {
 
     bool fallback(int res) { return res == 0; }
 
-#if !FMT_MSC_VER
+#if !UMPIRE_FMT_MSC_VER
     bool fallback(detail::null<>) {
       std::tm* tm = std::gmtime(&time_);
       if (tm) tm_ = *tm;
@@ -371,7 +371,7 @@ inline std::tm gmtime(std::time_t time) {
   };
   dispatcher gt(time);
   // Too big time values may be unsupported.
-  if (!gt.run()) FMT_THROW(format_error("time_t value out of range"));
+  if (!gt.run()) UMPIRE_FMT_THROW(format_error("time_t value out of range"));
   return gt.tm_;
 }
 
@@ -414,7 +414,7 @@ struct formatter<std::chrono::time_point<std::chrono::system_clock>, Char>
 
 template <typename Char> struct formatter<std::tm, Char> {
   template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  UMPIRE_FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
     auto it = ctx.begin();
     if (it != ctx.end() && *it == ':') ++it;
     auto end = it;
@@ -455,64 +455,64 @@ template <typename Char> struct formatter<std::tm, Char> {
 };
 
 namespace detail {
-template <typename Period> FMT_CONSTEXPR const char* get_units() {
+template <typename Period> UMPIRE_FMT_CONSTEXPR const char* get_units() {
   return nullptr;
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::atto>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::atto>() {
   return "as";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::femto>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::femto>() {
   return "fs";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::pico>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::pico>() {
   return "ps";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::nano>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::nano>() {
   return "ns";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::micro>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::micro>() {
   return "µs";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::milli>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::milli>() {
   return "ms";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::centi>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::centi>() {
   return "cs";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::deci>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::deci>() {
   return "ds";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::ratio<1>>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::ratio<1>>() {
   return "s";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::deca>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::deca>() {
   return "das";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::hecto>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::hecto>() {
   return "hs";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::kilo>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::kilo>() {
   return "ks";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::mega>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::mega>() {
   return "Ms";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::giga>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::giga>() {
   return "Gs";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::tera>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::tera>() {
   return "Ts";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::peta>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::peta>() {
   return "Ps";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::exa>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::exa>() {
   return "Es";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::ratio<60>>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::ratio<60>>() {
   return "m";
 }
-template <> FMT_CONSTEXPR inline const char* get_units<std::ratio<3600>>() {
+template <> UMPIRE_FMT_CONSTEXPR inline const char* get_units<std::ratio<3600>>() {
   return "h";
 }
 
@@ -524,7 +524,7 @@ enum class numeric_system {
 
 // Parses a put_time-like format string and invokes handler actions.
 template <typename Char, typename Handler>
-FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
+UMPIRE_FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
                                               const Char* end,
                                               Handler&& handler) {
   auto ptr = begin;
@@ -537,7 +537,7 @@ FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
     }
     if (begin != ptr) handler.on_text(begin, ptr);
     ++ptr;  // consume '%'
-    if (ptr == end) FMT_THROW(format_error("invalid format"));
+    if (ptr == end) UMPIRE_FMT_THROW(format_error("invalid format"));
     c = *ptr++;
     switch (c) {
     case '%':
@@ -628,7 +628,7 @@ FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
       break;
     // Alternative representation:
     case 'E': {
-      if (ptr == end) FMT_THROW(format_error("invalid format"));
+      if (ptr == end) UMPIRE_FMT_THROW(format_error("invalid format"));
       c = *ptr++;
       switch (c) {
       case 'c':
@@ -641,12 +641,12 @@ FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
         handler.on_loc_time(numeric_system::alternative);
         break;
       default:
-        FMT_THROW(format_error("invalid format"));
+        UMPIRE_FMT_THROW(format_error("invalid format"));
       }
       break;
     }
     case 'O':
-      if (ptr == end) FMT_THROW(format_error("invalid format"));
+      if (ptr == end) UMPIRE_FMT_THROW(format_error("invalid format"));
       c = *ptr++;
       switch (c) {
       case 'w':
@@ -668,11 +668,11 @@ FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
         handler.on_second(numeric_system::alternative);
         break;
       default:
-        FMT_THROW(format_error("invalid format"));
+        UMPIRE_FMT_THROW(format_error("invalid format"));
       }
       break;
     default:
-      FMT_THROW(format_error("invalid format"));
+      UMPIRE_FMT_THROW(format_error("invalid format"));
     }
     begin = ptr;
   }
@@ -681,75 +681,75 @@ FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
 }
 
 struct chrono_format_checker {
-  FMT_NORETURN void report_no_date() { FMT_THROW(format_error("no date")); }
+  UMPIRE_FMT_NORETURN void report_no_date() { UMPIRE_FMT_THROW(format_error("no date")); }
 
   template <typename Char>
-  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
-  FMT_NORETURN void on_abbr_weekday() { report_no_date(); }
-  FMT_NORETURN void on_full_weekday() { report_no_date(); }
-  FMT_NORETURN void on_dec0_weekday(numeric_system) { report_no_date(); }
-  FMT_NORETURN void on_dec1_weekday(numeric_system) { report_no_date(); }
-  FMT_NORETURN void on_abbr_month() { report_no_date(); }
-  FMT_NORETURN void on_full_month() { report_no_date(); }
-  FMT_CONSTEXPR void on_24_hour(numeric_system) {}
-  FMT_CONSTEXPR void on_12_hour(numeric_system) {}
-  FMT_CONSTEXPR void on_minute(numeric_system) {}
-  FMT_CONSTEXPR void on_second(numeric_system) {}
-  FMT_NORETURN void on_datetime(numeric_system) { report_no_date(); }
-  FMT_NORETURN void on_loc_date(numeric_system) { report_no_date(); }
-  FMT_NORETURN void on_loc_time(numeric_system) { report_no_date(); }
-  FMT_NORETURN void on_us_date() { report_no_date(); }
-  FMT_NORETURN void on_iso_date() { report_no_date(); }
-  FMT_CONSTEXPR void on_12_hour_time() {}
-  FMT_CONSTEXPR void on_24_hour_time() {}
-  FMT_CONSTEXPR void on_iso_time() {}
-  FMT_CONSTEXPR void on_am_pm() {}
-  FMT_CONSTEXPR void on_duration_value() {}
-  FMT_CONSTEXPR void on_duration_unit() {}
-  FMT_NORETURN void on_utc_offset() { report_no_date(); }
-  FMT_NORETURN void on_tz_name() { report_no_date(); }
+  UMPIRE_FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
+  UMPIRE_FMT_NORETURN void on_abbr_weekday() { report_no_date(); }
+  UMPIRE_FMT_NORETURN void on_full_weekday() { report_no_date(); }
+  UMPIRE_FMT_NORETURN void on_dec0_weekday(numeric_system) { report_no_date(); }
+  UMPIRE_FMT_NORETURN void on_dec1_weekday(numeric_system) { report_no_date(); }
+  UMPIRE_FMT_NORETURN void on_abbr_month() { report_no_date(); }
+  UMPIRE_FMT_NORETURN void on_full_month() { report_no_date(); }
+  UMPIRE_FMT_CONSTEXPR void on_24_hour(numeric_system) {}
+  UMPIRE_FMT_CONSTEXPR void on_12_hour(numeric_system) {}
+  UMPIRE_FMT_CONSTEXPR void on_minute(numeric_system) {}
+  UMPIRE_FMT_CONSTEXPR void on_second(numeric_system) {}
+  UMPIRE_FMT_NORETURN void on_datetime(numeric_system) { report_no_date(); }
+  UMPIRE_FMT_NORETURN void on_loc_date(numeric_system) { report_no_date(); }
+  UMPIRE_FMT_NORETURN void on_loc_time(numeric_system) { report_no_date(); }
+  UMPIRE_FMT_NORETURN void on_us_date() { report_no_date(); }
+  UMPIRE_FMT_NORETURN void on_iso_date() { report_no_date(); }
+  UMPIRE_FMT_CONSTEXPR void on_12_hour_time() {}
+  UMPIRE_FMT_CONSTEXPR void on_24_hour_time() {}
+  UMPIRE_FMT_CONSTEXPR void on_iso_time() {}
+  UMPIRE_FMT_CONSTEXPR void on_am_pm() {}
+  UMPIRE_FMT_CONSTEXPR void on_duration_value() {}
+  UMPIRE_FMT_CONSTEXPR void on_duration_unit() {}
+  UMPIRE_FMT_NORETURN void on_utc_offset() { report_no_date(); }
+  UMPIRE_FMT_NORETURN void on_tz_name() { report_no_date(); }
 };
 
-template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_integral<T>::value)>
 inline bool isnan(T) {
   return false;
 }
-template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
+template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_floating_point<T>::value)>
 inline bool isnan(T value) {
   return std::isnan(value);
 }
 
-template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_integral<T>::value)>
 inline bool isfinite(T) {
   return true;
 }
-template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
+template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_floating_point<T>::value)>
 inline bool isfinite(T value) {
   return std::isfinite(value);
 }
 
 // Converts value to int and checks that it's in the range [0, upper).
-template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_integral<T>::value)>
 inline int to_nonnegative_int(T value, int upper) {
-  FMT_ASSERT(value >= 0 && to_unsigned(value) <= to_unsigned(upper),
+  UMPIRE_FMT_ASSERT(value >= 0 && to_unsigned(value) <= to_unsigned(upper),
              "invalid value");
   (void)upper;
   return static_cast<int>(value);
 }
-template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+template <typename T, UMPIRE_FMT_ENABLE_IF(!std::is_integral<T>::value)>
 inline int to_nonnegative_int(T value, int upper) {
-  FMT_ASSERT(
+  UMPIRE_FMT_ASSERT(
       std::isnan(value) || (value >= 0 && value <= static_cast<T>(upper)),
       "invalid value");
   (void)upper;
   return static_cast<int>(value);
 }
 
-template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_integral<T>::value)>
 inline T mod(T x, int y) {
   return x % static_cast<T>(y);
 }
-template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
+template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_floating_point<T>::value)>
 inline T mod(T x, int y) {
   return std::fmod(x, static_cast<T>(y));
 }
@@ -765,24 +765,24 @@ template <typename T> struct make_unsigned_or_unchanged<T, true> {
   using type = typename std::make_unsigned<T>::type;
 };
 
-#if FMT_SAFE_DURATION_CAST
+#if UMPIRE_FMT_SAFE_DURATION_CAST
 // throwing version of safe_duration_cast
 template <typename To, typename FromRep, typename FromPeriod>
 To fmt_safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) {
   int ec;
   To to = safe_duration_cast::safe_duration_cast<To>(from, ec);
-  if (ec) FMT_THROW(format_error("cannot format duration"));
+  if (ec) UMPIRE_FMT_THROW(format_error("cannot format duration"));
   return to;
 }
 #endif
 
 template <typename Rep, typename Period,
-          FMT_ENABLE_IF(std::is_integral<Rep>::value)>
+          UMPIRE_FMT_ENABLE_IF(std::is_integral<Rep>::value)>
 inline std::chrono::duration<Rep, std::milli> get_milliseconds(
     std::chrono::duration<Rep, Period> d) {
   // this may overflow and/or the result may not fit in the
   // target type.
-#if FMT_SAFE_DURATION_CAST
+#if UMPIRE_FMT_SAFE_DURATION_CAST
   using CommonSecondsType =
       typename std::common_type<decltype(d), std::chrono::seconds>::type;
   const auto d_as_common = fmt_safe_duration_cast<CommonSecondsType>(d);
@@ -800,7 +800,7 @@ inline std::chrono::duration<Rep, std::milli> get_milliseconds(
 }
 
 template <typename Rep, typename Period,
-          FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>
+          UMPIRE_FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>
 inline std::chrono::duration<Rep, std::milli> get_milliseconds(
     std::chrono::duration<Rep, Period> d) {
   using common_type = typename std::common_type<Rep, std::intmax_t>::type;
@@ -811,13 +811,13 @@ inline std::chrono::duration<Rep, std::milli> get_milliseconds(
 }
 
 template <typename Char, typename Rep, typename OutputIt,
-          FMT_ENABLE_IF(std::is_integral<Rep>::value)>
+          UMPIRE_FMT_ENABLE_IF(std::is_integral<Rep>::value)>
 OutputIt format_duration_value(OutputIt out, Rep val, int) {
   return write<Char>(out, val);
 }
 
 template <typename Char, typename Rep, typename OutputIt,
-          FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>
+          UMPIRE_FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>
 OutputIt format_duration_value(OutputIt out, Rep val, int precision) {
   auto specs = basic_format_specs<Char>();
   specs.precision = precision;
@@ -884,7 +884,7 @@ struct chrono_formatter {
 
     // this may overflow and/or the result may not fit in the
     // target type.
-#if FMT_SAFE_DURATION_CAST
+#if UMPIRE_FMT_SAFE_DURATION_CAST
     // might need checked conversion (rep!=Rep)
     auto tmpval = std::chrono::duration<rep, Period>(val);
     s = fmt_safe_duration_cast<seconds>(tmpval);
@@ -1013,7 +1013,7 @@ struct chrono_formatter {
 
     if (ns == numeric_system::standard) {
       write(second(), 2);
-#if FMT_SAFE_DURATION_CAST
+#if UMPIRE_FMT_SAFE_DURATION_CAST
       // convert rep->Rep
       using duration_rep = std::chrono::duration<rep, Period>;
       using duration_Rep = std::chrono::duration<Rep, Period>;
@@ -1090,36 +1090,36 @@ struct formatter<std::chrono::duration<Rep, Period>, Char> {
     basic_format_parse_context<Char>& context;
     basic_string_view<Char> format_str;
 
-    template <typename Id> FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {
+    template <typename Id> UMPIRE_FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {
       context.check_arg_id(arg_id);
       return arg_ref_type(arg_id);
     }
 
-    FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<Char> arg_id) {
+    UMPIRE_FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<Char> arg_id) {
       context.check_arg_id(arg_id);
       return arg_ref_type(arg_id);
     }
 
-    FMT_CONSTEXPR arg_ref_type make_arg_ref(detail::auto_id) {
+    UMPIRE_FMT_CONSTEXPR arg_ref_type make_arg_ref(detail::auto_id) {
       return arg_ref_type(context.next_arg_id());
     }
 
-    void on_error(const char* msg) { FMT_THROW(format_error(msg)); }
-    FMT_CONSTEXPR void on_fill(basic_string_view<Char> fill) {
+    void on_error(const char* msg) { UMPIRE_FMT_THROW(format_error(msg)); }
+    UMPIRE_FMT_CONSTEXPR void on_fill(basic_string_view<Char> fill) {
       f.specs.fill = fill;
     }
-    FMT_CONSTEXPR void on_align(align_t align) { f.specs.align = align; }
-    FMT_CONSTEXPR void on_width(int width) { f.specs.width = width; }
-    FMT_CONSTEXPR void on_precision(int _precision) {
+    UMPIRE_FMT_CONSTEXPR void on_align(align_t align) { f.specs.align = align; }
+    UMPIRE_FMT_CONSTEXPR void on_width(int width) { f.specs.width = width; }
+    UMPIRE_FMT_CONSTEXPR void on_precision(int _precision) {
       f.precision = _precision;
     }
-    FMT_CONSTEXPR void end_precision() {}
+    UMPIRE_FMT_CONSTEXPR void end_precision() {}
 
-    template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
+    template <typename Id> UMPIRE_FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
       f.width_ref = make_arg_ref(arg_id);
     }
 
-    template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
+    template <typename Id> UMPIRE_FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
       f.precision_ref = make_arg_ref(arg_id);
     }
   };
@@ -1130,7 +1130,7 @@ struct formatter<std::chrono::duration<Rep, Period>, Char> {
     iterator end;
   };
 
-  FMT_CONSTEXPR parse_range do_parse(basic_format_parse_context<Char>& ctx) {
+  UMPIRE_FMT_CONSTEXPR parse_range do_parse(basic_format_parse_context<Char>& ctx) {
     auto begin = ctx.begin(), end = ctx.end();
     if (begin == end || *begin == '}') return {begin, begin};
     spec_handler handler{*this, ctx, format_str};
@@ -1149,7 +1149,7 @@ struct formatter<std::chrono::duration<Rep, Period>, Char> {
   }
 
  public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
+  UMPIRE_FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
       -> decltype(ctx.begin()) {
     auto range = do_parse(ctx);
     format_str = basic_string_view<Char>(
@@ -1185,6 +1185,6 @@ struct formatter<std::chrono::duration<Rep, Period>, Char> {
   }
 };
 
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_CHRONO_H_
+#endif  // UMPIRE_FMT_CHRONO_H_
diff --git a/src/tpl/umpire/fmt/color.h b/src/tpl/umpire/fmt/color.h
index 73e62b855..21037c37d 100644
--- a/src/tpl/umpire/fmt/color.h
+++ b/src/tpl/umpire/fmt/color.h
@@ -5,19 +5,19 @@
 //
 // For the license information refer to format.h.
 
-#ifndef FMT_COLOR_H_
-#define FMT_COLOR_H_
+#ifndef UMPIRE_FMT_COLOR_H_
+#define UMPIRE_FMT_COLOR_H_
 
 #include "format.h"
 
 // __declspec(deprecated) is broken in some MSVC versions.
-#if FMT_MSC_VER
-#  define FMT_DEPRECATED_NONMSVC
+#if UMPIRE_FMT_MSC_VER
+#  define UMPIRE_FMT_DEPRECATED_NONMSVC
 #else
-#  define FMT_DEPRECATED_NONMSVC FMT_DEPRECATED
+#  define UMPIRE_FMT_DEPRECATED_NONMSVC UMPIRE_FMT_DEPRECATED
 #endif
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 
 enum class color : uint32_t {
   alice_blue = 0xF0F8FF,               // rgb(240,248,255)
@@ -192,11 +192,11 @@ enum class emphasis : uint8_t {
 // rgb is a struct for red, green and blue colors.
 // Using the name "rgb" makes some editors show the color in a tooltip.
 struct rgb {
-  FMT_CONSTEXPR rgb() : r(0), g(0), b(0) {}
-  FMT_CONSTEXPR rgb(uint8_t r_, uint8_t g_, uint8_t b_) : r(r_), g(g_), b(b_) {}
-  FMT_CONSTEXPR rgb(uint32_t hex)
+  UMPIRE_FMT_CONSTEXPR rgb() : r(0), g(0), b(0) {}
+  UMPIRE_FMT_CONSTEXPR rgb(uint8_t r_, uint8_t g_, uint8_t b_) : r(r_), g(g_), b(b_) {}
+  UMPIRE_FMT_CONSTEXPR rgb(uint32_t hex)
       : r((hex >> 16) & 0xFF), g((hex >> 8) & 0xFF), b(hex & 0xFF) {}
-  FMT_CONSTEXPR rgb(color hex)
+  UMPIRE_FMT_CONSTEXPR rgb(color hex)
       : r((uint32_t(hex) >> 16) & 0xFF),
         g((uint32_t(hex) >> 8) & 0xFF),
         b(uint32_t(hex) & 0xFF) {}
@@ -209,16 +209,16 @@ namespace detail {
 
 // color is a struct of either a rgb color or a terminal color.
 struct color_type {
-  FMT_CONSTEXPR color_type() FMT_NOEXCEPT : is_rgb(), value{} {}
-  FMT_CONSTEXPR color_type(color rgb_color) FMT_NOEXCEPT : is_rgb(true),
+  UMPIRE_FMT_CONSTEXPR color_type() UMPIRE_FMT_NOEXCEPT : is_rgb(), value{} {}
+  UMPIRE_FMT_CONSTEXPR color_type(color rgb_color) UMPIRE_FMT_NOEXCEPT : is_rgb(true),
                                                            value{} {
     value.rgb_color = static_cast<uint32_t>(rgb_color);
   }
-  FMT_CONSTEXPR color_type(rgb rgb_color) FMT_NOEXCEPT : is_rgb(true), value{} {
+  UMPIRE_FMT_CONSTEXPR color_type(rgb rgb_color) UMPIRE_FMT_NOEXCEPT : is_rgb(true), value{} {
     value.rgb_color = (static_cast<uint32_t>(rgb_color.r) << 16) |
                       (static_cast<uint32_t>(rgb_color.g) << 8) | rgb_color.b;
   }
-  FMT_CONSTEXPR color_type(terminal_color term_color) FMT_NOEXCEPT : is_rgb(),
+  UMPIRE_FMT_CONSTEXPR color_type(terminal_color term_color) UMPIRE_FMT_NOEXCEPT : is_rgb(),
                                                                      value{} {
     value.term_color = static_cast<uint8_t>(term_color);
   }
@@ -233,18 +233,18 @@ struct color_type {
 /** A text style consisting of foreground and background colors and emphasis. */
 class text_style {
  public:
-  FMT_CONSTEXPR text_style(emphasis em = emphasis()) FMT_NOEXCEPT
+  UMPIRE_FMT_CONSTEXPR text_style(emphasis em = emphasis()) UMPIRE_FMT_NOEXCEPT
       : set_foreground_color(),
         set_background_color(),
         ems(em) {}
 
-  FMT_CONSTEXPR text_style& operator|=(const text_style& rhs) {
+  UMPIRE_FMT_CONSTEXPR text_style& operator|=(const text_style& rhs) {
     if (!set_foreground_color) {
       set_foreground_color = rhs.set_foreground_color;
       foreground_color = rhs.foreground_color;
     } else if (rhs.set_foreground_color) {
       if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)
-        FMT_THROW(format_error("can't OR a terminal color"));
+        UMPIRE_FMT_THROW(format_error("can't OR a terminal color"));
       foreground_color.value.rgb_color |= rhs.foreground_color.value.rgb_color;
     }
 
@@ -253,7 +253,7 @@ class text_style {
       background_color = rhs.background_color;
     } else if (rhs.set_background_color) {
       if (!background_color.is_rgb || !rhs.background_color.is_rgb)
-        FMT_THROW(format_error("can't OR a terminal color"));
+        UMPIRE_FMT_THROW(format_error("can't OR a terminal color"));
       background_color.value.rgb_color |= rhs.background_color.value.rgb_color;
     }
 
@@ -262,46 +262,46 @@ class text_style {
     return *this;
   }
 
-  friend FMT_CONSTEXPR text_style operator|(text_style lhs,
+  friend UMPIRE_FMT_CONSTEXPR text_style operator|(text_style lhs,
                                             const text_style& rhs) {
     return lhs |= rhs;
   }
 
-  FMT_DEPRECATED_NONMSVC FMT_CONSTEXPR text_style& operator&=(
+  UMPIRE_FMT_DEPRECATED_NONMSVC UMPIRE_FMT_CONSTEXPR text_style& operator&=(
       const text_style& rhs) {
     return and_assign(rhs);
   }
 
-  FMT_DEPRECATED_NONMSVC friend FMT_CONSTEXPR text_style
+  UMPIRE_FMT_DEPRECATED_NONMSVC friend UMPIRE_FMT_CONSTEXPR text_style
   operator&(text_style lhs, const text_style& rhs) {
     return lhs.and_assign(rhs);
   }
 
-  FMT_CONSTEXPR bool has_foreground() const FMT_NOEXCEPT {
+  UMPIRE_FMT_CONSTEXPR bool has_foreground() const UMPIRE_FMT_NOEXCEPT {
     return set_foreground_color;
   }
-  FMT_CONSTEXPR bool has_background() const FMT_NOEXCEPT {
+  UMPIRE_FMT_CONSTEXPR bool has_background() const UMPIRE_FMT_NOEXCEPT {
     return set_background_color;
   }
-  FMT_CONSTEXPR bool has_emphasis() const FMT_NOEXCEPT {
+  UMPIRE_FMT_CONSTEXPR bool has_emphasis() const UMPIRE_FMT_NOEXCEPT {
     return static_cast<uint8_t>(ems) != 0;
   }
-  FMT_CONSTEXPR detail::color_type get_foreground() const FMT_NOEXCEPT {
-    FMT_ASSERT(has_foreground(), "no foreground specified for this style");
+  UMPIRE_FMT_CONSTEXPR detail::color_type get_foreground() const UMPIRE_FMT_NOEXCEPT {
+    UMPIRE_FMT_ASSERT(has_foreground(), "no foreground specified for this style");
     return foreground_color;
   }
-  FMT_CONSTEXPR detail::color_type get_background() const FMT_NOEXCEPT {
-    FMT_ASSERT(has_background(), "no background specified for this style");
+  UMPIRE_FMT_CONSTEXPR detail::color_type get_background() const UMPIRE_FMT_NOEXCEPT {
+    UMPIRE_FMT_ASSERT(has_background(), "no background specified for this style");
     return background_color;
   }
-  FMT_CONSTEXPR emphasis get_emphasis() const FMT_NOEXCEPT {
-    FMT_ASSERT(has_emphasis(), "no emphasis specified for this style");
+  UMPIRE_FMT_CONSTEXPR emphasis get_emphasis() const UMPIRE_FMT_NOEXCEPT {
+    UMPIRE_FMT_ASSERT(has_emphasis(), "no emphasis specified for this style");
     return ems;
   }
 
  private:
-  FMT_CONSTEXPR text_style(bool is_foreground,
-                           detail::color_type text_color) FMT_NOEXCEPT
+  UMPIRE_FMT_CONSTEXPR text_style(bool is_foreground,
+                           detail::color_type text_color) UMPIRE_FMT_NOEXCEPT
       : set_foreground_color(),
         set_background_color(),
         ems() {
@@ -315,13 +315,13 @@ class text_style {
   }
 
   // DEPRECATED!
-  FMT_CONSTEXPR text_style& and_assign(const text_style& rhs) {
+  UMPIRE_FMT_CONSTEXPR text_style& and_assign(const text_style& rhs) {
     if (!set_foreground_color) {
       set_foreground_color = rhs.set_foreground_color;
       foreground_color = rhs.foreground_color;
     } else if (rhs.set_foreground_color) {
       if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)
-        FMT_THROW(format_error("can't AND a terminal color"));
+        UMPIRE_FMT_THROW(format_error("can't AND a terminal color"));
       foreground_color.value.rgb_color &= rhs.foreground_color.value.rgb_color;
     }
 
@@ -330,7 +330,7 @@ class text_style {
       background_color = rhs.background_color;
     } else if (rhs.set_background_color) {
       if (!background_color.is_rgb || !rhs.background_color.is_rgb)
-        FMT_THROW(format_error("can't AND a terminal color"));
+        UMPIRE_FMT_THROW(format_error("can't AND a terminal color"));
       background_color.value.rgb_color &= rhs.background_color.value.rgb_color;
     }
 
@@ -339,11 +339,11 @@ class text_style {
     return *this;
   }
 
-  friend FMT_CONSTEXPR_DECL text_style fg(detail::color_type foreground)
-      FMT_NOEXCEPT;
+  friend UMPIRE_FMT_CONSTEXPR_DECL text_style fg(detail::color_type foreground)
+      UMPIRE_FMT_NOEXCEPT;
 
-  friend FMT_CONSTEXPR_DECL text_style bg(detail::color_type background)
-      FMT_NOEXCEPT;
+  friend UMPIRE_FMT_CONSTEXPR_DECL text_style bg(detail::color_type background)
+      UMPIRE_FMT_NOEXCEPT;
 
   detail::color_type foreground_color;
   detail::color_type background_color;
@@ -353,25 +353,25 @@ class text_style {
 };
 
 /** Creates a text style from the foreground (text) color. */
-FMT_CONSTEXPR inline text_style fg(detail::color_type foreground) FMT_NOEXCEPT {
+UMPIRE_FMT_CONSTEXPR inline text_style fg(detail::color_type foreground) UMPIRE_FMT_NOEXCEPT {
   return text_style(true, foreground);
 }
 
 /** Creates a text style from the background color. */
-FMT_CONSTEXPR inline text_style bg(detail::color_type background) FMT_NOEXCEPT {
+UMPIRE_FMT_CONSTEXPR inline text_style bg(detail::color_type background) UMPIRE_FMT_NOEXCEPT {
   return text_style(false, background);
 }
 
-FMT_CONSTEXPR inline text_style operator|(emphasis lhs,
-                                          emphasis rhs) FMT_NOEXCEPT {
+UMPIRE_FMT_CONSTEXPR inline text_style operator|(emphasis lhs,
+                                          emphasis rhs) UMPIRE_FMT_NOEXCEPT {
   return text_style(lhs) | rhs;
 }
 
 namespace detail {
 
 template <typename Char> struct ansi_color_escape {
-  FMT_CONSTEXPR ansi_color_escape(detail::color_type text_color,
-                                  const char* esc) FMT_NOEXCEPT {
+  UMPIRE_FMT_CONSTEXPR ansi_color_escape(detail::color_type text_color,
+                                  const char* esc) UMPIRE_FMT_NOEXCEPT {
     // If we have a terminal color, we need to output another escape code
     // sequence.
     if (!text_color.is_rgb) {
@@ -406,7 +406,7 @@ template <typename Char> struct ansi_color_escape {
     to_esc(color.b, buffer + 15, 'm');
     buffer[19] = static_cast<Char>(0);
   }
-  FMT_CONSTEXPR ansi_color_escape(emphasis em) FMT_NOEXCEPT {
+  UMPIRE_FMT_CONSTEXPR ansi_color_escape(emphasis em) UMPIRE_FMT_NOEXCEPT {
     uint8_t em_codes[4] = {};
     uint8_t em_bits = static_cast<uint8_t>(em);
     if (em_bits & static_cast<uint8_t>(emphasis::bold)) em_codes[0] = 1;
@@ -425,18 +425,18 @@ template <typename Char> struct ansi_color_escape {
     }
     buffer[index++] = static_cast<Char>(0);
   }
-  FMT_CONSTEXPR operator const Char*() const FMT_NOEXCEPT { return buffer; }
+  UMPIRE_FMT_CONSTEXPR operator const Char*() const UMPIRE_FMT_NOEXCEPT { return buffer; }
 
-  FMT_CONSTEXPR const Char* begin() const FMT_NOEXCEPT { return buffer; }
-  FMT_CONSTEXPR const Char* end() const FMT_NOEXCEPT {
+  UMPIRE_FMT_CONSTEXPR const Char* begin() const UMPIRE_FMT_NOEXCEPT { return buffer; }
+  UMPIRE_FMT_CONSTEXPR const Char* end() const UMPIRE_FMT_NOEXCEPT {
     return buffer + std::char_traits<Char>::length(buffer);
   }
 
  private:
   Char buffer[7u + 3u * 4u + 1u];
 
-  static FMT_CONSTEXPR void to_esc(uint8_t c, Char* out,
-                                   char delimiter) FMT_NOEXCEPT {
+  static UMPIRE_FMT_CONSTEXPR void to_esc(uint8_t c, Char* out,
+                                   char delimiter) UMPIRE_FMT_NOEXCEPT {
     out[0] = static_cast<Char>('0' + c / 100);
     out[1] = static_cast<Char>('0' + c / 10 % 10);
     out[2] = static_cast<Char>('0' + c % 10);
@@ -445,42 +445,42 @@ template <typename Char> struct ansi_color_escape {
 };
 
 template <typename Char>
-FMT_CONSTEXPR ansi_color_escape<Char> make_foreground_color(
-    detail::color_type foreground) FMT_NOEXCEPT {
+UMPIRE_FMT_CONSTEXPR ansi_color_escape<Char> make_foreground_color(
+    detail::color_type foreground) UMPIRE_FMT_NOEXCEPT {
   return ansi_color_escape<Char>(foreground, detail::data::foreground_color);
 }
 
 template <typename Char>
-FMT_CONSTEXPR ansi_color_escape<Char> make_background_color(
-    detail::color_type background) FMT_NOEXCEPT {
+UMPIRE_FMT_CONSTEXPR ansi_color_escape<Char> make_background_color(
+    detail::color_type background) UMPIRE_FMT_NOEXCEPT {
   return ansi_color_escape<Char>(background, detail::data::background_color);
 }
 
 template <typename Char>
-FMT_CONSTEXPR ansi_color_escape<Char> make_emphasis(emphasis em) FMT_NOEXCEPT {
+UMPIRE_FMT_CONSTEXPR ansi_color_escape<Char> make_emphasis(emphasis em) UMPIRE_FMT_NOEXCEPT {
   return ansi_color_escape<Char>(em);
 }
 
 template <typename Char>
-inline void fputs(const Char* chars, FILE* stream) FMT_NOEXCEPT {
+inline void fputs(const Char* chars, FILE* stream) UMPIRE_FMT_NOEXCEPT {
   std::fputs(chars, stream);
 }
 
 template <>
-inline void fputs<wchar_t>(const wchar_t* chars, FILE* stream) FMT_NOEXCEPT {
+inline void fputs<wchar_t>(const wchar_t* chars, FILE* stream) UMPIRE_FMT_NOEXCEPT {
   std::fputws(chars, stream);
 }
 
-template <typename Char> inline void reset_color(FILE* stream) FMT_NOEXCEPT {
+template <typename Char> inline void reset_color(FILE* stream) UMPIRE_FMT_NOEXCEPT {
   fputs(detail::data::reset_color, stream);
 }
 
-template <> inline void reset_color<wchar_t>(FILE* stream) FMT_NOEXCEPT {
+template <> inline void reset_color<wchar_t>(FILE* stream) UMPIRE_FMT_NOEXCEPT {
   fputs(detail::data::wreset_color, stream);
 }
 
 template <typename Char>
-inline void reset_color(buffer<Char>& buffer) FMT_NOEXCEPT {
+inline void reset_color(buffer<Char>& buffer) UMPIRE_FMT_NOEXCEPT {
   const char* begin = data::reset_color;
   const char* end = begin + sizeof(data::reset_color) - 1;
   buffer.append(begin, end);
@@ -532,7 +532,7 @@ void vprint(std::FILE* f, const text_style& ts, const S& format,
   \endrst
  */
 template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_string<S>::value)>
+          UMPIRE_FMT_ENABLE_IF(detail::is_string<S>::value)>
 void print(std::FILE* f, const text_style& ts, const S& format_str,
            const Args&... args) {
   vprint(f, ts, format_str,
@@ -551,7 +551,7 @@ void print(std::FILE* f, const text_style& ts, const S& format_str,
   \endrst
  */
 template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_string<S>::value)>
+          UMPIRE_FMT_ENABLE_IF(detail::is_string<S>::value)>
 void print(const text_style& ts, const S& format_str, const Args&... args) {
   return print(stdout, ts, format_str, args...);
 }
@@ -588,7 +588,7 @@ inline std::basic_string<Char> format(const text_style& ts, const S& format_str,
   Formats a string with the given text_style and writes the output to ``out``.
  */
 template <typename OutputIt, typename Char,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value)>
+          UMPIRE_FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value)>
 OutputIt vformat_to(
     OutputIt out, const text_style& ts, basic_string_view<Char> format_str,
     basic_format_args<buffer_context<type_identity_t<Char>>> args) {
@@ -619,6 +619,6 @@ inline auto format_to(OutputIt out, const text_style& ts, const S& format_str,
                     umpire::fmt::make_args_checked<Args...>(format_str, args...));
 }
 
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_COLOR_H_
+#endif  // UMPIRE_FMT_COLOR_H_
diff --git a/src/tpl/umpire/fmt/compile.h b/src/tpl/umpire/fmt/compile.h
index 3bcad028d..f9ef346c0 100644
--- a/src/tpl/umpire/fmt/compile.h
+++ b/src/tpl/umpire/fmt/compile.h
@@ -5,24 +5,24 @@
 //
 // For the license information refer to format.h.
 
-#ifndef FMT_COMPILE_H_
-#define FMT_COMPILE_H_
+#ifndef UMPIRE_FMT_COMPILE_H_
+#define UMPIRE_FMT_COMPILE_H_
 
 #include <algorithm>
 #include <vector>
 
 #include "format.h"
 
-#ifndef FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
+#ifndef UMPIRE_FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
 #  if defined(__cpp_nontype_template_parameter_class) && \
-      (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 903)
-#    define FMT_USE_NONTYPE_TEMPLATE_PARAMETERS 1
+      (!UMPIRE_FMT_GCC_VERSION || UMPIRE_FMT_GCC_VERSION >= 903)
+#    define UMPIRE_FMT_USE_NONTYPE_TEMPLATE_PARAMETERS 1
 #  else
-#    define FMT_USE_NONTYPE_TEMPLATE_PARAMETERS 0
+#    define UMPIRE_FMT_USE_NONTYPE_TEMPLATE_PARAMETERS 0
 #  endif
 #endif
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 namespace detail {
 
 template <typename OutputIt> class truncating_iterator_base {
@@ -120,12 +120,12 @@ struct is_compiled_string : std::is_base_of<compiled_string, S> {};
 
     // Converts 42 into std::string using the most efficient method and no
     // runtime format string processing.
-    std::string s = umpire::fmt::format(FMT_COMPILE("{}"), 42);
+    std::string s = umpire::fmt::format(UMPIRE_FMT_COMPILE("{}"), 42);
   \endrst
  */
-#define FMT_COMPILE(s) FMT_STRING_IMPL(s, umpire::fmt::detail::compiled_string)
+#define UMPIRE_FMT_COMPILE(s) UMPIRE_FMT_STRING_IMPL(s, umpire::fmt::detail::compiled_string)
 
-#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
+#if UMPIRE_FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
 template <typename Char, size_t N> struct fixed_string {
   constexpr fixed_string(const Char (&str)[N]) {
     copy_str<Char, const Char*, Char*>(static_cast<const Char*>(str), str + N,
@@ -164,26 +164,26 @@ template <typename Char> struct format_part {
     basic_string_view<Char> str;
     replacement repl;
 
-    FMT_CONSTEXPR value(int index = 0) : arg_index(index) {}
-    FMT_CONSTEXPR value(basic_string_view<Char> s) : str(s) {}
-    FMT_CONSTEXPR value(replacement r) : repl(r) {}
+    UMPIRE_FMT_CONSTEXPR value(int index = 0) : arg_index(index) {}
+    UMPIRE_FMT_CONSTEXPR value(basic_string_view<Char> s) : str(s) {}
+    UMPIRE_FMT_CONSTEXPR value(replacement r) : repl(r) {}
   } val;
   // Position past the end of the argument id.
   const Char* arg_id_end = nullptr;
 
-  FMT_CONSTEXPR format_part(kind k = kind::arg_index, value v = {})
+  UMPIRE_FMT_CONSTEXPR format_part(kind k = kind::arg_index, value v = {})
       : part_kind(k), val(v) {}
 
-  static FMT_CONSTEXPR format_part make_arg_index(int index) {
+  static UMPIRE_FMT_CONSTEXPR format_part make_arg_index(int index) {
     return format_part(kind::arg_index, index);
   }
-  static FMT_CONSTEXPR format_part make_arg_name(basic_string_view<Char> name) {
+  static UMPIRE_FMT_CONSTEXPR format_part make_arg_name(basic_string_view<Char> name) {
     return format_part(kind::arg_name, name);
   }
-  static FMT_CONSTEXPR format_part make_text(basic_string_view<Char> text) {
+  static UMPIRE_FMT_CONSTEXPR format_part make_text(basic_string_view<Char> text) {
     return format_part(kind::text, text);
   }
-  static FMT_CONSTEXPR format_part make_replacement(replacement repl) {
+  static UMPIRE_FMT_CONSTEXPR format_part make_replacement(replacement repl) {
     return format_part(kind::replacement, repl);
   }
 };
@@ -191,19 +191,19 @@ template <typename Char> struct format_part {
 template <typename Char> struct part_counter {
   unsigned num_parts = 0;
 
-  FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
+  UMPIRE_FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
     if (begin != end) ++num_parts;
   }
 
-  FMT_CONSTEXPR int on_arg_id() { return ++num_parts, 0; }
-  FMT_CONSTEXPR int on_arg_id(int) { return ++num_parts, 0; }
-  FMT_CONSTEXPR int on_arg_id(basic_string_view<Char>) {
+  UMPIRE_FMT_CONSTEXPR int on_arg_id() { return ++num_parts, 0; }
+  UMPIRE_FMT_CONSTEXPR int on_arg_id(int) { return ++num_parts, 0; }
+  UMPIRE_FMT_CONSTEXPR int on_arg_id(basic_string_view<Char>) {
     return ++num_parts, 0;
   }
 
-  FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}
+  UMPIRE_FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}
 
-  FMT_CONSTEXPR const Char* on_format_specs(int, const Char* begin,
+  UMPIRE_FMT_CONSTEXPR const Char* on_format_specs(int, const Char* begin,
                                             const Char* end) {
     // Find the matching brace.
     unsigned brace_counter = 0;
@@ -218,12 +218,12 @@ template <typename Char> struct part_counter {
     return begin;
   }
 
-  FMT_CONSTEXPR void on_error(const char*) {}
+  UMPIRE_FMT_CONSTEXPR void on_error(const char*) {}
 };
 
 // Counts the number of parts in a format string.
 template <typename Char>
-FMT_CONSTEXPR unsigned count_parts(basic_string_view<Char> format_str) {
+UMPIRE_FMT_CONSTEXPR unsigned count_parts(basic_string_view<Char> format_str) {
   part_counter<Char> counter;
   parse_format_string<true>(format_str, counter);
   return counter.num_parts;
@@ -240,39 +240,39 @@ class format_string_compiler : public error_handler {
   basic_format_parse_context<Char> parse_context_;
 
  public:
-  FMT_CONSTEXPR format_string_compiler(basic_string_view<Char> format_str,
+  UMPIRE_FMT_CONSTEXPR format_string_compiler(basic_string_view<Char> format_str,
                                        PartHandler handler)
       : handler_(handler),
         format_str_(format_str),
         parse_context_(format_str) {}
 
-  FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
+  UMPIRE_FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
     if (begin != end)
       handler_(part::make_text({begin, to_unsigned(end - begin)}));
   }
 
-  FMT_CONSTEXPR int on_arg_id() {
+  UMPIRE_FMT_CONSTEXPR int on_arg_id() {
     part_ = part::make_arg_index(parse_context_.next_arg_id());
     return 0;
   }
 
-  FMT_CONSTEXPR int on_arg_id(int id) {
+  UMPIRE_FMT_CONSTEXPR int on_arg_id(int id) {
     parse_context_.check_arg_id(id);
     part_ = part::make_arg_index(id);
     return 0;
   }
 
-  FMT_CONSTEXPR int on_arg_id(basic_string_view<Char> id) {
+  UMPIRE_FMT_CONSTEXPR int on_arg_id(basic_string_view<Char> id) {
     part_ = part::make_arg_name(id);
     return 0;
   }
 
-  FMT_CONSTEXPR void on_replacement_field(int, const Char* ptr) {
+  UMPIRE_FMT_CONSTEXPR void on_replacement_field(int, const Char* ptr) {
     part_.arg_id_end = ptr;
     handler_(part_);
   }
 
-  FMT_CONSTEXPR const Char* on_format_specs(int, const Char* begin,
+  UMPIRE_FMT_CONSTEXPR const Char* on_format_specs(int, const Char* begin,
                                             const Char* end) {
     auto repl = typename part::replacement();
     dynamic_specs_handler<basic_format_parse_context<Char>> handler(
@@ -291,7 +291,7 @@ class format_string_compiler : public error_handler {
 
 // Compiles a format string and invokes handler(part) for each parsed part.
 template <bool IS_CONSTEXPR, typename Char, typename PartHandler>
-FMT_CONSTEXPR void compile_format_string(basic_string_view<Char> format_str,
+UMPIRE_FMT_CONSTEXPR void compile_format_string(basic_string_view<Char> format_str,
                                          PartHandler handler) {
   parse_format_string<IS_CONSTEXPR>(
       format_str,
@@ -402,11 +402,11 @@ struct compiled_format_base : basic_compiled_format {
 
 template <typename Char, unsigned N> struct format_part_array {
   format_part<Char> data[N] = {};
-  FMT_CONSTEXPR format_part_array() = default;
+  UMPIRE_FMT_CONSTEXPR format_part_array() = default;
 };
 
 template <typename Char, unsigned N>
-FMT_CONSTEXPR format_part_array<Char, N> compile_to_parts(
+UMPIRE_FMT_CONSTEXPR format_part_array<Char, N> compile_to_parts(
     basic_string_view<Char> format_str) {
   format_part_array<Char, N> parts;
   unsigned counter = 0;
@@ -414,7 +414,7 @@ FMT_CONSTEXPR format_part_array<Char, N> compile_to_parts(
   struct {
     format_part<Char>* parts;
     unsigned* counter;
-    FMT_CONSTEXPR void operator()(const format_part<Char>& part) {
+    UMPIRE_FMT_CONSTEXPR void operator()(const format_part<Char>& part) {
       parts[(*counter)++] = part;
     }
   } collector{parts.data, &counter};
@@ -435,12 +435,12 @@ struct compiled_format_base<S, enable_if_t<is_compile_string<S>::value>>
     : basic_compiled_format {
   using char_type = char_t<S>;
 
-  FMT_CONSTEXPR explicit compiled_format_base(basic_string_view<char_type>) {}
+  UMPIRE_FMT_CONSTEXPR explicit compiled_format_base(basic_string_view<char_type>) {}
 
 // Workaround for old compilers. Format string compilation will not be
 // performed there anyway.
-#if FMT_USE_CONSTEXPR
-  static FMT_CONSTEXPR_DECL const unsigned num_format_parts =
+#if UMPIRE_FMT_USE_CONSTEXPR
+  static UMPIRE_FMT_CONSTEXPR_DECL const unsigned num_format_parts =
       constexpr_max(count_parts(to_string_view(S())), 1u);
 #else
   static const unsigned num_format_parts = 1;
@@ -449,7 +449,7 @@ struct compiled_format_base<S, enable_if_t<is_compile_string<S>::value>>
   using parts_container = format_part<char_type>[num_format_parts];
 
   const parts_container& parts() const {
-    static FMT_CONSTEXPR_DECL const auto compiled_parts =
+    static UMPIRE_FMT_CONSTEXPR_DECL const auto compiled_parts =
         compile_to_parts<char_type, num_format_parts>(
             detail::to_string_view(S()));
     return compiled_parts.data;
@@ -676,7 +676,7 @@ template <typename Char> struct arg_id_handler {
   constexpr void on_error(const char* message) { throw format_error(message); }
 
   constexpr int on_arg_id() {
-    FMT_ASSERT(false, "handler cannot be used with automatic indexing");
+    UMPIRE_FMT_ASSERT(false, "handler cannot be used with automatic indexing");
     return 0;
   }
 
@@ -781,7 +781,7 @@ constexpr auto compile_format_string(S format_str) {
 }
 
 template <typename... Args, typename S,
-          FMT_ENABLE_IF(is_compile_string<S>::value ||
+          UMPIRE_FMT_ENABLE_IF(is_compile_string<S>::value ||
                         detail::is_compiled_string<S>::value)>
 constexpr auto compile(S format_str) {
   constexpr basic_string_view<typename S::char_type> str = format_str;
@@ -796,7 +796,7 @@ constexpr auto compile(S format_str) {
 }
 #else
 template <typename... Args, typename S,
-          FMT_ENABLE_IF(is_compile_string<S>::value)>
+          UMPIRE_FMT_ENABLE_IF(is_compile_string<S>::value)>
 constexpr auto compile(S format_str) -> detail::compiled_format<S, Args...> {
   return detail::compiled_format<S, Args...>(to_string_view(format_str));
 }
@@ -813,20 +813,20 @@ auto compile(const Char (&format_str)[N])
 }
 }  // namespace detail
 
-// DEPRECATED! use FMT_COMPILE instead.
+// DEPRECATED! use UMPIRE_FMT_COMPILE instead.
 template <typename... Args>
-FMT_DEPRECATED auto compile(const Args&... args)
+UMPIRE_FMT_DEPRECATED auto compile(const Args&... args)
     -> decltype(detail::compile(args...)) {
   return detail::compile(args...);
 }
 
-#if FMT_USE_CONSTEXPR
+#if UMPIRE_FMT_USE_CONSTEXPR
 #  ifdef __cpp_if_constexpr
 
 template <typename CompiledFormat, typename... Args,
           typename Char = typename CompiledFormat::char_type,
-          FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
-FMT_INLINE std::basic_string<Char> format(const CompiledFormat& cf,
+          UMPIRE_FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
+UMPIRE_FMT_INLINE std::basic_string<Char> format(const CompiledFormat& cf,
                                           const Args&... args) {
   basic_memory_buffer<Char> buffer;
   cf.format(detail::buffer_appender<Char>(buffer), args...);
@@ -834,17 +834,17 @@ FMT_INLINE std::basic_string<Char> format(const CompiledFormat& cf,
 }
 
 template <typename OutputIt, typename CompiledFormat, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
+          UMPIRE_FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
 constexpr OutputIt format_to(OutputIt out, const CompiledFormat& cf,
                              const Args&... args) {
   return cf.format(out, args...);
 }
 #  endif  // __cpp_if_constexpr
-#endif    // FMT_USE_CONSTEXPR
+#endif    // UMPIRE_FMT_USE_CONSTEXPR
 
 template <typename CompiledFormat, typename... Args,
           typename Char = typename CompiledFormat::char_type,
-          FMT_ENABLE_IF(std::is_base_of<detail::basic_compiled_format,
+          UMPIRE_FMT_ENABLE_IF(std::is_base_of<detail::basic_compiled_format,
                                         CompiledFormat>::value)>
 std::basic_string<Char> format(const CompiledFormat& cf, const Args&... args) {
   basic_memory_buffer<Char> buffer;
@@ -855,8 +855,8 @@ std::basic_string<Char> format(const CompiledFormat& cf, const Args&... args) {
 }
 
 template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-FMT_INLINE std::basic_string<typename S::char_type> format(const S&,
+          UMPIRE_FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
+UMPIRE_FMT_INLINE std::basic_string<typename S::char_type> format(const S&,
                                                            Args&&... args) {
 #ifdef __cpp_if_constexpr
   if constexpr (std::is_same<typename S::char_type, char>::value) {
@@ -887,7 +887,7 @@ FMT_INLINE std::basic_string<typename S::char_type> format(const S&,
 }
 
 template <typename OutputIt, typename CompiledFormat, typename... Args,
-          FMT_ENABLE_IF(std::is_base_of<detail::basic_compiled_format,
+          UMPIRE_FMT_ENABLE_IF(std::is_base_of<detail::basic_compiled_format,
                                         CompiledFormat>::value)>
 constexpr OutputIt format_to(OutputIt out, const CompiledFormat& cf,
                              const Args&... args) {
@@ -898,8 +898,8 @@ constexpr OutputIt format_to(OutputIt out, const CompiledFormat& cf,
 }
 
 template <typename OutputIt, typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-FMT_CONSTEXPR OutputIt format_to(OutputIt out, const S&, Args&&... args) {
+          UMPIRE_FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
+UMPIRE_FMT_CONSTEXPR OutputIt format_to(OutputIt out, const S&, Args&&... args) {
   constexpr auto compiled = detail::compile<Args...>(S());
 #ifdef __cpp_if_constexpr
   if constexpr (std::is_same<remove_cvref_t<decltype(compiled)>,
@@ -930,7 +930,7 @@ auto format_to_n(OutputIt out, size_t n, const CompiledFormat& cf,
 }
 
 template <typename OutputIt, typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
+          UMPIRE_FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
 format_to_n_result<OutputIt> format_to_n(OutputIt out, size_t n, const S&,
                                          Args&&... args) {
   auto it = format_to(detail::truncating_iterator<OutputIt>(out, n), S(),
@@ -939,14 +939,14 @@ format_to_n_result<OutputIt> format_to_n(OutputIt out, size_t n, const S&,
 }
 
 template <typename CompiledFormat, typename... Args,
-          FMT_ENABLE_IF(std::is_base_of<detail::basic_compiled_format,
+          UMPIRE_FMT_ENABLE_IF(std::is_base_of<detail::basic_compiled_format,
                                         CompiledFormat>::value ||
                         detail::is_compiled_string<CompiledFormat>::value)>
 size_t formatted_size(const CompiledFormat& cf, const Args&... args) {
   return format_to(detail::counting_iterator(), cf, args...).count();
 }
 
-#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
+#if UMPIRE_FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
 inline namespace literals {
 template <detail::fixed_string Str>
 constexpr detail::udl_compiled_string<remove_cvref_t<decltype(Str.data[0])>,
@@ -957,6 +957,6 @@ operator""_cf() {
 }  // namespace literals
 #endif
 
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_COMPILE_H_
+#endif  // UMPIRE_FMT_COMPILE_H_
diff --git a/src/tpl/umpire/fmt/core.h b/src/tpl/umpire/fmt/core.h
index 14530ede0..cbf228bfc 100644
--- a/src/tpl/umpire/fmt/core.h
+++ b/src/tpl/umpire/fmt/core.h
@@ -5,8 +5,8 @@
 //
 // For the license information refer to format.h.
 
-#ifndef FMT_CORE_H_
-#define FMT_CORE_H_
+#ifndef UMPIRE_FMT_CORE_H_
+#define UMPIRE_FMT_CORE_H_
 
 #include <cstdio>  // std::FILE
 #include <cstring>
@@ -15,245 +15,245 @@
 #include <type_traits>
 
 // The fmt library version in the form major * 10000 + minor * 100 + patch.
-#define FMT_VERSION 70103
+#define UMPIRE_FMT_VERSION 70103
 
 #ifdef __clang__
-#  define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
+#  define UMPIRE_FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
 #else
-#  define FMT_CLANG_VERSION 0
+#  define UMPIRE_FMT_CLANG_VERSION 0
 #endif
 
 #if defined(__GNUC__) && !defined(__clang__)
-#  define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+#  define UMPIRE_FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
 #else
-#  define FMT_GCC_VERSION 0
+#  define UMPIRE_FMT_GCC_VERSION 0
 #endif
 
 #if defined(__INTEL_COMPILER)
-#  define FMT_ICC_VERSION __INTEL_COMPILER
+#  define UMPIRE_FMT_ICC_VERSION __INTEL_COMPILER
 #else
-#  define FMT_ICC_VERSION 0
+#  define UMPIRE_FMT_ICC_VERSION 0
 #endif
 
 #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
-#  define FMT_HAS_GXX_CXX11 FMT_GCC_VERSION
+#  define UMPIRE_FMT_HAS_GXX_CXX11 UMPIRE_FMT_GCC_VERSION
 #else
-#  define FMT_HAS_GXX_CXX11 0
+#  define UMPIRE_FMT_HAS_GXX_CXX11 0
 #endif
 
 #ifdef __NVCC__
-#  define FMT_NVCC __NVCC__
+#  define UMPIRE_FMT_NVCC __NVCC__
 #else
-#  define FMT_NVCC 0
+#  define UMPIRE_FMT_NVCC 0
 #endif
 
 #ifdef _MSC_VER
-#  define FMT_MSC_VER _MSC_VER
-#  define FMT_MSC_WARNING(...) __pragma(warning(__VA_ARGS__))
+#  define UMPIRE_FMT_MSC_VER _MSC_VER
+#  define UMPIRE_FMT_MSC_WARNING(...) __pragma(warning(__VA_ARGS__))
 #else
-#  define FMT_MSC_VER 0
-#  define FMT_MSC_WARNING(...)
+#  define UMPIRE_FMT_MSC_VER 0
+#  define UMPIRE_FMT_MSC_WARNING(...)
 #endif
 
 #ifdef __has_feature
-#  define FMT_HAS_FEATURE(x) __has_feature(x)
+#  define UMPIRE_FMT_HAS_FEATURE(x) __has_feature(x)
 #else
-#  define FMT_HAS_FEATURE(x) 0
+#  define UMPIRE_FMT_HAS_FEATURE(x) 0
 #endif
 
 #if defined(__has_include) && !defined(__INTELLISENSE__) && \
-    (!FMT_ICC_VERSION || FMT_ICC_VERSION >= 1600)
-#  define FMT_HAS_INCLUDE(x) __has_include(x)
+    (!UMPIRE_FMT_ICC_VERSION || UMPIRE_FMT_ICC_VERSION >= 1600)
+#  define UMPIRE_FMT_HAS_INCLUDE(x) __has_include(x)
 #else
-#  define FMT_HAS_INCLUDE(x) 0
+#  define UMPIRE_FMT_HAS_INCLUDE(x) 0
 #endif
 
 #ifdef __has_cpp_attribute
-#  define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
+#  define UMPIRE_FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
 #else
-#  define FMT_HAS_CPP_ATTRIBUTE(x) 0
+#  define UMPIRE_FMT_HAS_CPP_ATTRIBUTE(x) 0
 #endif
 
-#define FMT_HAS_CPP14_ATTRIBUTE(attribute) \
-  (__cplusplus >= 201402L && FMT_HAS_CPP_ATTRIBUTE(attribute))
+#define UMPIRE_FMT_HAS_CPP14_ATTRIBUTE(attribute) \
+  (__cplusplus >= 201402L && UMPIRE_FMT_HAS_CPP_ATTRIBUTE(attribute))
 
-#define FMT_HAS_CPP17_ATTRIBUTE(attribute) \
-  (__cplusplus >= 201703L && FMT_HAS_CPP_ATTRIBUTE(attribute))
+#define UMPIRE_FMT_HAS_CPP17_ATTRIBUTE(attribute) \
+  (__cplusplus >= 201703L && UMPIRE_FMT_HAS_CPP_ATTRIBUTE(attribute))
 
 // Check if relaxed C++14 constexpr is supported.
 // GCC doesn't allow throw in constexpr until version 6 (bug 67371).
-#ifndef FMT_USE_CONSTEXPR
-#  define FMT_USE_CONSTEXPR                                           \
-    (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VER >= 1910 || \
-     (FMT_GCC_VERSION >= 600 && __cplusplus >= 201402L)) &&           \
-        !FMT_NVCC && !FMT_ICC_VERSION
+#ifndef UMPIRE_FMT_USE_CONSTEXPR
+#  define UMPIRE_FMT_USE_CONSTEXPR                                           \
+    (UMPIRE_FMT_HAS_FEATURE(cxx_relaxed_constexpr) || UMPIRE_FMT_MSC_VER >= 1910 || \
+     (UMPIRE_FMT_GCC_VERSION >= 600 && __cplusplus >= 201402L)) &&           \
+        !UMPIRE_FMT_NVCC && !UMPIRE_FMT_ICC_VERSION
 #endif
-#if FMT_USE_CONSTEXPR
-#  define FMT_CONSTEXPR constexpr
-#  define FMT_CONSTEXPR_DECL constexpr
+#if UMPIRE_FMT_USE_CONSTEXPR
+#  define UMPIRE_FMT_CONSTEXPR constexpr
+#  define UMPIRE_FMT_CONSTEXPR_DECL constexpr
 #else
-#  define FMT_CONSTEXPR
-#  define FMT_CONSTEXPR_DECL
+#  define UMPIRE_FMT_CONSTEXPR
+#  define UMPIRE_FMT_CONSTEXPR_DECL
 #endif
 
-#ifndef FMT_OVERRIDE
-#  if FMT_HAS_FEATURE(cxx_override_control) || \
-      (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1900
-#    define FMT_OVERRIDE override
+#ifndef UMPIRE_FMT_OVERRIDE
+#  if UMPIRE_FMT_HAS_FEATURE(cxx_override_control) || \
+      (UMPIRE_FMT_GCC_VERSION >= 408 && UMPIRE_FMT_HAS_GXX_CXX11) || UMPIRE_FMT_MSC_VER >= 1900
+#    define UMPIRE_FMT_OVERRIDE override
 #  else
-#    define FMT_OVERRIDE
+#    define UMPIRE_FMT_OVERRIDE
 #  endif
 #endif
 
 // Check if exceptions are disabled.
-#ifndef FMT_EXCEPTIONS
+#ifndef UMPIRE_FMT_EXCEPTIONS
 #  if (defined(__GNUC__) && !defined(__EXCEPTIONS)) || \
-      FMT_MSC_VER && !_HAS_EXCEPTIONS
-#    define FMT_EXCEPTIONS 0
+      UMPIRE_FMT_MSC_VER && !_HAS_EXCEPTIONS
+#    define UMPIRE_FMT_EXCEPTIONS 0
 #  else
-#    define FMT_EXCEPTIONS 1
+#    define UMPIRE_FMT_EXCEPTIONS 1
 #  endif
 #endif
 
-// Define FMT_USE_NOEXCEPT to make fmt use noexcept (C++11 feature).
-#ifndef FMT_USE_NOEXCEPT
-#  define FMT_USE_NOEXCEPT 0
+// Define UMPIRE_FMT_USE_NOEXCEPT to make fmt use noexcept (C++11 feature).
+#ifndef UMPIRE_FMT_USE_NOEXCEPT
+#  define UMPIRE_FMT_USE_NOEXCEPT 0
 #endif
 
-#if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \
-    (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1900
-#  define FMT_DETECTED_NOEXCEPT noexcept
-#  define FMT_HAS_CXX11_NOEXCEPT 1
+#if UMPIRE_FMT_USE_NOEXCEPT || UMPIRE_FMT_HAS_FEATURE(cxx_noexcept) || \
+    (UMPIRE_FMT_GCC_VERSION >= 408 && UMPIRE_FMT_HAS_GXX_CXX11) || UMPIRE_FMT_MSC_VER >= 1900
+#  define UMPIRE_FMT_DETECTED_NOEXCEPT noexcept
+#  define UMPIRE_FMT_HAS_CXX11_NOEXCEPT 1
 #else
-#  define FMT_DETECTED_NOEXCEPT throw()
-#  define FMT_HAS_CXX11_NOEXCEPT 0
+#  define UMPIRE_FMT_DETECTED_NOEXCEPT throw()
+#  define UMPIRE_FMT_HAS_CXX11_NOEXCEPT 0
 #endif
 
-#ifndef FMT_NOEXCEPT
-#  if FMT_EXCEPTIONS || FMT_HAS_CXX11_NOEXCEPT
-#    define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT
+#ifndef UMPIRE_FMT_NOEXCEPT
+#  if UMPIRE_FMT_EXCEPTIONS || UMPIRE_FMT_HAS_CXX11_NOEXCEPT
+#    define UMPIRE_FMT_NOEXCEPT UMPIRE_FMT_DETECTED_NOEXCEPT
 #  else
-#    define FMT_NOEXCEPT
+#    define UMPIRE_FMT_NOEXCEPT
 #  endif
 #endif
 
 // [[noreturn]] is disabled on MSVC and NVCC because of bogus unreachable code
 // warnings.
-#if FMT_EXCEPTIONS && FMT_HAS_CPP_ATTRIBUTE(noreturn) && !FMT_MSC_VER && \
-    !FMT_NVCC
-#  define FMT_NORETURN [[noreturn]]
+#if UMPIRE_FMT_EXCEPTIONS && UMPIRE_FMT_HAS_CPP_ATTRIBUTE(noreturn) && !UMPIRE_FMT_MSC_VER && \
+    !UMPIRE_FMT_NVCC
+#  define UMPIRE_FMT_NORETURN [[noreturn]]
 #else
-#  define FMT_NORETURN
+#  define UMPIRE_FMT_NORETURN
 #endif
 
-#ifndef FMT_DEPRECATED
-#  if FMT_HAS_CPP14_ATTRIBUTE(deprecated) || FMT_MSC_VER >= 1900
-#    define FMT_DEPRECATED [[deprecated]]
+#ifndef UMPIRE_FMT_DEPRECATED
+#  if UMPIRE_FMT_HAS_CPP14_ATTRIBUTE(deprecated) || UMPIRE_FMT_MSC_VER >= 1900
+#    define UMPIRE_FMT_DEPRECATED [[deprecated]]
 #  else
 #    if (defined(__GNUC__) && !defined(__LCC__)) || defined(__clang__)
-#      define FMT_DEPRECATED __attribute__((deprecated))
-#    elif FMT_MSC_VER
-#      define FMT_DEPRECATED __declspec(deprecated)
+#      define UMPIRE_FMT_DEPRECATED __attribute__((deprecated))
+#    elif UMPIRE_FMT_MSC_VER
+#      define UMPIRE_FMT_DEPRECATED __declspec(deprecated)
 #    else
-#      define FMT_DEPRECATED /* deprecated */
+#      define UMPIRE_FMT_DEPRECATED /* deprecated */
 #    endif
 #  endif
 #endif
 
 // Workaround broken [[deprecated]] in the Intel, PGI and NVCC compilers.
-#if FMT_ICC_VERSION || defined(__PGI) || FMT_NVCC
-#  define FMT_DEPRECATED_ALIAS
+#if UMPIRE_FMT_ICC_VERSION || defined(__PGI) || UMPIRE_FMT_NVCC
+#  define UMPIRE_FMT_DEPRECATED_ALIAS
 #else
-#  define FMT_DEPRECATED_ALIAS FMT_DEPRECATED
+#  define UMPIRE_FMT_DEPRECATED_ALIAS UMPIRE_FMT_DEPRECATED
 #endif
 
-#ifndef FMT_INLINE
-#  if FMT_GCC_VERSION || FMT_CLANG_VERSION
-#    define FMT_INLINE inline __attribute__((always_inline))
+#ifndef UMPIRE_FMT_INLINE
+#  if UMPIRE_FMT_GCC_VERSION || UMPIRE_FMT_CLANG_VERSION
+#    define UMPIRE_FMT_INLINE inline __attribute__((always_inline))
 #  else
-#    define FMT_INLINE inline
+#    define UMPIRE_FMT_INLINE inline
 #  endif
 #endif
 
-#ifndef FMT_USE_INLINE_NAMESPACES
-#  if FMT_HAS_FEATURE(cxx_inline_namespaces) || FMT_GCC_VERSION >= 404 || \
-      (FMT_MSC_VER >= 1900 && (!defined(_MANAGED) || !_MANAGED))
-#    define FMT_USE_INLINE_NAMESPACES 1
+#ifndef UMPIRE_FMT_USE_INLINE_NAMESPACES
+#  if UMPIRE_FMT_HAS_FEATURE(cxx_inline_namespaces) || UMPIRE_FMT_GCC_VERSION >= 404 || \
+      (UMPIRE_FMT_MSC_VER >= 1900 && (!defined(_MANAGED) || !_MANAGED))
+#    define UMPIRE_FMT_USE_INLINE_NAMESPACES 1
 #  else
-#    define FMT_USE_INLINE_NAMESPACES 0
+#    define UMPIRE_FMT_USE_INLINE_NAMESPACES 0
 #  endif
 #endif
 
-#ifndef FMT_BEGIN_NAMESPACE
-#  if FMT_USE_INLINE_NAMESPACES
-#    define FMT_INLINE_NAMESPACE inline namespace
-#    define FMT_END_NAMESPACE \
+#ifndef UMPIRE_FMT_BEGIN_NAMESPACE
+#  if UMPIRE_FMT_USE_INLINE_NAMESPACES
+#    define UMPIRE_FMT_INLINE_NAMESPACE inline namespace
+#    define UMPIRE_FMT_END_NAMESPACE \
       }                       \
       }                       \
       }
 #  else
-#    define FMT_INLINE_NAMESPACE namespace
-#    define FMT_END_NAMESPACE \
+#    define UMPIRE_FMT_INLINE_NAMESPACE namespace
+#    define UMPIRE_FMT_END_NAMESPACE \
       }                       \
       using namespace v7;     \
       }                       \
       }
 #  endif
-#  define FMT_BEGIN_NAMESPACE \
+#  define UMPIRE_FMT_BEGIN_NAMESPACE \
     namespace umpire {          \
     namespace fmt {           \
-    FMT_INLINE_NAMESPACE v7 {
+    UMPIRE_FMT_INLINE_NAMESPACE v7 {
 #endif
 
-#if !defined(FMT_HEADER_ONLY) && defined(_WIN32)
-#  define FMT_CLASS_API FMT_MSC_WARNING(suppress : 4275)
-#  ifdef FMT_EXPORT
-#    define FMT_API __declspec(dllexport)
-#    define FMT_EXTERN_TEMPLATE_API FMT_API
-#    define FMT_EXPORTED
-#  elif defined(FMT_SHARED)
-#    define FMT_API __declspec(dllimport)
-#    define FMT_EXTERN_TEMPLATE_API FMT_API
+#if !defined(UMPIRE_FMT_HEADER_ONLY) && defined(_WIN32)
+#  define UMPIRE_FMT_CLASS_API UMPIRE_FMT_MSC_WARNING(suppress : 4275)
+#  ifdef UMPIRE_FMT_EXPORT
+#    define UMPIRE_FMT_API __declspec(dllexport)
+#    define UMPIRE_FMT_EXTERN_TEMPLATE_API UMPIRE_FMT_API
+#    define UMPIRE_FMT_EXPORTED
+#  elif defined(UMPIRE_FMT_SHARED)
+#    define UMPIRE_FMT_API __declspec(dllimport)
+#    define UMPIRE_FMT_EXTERN_TEMPLATE_API UMPIRE_FMT_API
 #  endif
 #else
-#  define FMT_CLASS_API
+#  define UMPIRE_FMT_CLASS_API
 #endif
-#ifndef FMT_API
-#  define FMT_API
+#ifndef UMPIRE_FMT_API
+#  define UMPIRE_FMT_API
 #endif
-#ifndef FMT_EXTERN_TEMPLATE_API
-#  define FMT_EXTERN_TEMPLATE_API
+#ifndef UMPIRE_FMT_EXTERN_TEMPLATE_API
+#  define UMPIRE_FMT_EXTERN_TEMPLATE_API
 #endif
-#ifndef FMT_INSTANTIATION_DEF_API
-#  define FMT_INSTANTIATION_DEF_API FMT_API
+#ifndef UMPIRE_FMT_INSTANTIATION_DEF_API
+#  define UMPIRE_FMT_INSTANTIATION_DEF_API UMPIRE_FMT_API
 #endif
 
-#ifndef FMT_HEADER_ONLY
-#  define FMT_EXTERN extern
+#ifndef UMPIRE_FMT_HEADER_ONLY
+#  define UMPIRE_FMT_EXTERN extern
 #else
-#  define FMT_EXTERN
+#  define UMPIRE_FMT_EXTERN
 #endif
 
 // libc++ supports string_view in pre-c++17.
-#if (FMT_HAS_INCLUDE(<string_view>) &&                       \
+#if (UMPIRE_FMT_HAS_INCLUDE(<string_view>) &&                       \
      (__cplusplus > 201402L || defined(_LIBCPP_VERSION))) || \
     (defined(_MSVC_LANG) && _MSVC_LANG > 201402L && _MSC_VER >= 1910)
 #  include <string_view>
-#  define FMT_USE_STRING_VIEW
-#elif FMT_HAS_INCLUDE("experimental/string_view") && __cplusplus >= 201402L
+#  define UMPIRE_FMT_USE_STRING_VIEW
+#elif UMPIRE_FMT_HAS_INCLUDE("experimental/string_view") && __cplusplus >= 201402L
 #  include <experimental/string_view>
-#  define FMT_USE_EXPERIMENTAL_STRING_VIEW
+#  define UMPIRE_FMT_USE_EXPERIMENTAL_STRING_VIEW
 #endif
 
-#ifndef FMT_UNICODE
-#  define FMT_UNICODE !FMT_MSC_VER
+#ifndef UMPIRE_FMT_UNICODE
+#  define UMPIRE_FMT_UNICODE !UMPIRE_FMT_MSC_VER
 #endif
 
-#ifndef FMT_COMPILE_TIME_CHECKS
-#  define FMT_COMPILE_TIME_CHECKS 0
+#ifndef UMPIRE_FMT_COMPILE_TIME_CHECKS
+#  define UMPIRE_FMT_COMPILE_TIME_CHECKS 0
 #endif
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 
 // Implementations of enable_if_t and other metafunctions for older systems.
 template <bool B, class T = void>
@@ -275,15 +275,15 @@ struct monostate {};
 // An enable_if helper to be used in template parameters which results in much
 // shorter symbols: https://godbolt.org/z/sWw4vP. Extra parentheses are needed
 // to workaround a bug in MSVC 2019 (see #1140 and #1186).
-#ifdef FMT_DOC
-#  define FMT_ENABLE_IF(...)
+#ifdef UMPIRE_FMT_DOC
+#  define UMPIRE_FMT_ENABLE_IF(...)
 #else
-#  define FMT_ENABLE_IF(...) enable_if_t<(__VA_ARGS__), int> = 0
+#  define UMPIRE_FMT_ENABLE_IF(...) enable_if_t<(__VA_ARGS__), int> = 0
 #endif
 
 namespace detail {
 
-constexpr bool is_constant_evaluated() FMT_NOEXCEPT {
+constexpr bool is_constant_evaluated() UMPIRE_FMT_NOEXCEPT {
 #ifdef __cpp_lib_is_constant_evaluated
   return std::is_constant_evaluated();
 #else
@@ -294,56 +294,56 @@ constexpr bool is_constant_evaluated() FMT_NOEXCEPT {
 // A helper function to suppress "conditional expression is constant" warnings.
 template <typename T> constexpr T const_check(T value) { return value; }
 
-FMT_NORETURN FMT_API void assert_fail(const char* file, int line,
+UMPIRE_FMT_NORETURN UMPIRE_FMT_API void assert_fail(const char* file, int line,
                                       const char* message);
 
-#ifndef FMT_ASSERT
+#ifndef UMPIRE_FMT_ASSERT
 #  ifdef NDEBUG
-// FMT_ASSERT is not empty to avoid -Werror=empty-body.
-#    define FMT_ASSERT(condition, message) ((void)0)
+// UMPIRE_FMT_ASSERT is not empty to avoid -Werror=empty-body.
+#    define UMPIRE_FMT_ASSERT(condition, message) ((void)0)
 #  else
-#    define FMT_ASSERT(condition, message)                                    \
+#    define UMPIRE_FMT_ASSERT(condition, message)                                    \
       ((condition) /* void() fails with -Winvalid-constexpr on clang 4.0.1 */ \
            ? (void)0                                                          \
            : ::umpire::fmt::detail::assert_fail(__FILE__, __LINE__, (message)))
 #  endif
 #endif
 
-#if defined(FMT_USE_STRING_VIEW)
+#if defined(UMPIRE_FMT_USE_STRING_VIEW)
 template <typename Char> using std_string_view = std::basic_string_view<Char>;
-#elif defined(FMT_USE_EXPERIMENTAL_STRING_VIEW)
+#elif defined(UMPIRE_FMT_USE_EXPERIMENTAL_STRING_VIEW)
 template <typename Char>
 using std_string_view = std::experimental::basic_string_view<Char>;
 #else
 template <typename T> struct std_string_view {};
 #endif
 
-#ifdef FMT_USE_INT128
+#ifdef UMPIRE_FMT_USE_INT128
 // Do nothing.
-#elif defined(__SIZEOF_INT128__) && !FMT_NVCC && \
-    !(FMT_CLANG_VERSION && FMT_MSC_VER)
-#  define FMT_USE_INT128 1
+#elif defined(__SIZEOF_INT128__) && !UMPIRE_FMT_NVCC && \
+    !(UMPIRE_FMT_CLANG_VERSION && UMPIRE_FMT_MSC_VER)
+#  define UMPIRE_FMT_USE_INT128 1
 using int128_t = __int128_t;
 using uint128_t = __uint128_t;
 #else
-#  define FMT_USE_INT128 0
+#  define UMPIRE_FMT_USE_INT128 0
 #endif
-#if !FMT_USE_INT128
+#if !UMPIRE_FMT_USE_INT128
 struct int128_t {};
 struct uint128_t {};
 #endif
 
 // Casts a nonnegative integer to unsigned.
 template <typename Int>
-FMT_CONSTEXPR typename std::make_unsigned<Int>::type to_unsigned(Int value) {
-  FMT_ASSERT(value >= 0, "negative value");
+UMPIRE_FMT_CONSTEXPR typename std::make_unsigned<Int>::type to_unsigned(Int value) {
+  UMPIRE_FMT_ASSERT(value >= 0, "negative value");
   return static_cast<typename std::make_unsigned<Int>::type>(value);
 }
 
-FMT_MSC_WARNING(suppress : 4566) constexpr unsigned char micro[] = "\u00B5";
+UMPIRE_FMT_MSC_WARNING(suppress : 4566) constexpr unsigned char micro[] = "\u00B5";
 
 template <typename Char> constexpr bool is_unicode() {
-  return FMT_UNICODE || sizeof(Char) != 1 ||
+  return UMPIRE_FMT_UNICODE || sizeof(Char) != 1 ||
          (sizeof(micro) == 3 && micro[0] == 0xC2 && micro[1] == 0xB5);
 }
 
@@ -354,7 +354,7 @@ enum char8_type : unsigned char {};
 #endif
 }  // namespace detail
 
-#ifdef FMT_USE_INTERNAL
+#ifdef UMPIRE_FMT_USE_INTERNAL
 namespace internal = detail;  // DEPRECATED
 #endif
 
@@ -374,10 +374,10 @@ template <typename Char> class basic_string_view {
   using value_type = Char;
   using iterator = const Char*;
 
-  constexpr basic_string_view() FMT_NOEXCEPT : data_(nullptr), size_(0) {}
+  constexpr basic_string_view() UMPIRE_FMT_NOEXCEPT : data_(nullptr), size_(0) {}
 
   /** Constructs a string reference object from a C string and a size. */
-  constexpr basic_string_view(const Char* s, size_t count) FMT_NOEXCEPT
+  constexpr basic_string_view(const Char* s, size_t count) UMPIRE_FMT_NOEXCEPT
       : data_(s),
         size_(count) {}
 
@@ -388,21 +388,21 @@ template <typename Char> class basic_string_view {
     \endrst
    */
 #if __cplusplus >= 201703L  // C++17's char_traits::length() is constexpr.
-  FMT_CONSTEXPR
+  UMPIRE_FMT_CONSTEXPR
 #endif
   basic_string_view(const Char* s)
       : data_(s), size_(std::char_traits<Char>::length(s)) {}
 
   /** Constructs a string reference from a ``std::basic_string`` object. */
   template <typename Traits, typename Alloc>
-  FMT_CONSTEXPR basic_string_view(
-      const std::basic_string<Char, Traits, Alloc>& s) FMT_NOEXCEPT
+  UMPIRE_FMT_CONSTEXPR basic_string_view(
+      const std::basic_string<Char, Traits, Alloc>& s) UMPIRE_FMT_NOEXCEPT
       : data_(s.data()),
         size_(s.size()) {}
 
-  template <typename S, FMT_ENABLE_IF(std::is_same<
+  template <typename S, UMPIRE_FMT_ENABLE_IF(std::is_same<
                                       S, detail::std_string_view<Char>>::value)>
-  FMT_CONSTEXPR basic_string_view(S s) FMT_NOEXCEPT : data_(s.data()),
+  UMPIRE_FMT_CONSTEXPR basic_string_view(S s) UMPIRE_FMT_NOEXCEPT : data_(s.data()),
                                                       size_(s.size()) {}
 
   /** Returns a pointer to the string data. */
@@ -416,7 +416,7 @@ template <typename Char> class basic_string_view {
 
   constexpr const Char& operator[](size_t pos) const { return data_[pos]; }
 
-  FMT_CONSTEXPR void remove_prefix(size_t n) {
+  UMPIRE_FMT_CONSTEXPR void remove_prefix(size_t n) {
     data_ += n;
     size_ -= n;
   }
@@ -477,7 +477,7 @@ template <> struct is_char<char32_t> : std::true_type {};
     std::string message = umpire::fmt::format(my_string("The answer is {}"), 42);
   \endrst
  */
-template <typename Char, FMT_ENABLE_IF(is_char<Char>::value)>
+template <typename Char, UMPIRE_FMT_ENABLE_IF(is_char<Char>::value)>
 inline basic_string_view<Char> to_string_view(const Char* s) {
   return s;
 }
@@ -494,19 +494,19 @@ constexpr basic_string_view<Char> to_string_view(basic_string_view<Char> s) {
 }
 
 template <typename Char,
-          FMT_ENABLE_IF(!std::is_empty<detail::std_string_view<Char>>::value)>
+          UMPIRE_FMT_ENABLE_IF(!std::is_empty<detail::std_string_view<Char>>::value)>
 inline basic_string_view<Char> to_string_view(detail::std_string_view<Char> s) {
   return s;
 }
 
 // A base class for compile-time strings. It is defined in the fmt namespace to
-// make formatting functions visible via ADL, e.g. format(FMT_STRING("{}"), 42).
+// make formatting functions visible via ADL, e.g. format(UMPIRE_FMT_STRING("{}"), 42).
 struct compile_string {};
 
 template <typename S>
 struct is_compile_string : std::is_base_of<compile_string, S> {};
 
-template <typename S, FMT_ENABLE_IF(is_compile_string<S>::value)>
+template <typename S, UMPIRE_FMT_ENABLE_IF(is_compile_string<S>::value)>
 constexpr basic_string_view<typename S::char_type> to_string_view(const S& s) {
   return s;
 }
@@ -529,15 +529,15 @@ template <typename S> struct char_t_impl<S, enable_if_t<is_string<S>::value>> {
 };
 
 // Reports a compile-time error if S is not a valid format string.
-template <typename..., typename S, FMT_ENABLE_IF(!is_compile_string<S>::value)>
-FMT_INLINE void check_format_string(const S&) {
-#ifdef FMT_ENFORCE_COMPILE_STRING
+template <typename..., typename S, UMPIRE_FMT_ENABLE_IF(!is_compile_string<S>::value)>
+UMPIRE_FMT_INLINE void check_format_string(const S&) {
+#ifdef UMPIRE_FMT_ENFORCE_COMPILE_STRING
   static_assert(is_compile_string<S>::value,
-                "FMT_ENFORCE_COMPILE_STRING requires all format strings to use "
-                "FMT_STRING.");
+                "UMPIRE_FMT_ENFORCE_COMPILE_STRING requires all format strings to use "
+                "UMPIRE_FMT_STRING.");
 #endif
 }
-template <typename..., typename S, FMT_ENABLE_IF(is_compile_string<S>::value)>
+template <typename..., typename S, UMPIRE_FMT_ENABLE_IF(is_compile_string<S>::value)>
 void check_format_string(S);
 
 struct error_handler {
@@ -545,7 +545,7 @@ struct error_handler {
   constexpr error_handler(const error_handler&) = default;
 
   // This function is intentionally not constexpr to give a compile-time error.
-  FMT_NORETURN FMT_API void on_error(const char* message);
+  UMPIRE_FMT_NORETURN UMPIRE_FMT_API void on_error(const char* message);
 };
 }  // namespace detail
 
@@ -587,15 +587,15 @@ class basic_format_parse_context : private ErrorHandler {
     Returns an iterator to the beginning of the format string range being
     parsed.
    */
-  constexpr iterator begin() const FMT_NOEXCEPT { return format_str_.begin(); }
+  constexpr iterator begin() const UMPIRE_FMT_NOEXCEPT { return format_str_.begin(); }
 
   /**
     Returns an iterator past the end of the format string range being parsed.
    */
-  constexpr iterator end() const FMT_NOEXCEPT { return format_str_.end(); }
+  constexpr iterator end() const UMPIRE_FMT_NOEXCEPT { return format_str_.end(); }
 
   /** Advances the begin iterator to ``it``. */
-  FMT_CONSTEXPR void advance_to(iterator it) {
+  UMPIRE_FMT_CONSTEXPR void advance_to(iterator it) {
     format_str_.remove_prefix(detail::to_unsigned(it - begin()));
   }
 
@@ -603,7 +603,7 @@ class basic_format_parse_context : private ErrorHandler {
     Reports an error if using the manual argument indexing; otherwise returns
     the next argument index and switches to the automatic indexing.
    */
-  FMT_CONSTEXPR int next_arg_id() {
+  UMPIRE_FMT_CONSTEXPR int next_arg_id() {
     // Don't check if the argument id is valid to avoid overhead and because it
     // will be checked during formatting anyway.
     if (next_arg_id_ >= 0) return next_arg_id_++;
@@ -615,16 +615,16 @@ class basic_format_parse_context : private ErrorHandler {
     Reports an error if using the automatic argument indexing; otherwise
     switches to the manual indexing.
    */
-  FMT_CONSTEXPR void check_arg_id(int) {
+  UMPIRE_FMT_CONSTEXPR void check_arg_id(int) {
     if (next_arg_id_ > 0)
       on_error("cannot switch from automatic to manual argument indexing");
     else
       next_arg_id_ = -1;
   }
 
-  FMT_CONSTEXPR void check_arg_id(basic_string_view<Char>) {}
+  UMPIRE_FMT_CONSTEXPR void check_arg_id(basic_string_view<Char>) {}
 
-  FMT_CONSTEXPR void on_error(const char* message) {
+  UMPIRE_FMT_CONSTEXPR void on_error(const char* message) {
     ErrorHandler::on_error(message);
   }
 
@@ -683,10 +683,10 @@ template <typename T> class buffer {
 
  protected:
   // Don't initialize ptr_ since it is not accessed to save a few cycles.
-  FMT_MSC_WARNING(suppress : 26495)
-  buffer(size_t sz) FMT_NOEXCEPT : size_(sz), capacity_(sz) {}
+  UMPIRE_FMT_MSC_WARNING(suppress : 26495)
+  buffer(size_t sz) UMPIRE_FMT_NOEXCEPT : size_(sz), capacity_(sz) {}
 
-  buffer(T* p = nullptr, size_t sz = 0, size_t cap = 0) FMT_NOEXCEPT
+  buffer(T* p = nullptr, size_t sz = 0, size_t cap = 0) UMPIRE_FMT_NOEXCEPT
       : ptr_(p),
         size_(sz),
         capacity_(cap) {}
@@ -694,7 +694,7 @@ template <typename T> class buffer {
   ~buffer() = default;
 
   /** Sets the buffer data and capacity. */
-  void set(T* buf_data, size_t buf_capacity) FMT_NOEXCEPT {
+  void set(T* buf_data, size_t buf_capacity) UMPIRE_FMT_NOEXCEPT {
     ptr_ = buf_data;
     capacity_ = buf_capacity;
   }
@@ -709,23 +709,23 @@ template <typename T> class buffer {
   buffer(const buffer&) = delete;
   void operator=(const buffer&) = delete;
 
-  T* begin() FMT_NOEXCEPT { return ptr_; }
-  T* end() FMT_NOEXCEPT { return ptr_ + size_; }
+  T* begin() UMPIRE_FMT_NOEXCEPT { return ptr_; }
+  T* end() UMPIRE_FMT_NOEXCEPT { return ptr_ + size_; }
 
-  const T* begin() const FMT_NOEXCEPT { return ptr_; }
-  const T* end() const FMT_NOEXCEPT { return ptr_ + size_; }
+  const T* begin() const UMPIRE_FMT_NOEXCEPT { return ptr_; }
+  const T* end() const UMPIRE_FMT_NOEXCEPT { return ptr_ + size_; }
 
   /** Returns the size of this buffer. */
-  size_t size() const FMT_NOEXCEPT { return size_; }
+  size_t size() const UMPIRE_FMT_NOEXCEPT { return size_; }
 
   /** Returns the capacity of this buffer. */
-  size_t capacity() const FMT_NOEXCEPT { return capacity_; }
+  size_t capacity() const UMPIRE_FMT_NOEXCEPT { return capacity_; }
 
   /** Returns a pointer to the buffer data. */
-  T* data() FMT_NOEXCEPT { return ptr_; }
+  T* data() UMPIRE_FMT_NOEXCEPT { return ptr_; }
 
   /** Returns a pointer to the buffer data. */
-  const T* data() const FMT_NOEXCEPT { return ptr_; }
+  const T* data() const UMPIRE_FMT_NOEXCEPT { return ptr_; }
 
   /** Clears this buffer. */
   void clear() { size_ = 0; }
@@ -789,7 +789,7 @@ class iterator_buffer final : public Traits, public buffer<T> {
   T data_[buffer_size];
 
  protected:
-  void grow(size_t) final FMT_OVERRIDE {
+  void grow(size_t) final UMPIRE_FMT_OVERRIDE {
     if (this->size() == buffer_size) flush();
   }
   void flush();
@@ -808,7 +808,7 @@ class iterator_buffer final : public Traits, public buffer<T> {
 
 template <typename T> class iterator_buffer<T*, T> final : public buffer<T> {
  protected:
-  void grow(size_t) final FMT_OVERRIDE {}
+  void grow(size_t) final UMPIRE_FMT_OVERRIDE {}
 
  public:
   explicit iterator_buffer(T* out, size_t = 0) : buffer<T>(out, 0, ~size_t()) {}
@@ -826,7 +826,7 @@ class iterator_buffer<std::back_insert_iterator<Container>,
   Container& container_;
 
  protected:
-  void grow(size_t capacity) final FMT_OVERRIDE {
+  void grow(size_t capacity) final UMPIRE_FMT_OVERRIDE {
     container_.resize(capacity);
     this->set(&container_[0], capacity);
   }
@@ -849,7 +849,7 @@ template <typename T = char> class counting_buffer final : public buffer<T> {
   size_t count_ = 0;
 
  protected:
-  void grow(size_t) final FMT_OVERRIDE {
+  void grow(size_t) final UMPIRE_FMT_OVERRIDE {
     if (this->size() != buffer_size) return;
     count_ += this->size();
     this->clear();
@@ -946,9 +946,9 @@ struct arg_data<T, Char, NUM_ARGS, 0> {
   T args_[NUM_ARGS != 0 ? NUM_ARGS : +1];
 
   template <typename... U>
-  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
-  FMT_CONSTEXPR FMT_INLINE const T* args() const { return args_; }
-  FMT_CONSTEXPR FMT_INLINE std::nullptr_t named_args() { return nullptr; }
+  UMPIRE_FMT_CONSTEXPR UMPIRE_FMT_INLINE arg_data(const U&... init) : args_{init...} {}
+  UMPIRE_FMT_CONSTEXPR UMPIRE_FMT_INLINE const T* args() const { return args_; }
+  UMPIRE_FMT_CONSTEXPR UMPIRE_FMT_INLINE std::nullptr_t named_args() { return nullptr; }
 };
 
 template <typename Char>
@@ -969,7 +969,7 @@ void init_named_args(named_arg_info<Char>* named_args, int arg_count,
 }
 
 template <typename... Args>
-FMT_CONSTEXPR FMT_INLINE void init_named_args(std::nullptr_t, int, int,
+UMPIRE_FMT_CONSTEXPR UMPIRE_FMT_INLINE void init_named_args(std::nullptr_t, int, int,
                                               const Args&...) {}
 
 template <typename T> struct is_named_arg : std::false_type {};
@@ -1013,25 +1013,25 @@ enum class type {
 template <typename T, typename Char>
 struct type_constant : std::integral_constant<type, type::custom_type> {};
 
-#define FMT_TYPE_CONSTANT(Type, constant) \
+#define UMPIRE_FMT_TYPE_CONSTANT(Type, constant) \
   template <typename Char>                \
   struct type_constant<Type, Char>        \
       : std::integral_constant<type, type::constant> {}
 
-FMT_TYPE_CONSTANT(int, int_type);
-FMT_TYPE_CONSTANT(unsigned, uint_type);
-FMT_TYPE_CONSTANT(long long, long_long_type);
-FMT_TYPE_CONSTANT(unsigned long long, ulong_long_type);
-FMT_TYPE_CONSTANT(int128_t, int128_type);
-FMT_TYPE_CONSTANT(uint128_t, uint128_type);
-FMT_TYPE_CONSTANT(bool, bool_type);
-FMT_TYPE_CONSTANT(Char, char_type);
-FMT_TYPE_CONSTANT(float, float_type);
-FMT_TYPE_CONSTANT(double, double_type);
-FMT_TYPE_CONSTANT(long double, long_double_type);
-FMT_TYPE_CONSTANT(const Char*, cstring_type);
-FMT_TYPE_CONSTANT(basic_string_view<Char>, string_type);
-FMT_TYPE_CONSTANT(const void*, pointer_type);
+UMPIRE_FMT_TYPE_CONSTANT(int, int_type);
+UMPIRE_FMT_TYPE_CONSTANT(unsigned, uint_type);
+UMPIRE_FMT_TYPE_CONSTANT(long long, long_long_type);
+UMPIRE_FMT_TYPE_CONSTANT(unsigned long long, ulong_long_type);
+UMPIRE_FMT_TYPE_CONSTANT(int128_t, int128_type);
+UMPIRE_FMT_TYPE_CONSTANT(uint128_t, uint128_type);
+UMPIRE_FMT_TYPE_CONSTANT(bool, bool_type);
+UMPIRE_FMT_TYPE_CONSTANT(Char, char_type);
+UMPIRE_FMT_TYPE_CONSTANT(float, float_type);
+UMPIRE_FMT_TYPE_CONSTANT(double, double_type);
+UMPIRE_FMT_TYPE_CONSTANT(long double, long_double_type);
+UMPIRE_FMT_TYPE_CONSTANT(const Char*, cstring_type);
+UMPIRE_FMT_TYPE_CONSTANT(basic_string_view<Char>, string_type);
+UMPIRE_FMT_TYPE_CONSTANT(const void*, pointer_type);
 
 constexpr bool is_integral_type(type t) {
   return t > type::none_type && t <= type::last_integer_type;
@@ -1080,30 +1080,30 @@ template <typename Context> class value {
     named_arg_value<char_type> named_args;
   };
 
-  constexpr FMT_INLINE value(int val = 0) : int_value(val) {}
-  constexpr FMT_INLINE value(unsigned val) : uint_value(val) {}
-  constexpr FMT_INLINE value(long long val) : long_long_value(val) {}
-  constexpr FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
-  FMT_INLINE value(int128_t val) : int128_value(val) {}
-  FMT_INLINE value(uint128_t val) : uint128_value(val) {}
-  FMT_INLINE value(float val) : float_value(val) {}
-  FMT_INLINE value(double val) : double_value(val) {}
-  FMT_INLINE value(long double val) : long_double_value(val) {}
-  constexpr FMT_INLINE value(bool val) : bool_value(val) {}
-  constexpr FMT_INLINE value(char_type val) : char_value(val) {}
-  FMT_CONSTEXPR FMT_INLINE value(const char_type* val) {
+  constexpr UMPIRE_FMT_INLINE value(int val = 0) : int_value(val) {}
+  constexpr UMPIRE_FMT_INLINE value(unsigned val) : uint_value(val) {}
+  constexpr UMPIRE_FMT_INLINE value(long long val) : long_long_value(val) {}
+  constexpr UMPIRE_FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
+  UMPIRE_FMT_INLINE value(int128_t val) : int128_value(val) {}
+  UMPIRE_FMT_INLINE value(uint128_t val) : uint128_value(val) {}
+  UMPIRE_FMT_INLINE value(float val) : float_value(val) {}
+  UMPIRE_FMT_INLINE value(double val) : double_value(val) {}
+  UMPIRE_FMT_INLINE value(long double val) : long_double_value(val) {}
+  constexpr UMPIRE_FMT_INLINE value(bool val) : bool_value(val) {}
+  constexpr UMPIRE_FMT_INLINE value(char_type val) : char_value(val) {}
+  UMPIRE_FMT_CONSTEXPR UMPIRE_FMT_INLINE value(const char_type* val) {
     string.data = val;
     if (is_constant_evaluated()) string.size = {};
   }
-  FMT_CONSTEXPR FMT_INLINE value(basic_string_view<char_type> val) {
+  UMPIRE_FMT_CONSTEXPR UMPIRE_FMT_INLINE value(basic_string_view<char_type> val) {
     string.data = val.data();
     string.size = val.size();
   }
-  FMT_INLINE value(const void* val) : pointer(val) {}
-  FMT_INLINE value(const named_arg_info<char_type>* args, size_t size)
+  UMPIRE_FMT_INLINE value(const void* val) : pointer(val) {}
+  UMPIRE_FMT_INLINE value(const named_arg_info<char_type>* args, size_t size)
       : named_args{args, size} {}
 
-  template <typename T> FMT_INLINE value(const T& val) {
+  template <typename T> UMPIRE_FMT_INLINE value(const T& val) {
     custom.value = &val;
     // Get the formatter type through the context to allow different contexts
     // have different extension points, e.g. `formatter<T>` for `format` and
@@ -1127,7 +1127,7 @@ template <typename Context> class value {
 };
 
 template <typename Context, typename T>
-FMT_CONSTEXPR basic_format_arg<Context> make_arg(const T& value);
+UMPIRE_FMT_CONSTEXPR basic_format_arg<Context> make_arg(const T& value);
 
 // To minimize the number of types we need to deal with, long is translated
 // either to int or to long long depending on its size.
@@ -1141,83 +1141,83 @@ struct unformattable {};
 template <typename Context> struct arg_mapper {
   using char_type = typename Context::char_type;
 
-  FMT_CONSTEXPR int map(signed char val) { return val; }
-  FMT_CONSTEXPR unsigned map(unsigned char val) { return val; }
-  FMT_CONSTEXPR int map(short val) { return val; }
-  FMT_CONSTEXPR unsigned map(unsigned short val) { return val; }
-  FMT_CONSTEXPR int map(int val) { return val; }
-  FMT_CONSTEXPR unsigned map(unsigned val) { return val; }
-  FMT_CONSTEXPR long_type map(long val) { return val; }
-  FMT_CONSTEXPR ulong_type map(unsigned long val) { return val; }
-  FMT_CONSTEXPR long long map(long long val) { return val; }
-  FMT_CONSTEXPR unsigned long long map(unsigned long long val) { return val; }
-  FMT_CONSTEXPR int128_t map(int128_t val) { return val; }
-  FMT_CONSTEXPR uint128_t map(uint128_t val) { return val; }
-  FMT_CONSTEXPR bool map(bool val) { return val; }
-
-  template <typename T, FMT_ENABLE_IF(is_char<T>::value)>
-  FMT_CONSTEXPR char_type map(T val) {
+  UMPIRE_FMT_CONSTEXPR int map(signed char val) { return val; }
+  UMPIRE_FMT_CONSTEXPR unsigned map(unsigned char val) { return val; }
+  UMPIRE_FMT_CONSTEXPR int map(short val) { return val; }
+  UMPIRE_FMT_CONSTEXPR unsigned map(unsigned short val) { return val; }
+  UMPIRE_FMT_CONSTEXPR int map(int val) { return val; }
+  UMPIRE_FMT_CONSTEXPR unsigned map(unsigned val) { return val; }
+  UMPIRE_FMT_CONSTEXPR long_type map(long val) { return val; }
+  UMPIRE_FMT_CONSTEXPR ulong_type map(unsigned long val) { return val; }
+  UMPIRE_FMT_CONSTEXPR long long map(long long val) { return val; }
+  UMPIRE_FMT_CONSTEXPR unsigned long long map(unsigned long long val) { return val; }
+  UMPIRE_FMT_CONSTEXPR int128_t map(int128_t val) { return val; }
+  UMPIRE_FMT_CONSTEXPR uint128_t map(uint128_t val) { return val; }
+  UMPIRE_FMT_CONSTEXPR bool map(bool val) { return val; }
+
+  template <typename T, UMPIRE_FMT_ENABLE_IF(is_char<T>::value)>
+  UMPIRE_FMT_CONSTEXPR char_type map(T val) {
     static_assert(
         std::is_same<T, char>::value || std::is_same<T, char_type>::value,
         "mixing character types is disallowed");
     return val;
   }
 
-  FMT_CONSTEXPR float map(float val) { return val; }
-  FMT_CONSTEXPR double map(double val) { return val; }
-  FMT_CONSTEXPR long double map(long double val) { return val; }
+  UMPIRE_FMT_CONSTEXPR float map(float val) { return val; }
+  UMPIRE_FMT_CONSTEXPR double map(double val) { return val; }
+  UMPIRE_FMT_CONSTEXPR long double map(long double val) { return val; }
 
-  FMT_CONSTEXPR const char_type* map(char_type* val) { return val; }
-  FMT_CONSTEXPR const char_type* map(const char_type* val) { return val; }
-  template <typename T, FMT_ENABLE_IF(is_string<T>::value)>
-  FMT_CONSTEXPR basic_string_view<char_type> map(const T& val) {
+  UMPIRE_FMT_CONSTEXPR const char_type* map(char_type* val) { return val; }
+  UMPIRE_FMT_CONSTEXPR const char_type* map(const char_type* val) { return val; }
+  template <typename T, UMPIRE_FMT_ENABLE_IF(is_string<T>::value)>
+  UMPIRE_FMT_CONSTEXPR basic_string_view<char_type> map(const T& val) {
     static_assert(std::is_same<char_type, char_t<T>>::value,
                   "mixing character types is disallowed");
     return to_string_view(val);
   }
   template <typename T,
-            FMT_ENABLE_IF(
+            UMPIRE_FMT_ENABLE_IF(
                 std::is_constructible<basic_string_view<char_type>, T>::value &&
                 !is_string<T>::value && !has_formatter<T, Context>::value &&
                 !has_fallback_formatter<T, Context>::value)>
-  FMT_CONSTEXPR basic_string_view<char_type> map(const T& val) {
+  UMPIRE_FMT_CONSTEXPR basic_string_view<char_type> map(const T& val) {
     return basic_string_view<char_type>(val);
   }
   template <
       typename T,
-      FMT_ENABLE_IF(
+      UMPIRE_FMT_ENABLE_IF(
           std::is_constructible<std_string_view<char_type>, T>::value &&
           !std::is_constructible<basic_string_view<char_type>, T>::value &&
           !is_string<T>::value && !has_formatter<T, Context>::value &&
           !has_fallback_formatter<T, Context>::value)>
-  FMT_CONSTEXPR basic_string_view<char_type> map(const T& val) {
+  UMPIRE_FMT_CONSTEXPR basic_string_view<char_type> map(const T& val) {
     return std_string_view<char_type>(val);
   }
-  FMT_CONSTEXPR const char* map(const signed char* val) {
+  UMPIRE_FMT_CONSTEXPR const char* map(const signed char* val) {
     static_assert(std::is_same<char_type, char>::value, "invalid string type");
     return reinterpret_cast<const char*>(val);
   }
-  FMT_CONSTEXPR const char* map(const unsigned char* val) {
+  UMPIRE_FMT_CONSTEXPR const char* map(const unsigned char* val) {
     static_assert(std::is_same<char_type, char>::value, "invalid string type");
     return reinterpret_cast<const char*>(val);
   }
-  FMT_CONSTEXPR const char* map(signed char* val) {
+  UMPIRE_FMT_CONSTEXPR const char* map(signed char* val) {
     const auto* const_val = val;
     return map(const_val);
   }
-  FMT_CONSTEXPR const char* map(unsigned char* val) {
+  UMPIRE_FMT_CONSTEXPR const char* map(unsigned char* val) {
     const auto* const_val = val;
     return map(const_val);
   }
 
-  FMT_CONSTEXPR const void* map(void* val) { return val; }
-  FMT_CONSTEXPR const void* map(const void* val) { return val; }
-  FMT_CONSTEXPR const void* map(std::nullptr_t val) { return val; }
+  UMPIRE_FMT_CONSTEXPR const void* map(void* val) { return val; }
+  UMPIRE_FMT_CONSTEXPR const void* map(const void* val) { return val; }
+  UMPIRE_FMT_CONSTEXPR const void* map(std::nullptr_t val) { return val; }
 
   // We use SFINAE instead of a const T* parameter to avoid conflicting with
   // the C array overload.
   template <typename T>
-  FMT_CONSTEXPR auto map(T) -> enable_if_t<std::is_pointer<T>::value, int> {
+  UMPIRE_FMT_CONSTEXPR auto map(T) -> enable_if_t<std::is_pointer<T>::value, int> {
     // Formatting of arbitrary pointers is disallowed. If you want to output
     // a pointer cast it to "void *" or "const void *". In particular, this
     // forbids formatting of "[const] volatile char *" which is printed as bool
@@ -1227,29 +1227,29 @@ template <typename Context> struct arg_mapper {
   }
 
   template <typename T, std::size_t N>
-  FMT_CONSTEXPR auto map(const T (&values)[N]) -> const T (&)[N] {
+  UMPIRE_FMT_CONSTEXPR auto map(const T (&values)[N]) -> const T (&)[N] {
     return values;
   }
 
   template <typename T,
-            FMT_ENABLE_IF(std::is_enum<T>::value &&
+            UMPIRE_FMT_ENABLE_IF(std::is_enum<T>::value &&
                           !has_formatter<T, Context>::value &&
                           !has_fallback_formatter<T, Context>::value)>
-  FMT_CONSTEXPR auto map(const T& val)
+  UMPIRE_FMT_CONSTEXPR auto map(const T& val)
       -> decltype(std::declval<arg_mapper>().map(
           static_cast<typename std::underlying_type<T>::type>(val))) {
     return map(static_cast<typename std::underlying_type<T>::type>(val));
   }
   template <typename T,
-            FMT_ENABLE_IF(!is_string<T>::value && !is_char<T>::value &&
+            UMPIRE_FMT_ENABLE_IF(!is_string<T>::value && !is_char<T>::value &&
                           (has_formatter<T, Context>::value ||
                            has_fallback_formatter<T, Context>::value))>
-  FMT_CONSTEXPR const T& map(const T& val) {
+  UMPIRE_FMT_CONSTEXPR const T& map(const T& val) {
     return val;
   }
 
   template <typename T>
-  FMT_CONSTEXPR auto map(const named_arg<char_type, T>& val)
+  UMPIRE_FMT_CONSTEXPR auto map(const named_arg<char_type, T>& val)
       -> decltype(std::declval<arg_mapper>().map(val.value)) {
     return map(val.value);
   }
@@ -1278,11 +1278,11 @@ template <typename Context> class basic_format_arg {
   detail::type type_;
 
   template <typename ContextType, typename T>
-  friend FMT_CONSTEXPR basic_format_arg<ContextType> detail::make_arg(
+  friend UMPIRE_FMT_CONSTEXPR basic_format_arg<ContextType> detail::make_arg(
       const T& value);
 
   template <typename Visitor, typename Ctx>
-  friend FMT_CONSTEXPR auto visit_format_arg(Visitor&& vis,
+  friend UMPIRE_FMT_CONSTEXPR auto visit_format_arg(Visitor&& vis,
                                              const basic_format_arg<Ctx>& arg)
       -> decltype(vis(0));
 
@@ -1313,7 +1313,7 @@ template <typename Context> class basic_format_arg {
 
   constexpr basic_format_arg() : type_(detail::type::none_type) {}
 
-  constexpr explicit operator bool() const FMT_NOEXCEPT {
+  constexpr explicit operator bool() const UMPIRE_FMT_NOEXCEPT {
     return type_ != detail::type::none_type;
   }
 
@@ -1331,7 +1331,7 @@ template <typename Context> class basic_format_arg {
   \endrst
  */
 template <typename Visitor, typename Context>
-FMT_CONSTEXPR_DECL FMT_INLINE auto visit_format_arg(
+UMPIRE_FMT_CONSTEXPR_DECL UMPIRE_FMT_INLINE auto visit_format_arg(
     Visitor&& vis, const basic_format_arg<Context>& arg) -> decltype(vis(0)) {
   using char_type = typename Context::char_type;
   switch (arg.type_) {
@@ -1345,7 +1345,7 @@ FMT_CONSTEXPR_DECL FMT_INLINE auto visit_format_arg(
     return vis(arg.value_.long_long_value);
   case detail::type::ulong_long_type:
     return vis(arg.value_.ulong_long_value);
-#if FMT_USE_INT128
+#if UMPIRE_FMT_USE_INT128
   case detail::type::int128_type:
     return vis(arg.value_.int128_value);
   case detail::type::uint128_type:
@@ -1382,7 +1382,7 @@ template <typename T> struct formattable : std::false_type {};
 
 namespace detail {
 
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 500
+#if UMPIRE_FMT_GCC_VERSION && UMPIRE_FMT_GCC_VERSION < 500
 // A workaround for gcc 4.8 to make void_t work in a SFINAE context.
 template <typename... Ts> struct void_t_impl { using type = void; };
 template <typename... Ts>
@@ -1425,7 +1425,7 @@ class locale_ref {
   constexpr locale_ref() : locale_(nullptr) {}
   template <typename Locale> explicit locale_ref(const Locale& loc);
 
-  explicit operator bool() const FMT_NOEXCEPT { return locale_ != nullptr; }
+  explicit operator bool() const UMPIRE_FMT_NOEXCEPT { return locale_ != nullptr; }
 
   template <typename Locale> Locale get() const;
 };
@@ -1439,7 +1439,7 @@ constexpr unsigned long long encode_types() {
 }
 
 template <typename Context, typename T>
-FMT_CONSTEXPR basic_format_arg<Context> make_arg(const T& value) {
+UMPIRE_FMT_CONSTEXPR basic_format_arg<Context> make_arg(const T& value) {
   basic_format_arg<Context> arg;
   arg.type_ = mapped_type_constant<T, Context>::value;
   arg.value_ = arg_mapper<Context>().map(value);
@@ -1461,13 +1461,13 @@ template <typename T, typename U> constexpr const U& check(const U& val) {
 // a fallback formatter in one translation unit and an implicit conversion in
 // another (not recommended).
 template <bool IS_PACKED, typename Context, type, typename T,
-          FMT_ENABLE_IF(IS_PACKED)>
+          UMPIRE_FMT_ENABLE_IF(IS_PACKED)>
 constexpr value<Context> make_arg(const T& val) {
   return detail::check<T>(arg_mapper<Context>().map(val));
 }
 
 template <bool IS_PACKED, typename Context, type, typename T,
-          FMT_ENABLE_IF(!IS_PACKED)>
+          UMPIRE_FMT_ENABLE_IF(!IS_PACKED)>
 inline basic_format_arg<Context> make_arg(const T& value) {
   return make_arg<Context>(value);
 }
@@ -1502,24 +1502,24 @@ template <typename OutputIt, typename Char> class basic_format_context {
       : out_(out), args_(ctx_args), loc_(loc) {}
 
   constexpr format_arg arg(int id) const { return args_.get(id); }
-  FMT_CONSTEXPR format_arg arg(basic_string_view<char_type> name) {
+  UMPIRE_FMT_CONSTEXPR format_arg arg(basic_string_view<char_type> name) {
     return args_.get(name);
   }
   int arg_id(basic_string_view<char_type> name) { return args_.get_id(name); }
   const basic_format_args<basic_format_context>& args() const { return args_; }
 
-  FMT_CONSTEXPR detail::error_handler error_handler() { return {}; }
+  UMPIRE_FMT_CONSTEXPR detail::error_handler error_handler() { return {}; }
   void on_error(const char* message) { error_handler().on_error(message); }
 
   // Returns an iterator to the beginning of the output range.
-  FMT_CONSTEXPR iterator out() { return out_; }
+  UMPIRE_FMT_CONSTEXPR iterator out() { return out_; }
 
   // Advances the begin iterator to ``it``.
   void advance_to(iterator it) {
     if (!detail::is_back_insert_iterator<iterator>()) out_ = it;
   }
 
-  FMT_CONSTEXPR detail::locale_ref locale() { return loc_; }
+  UMPIRE_FMT_CONSTEXPR detail::locale_ref locale() { return loc_; }
 };
 
 template <typename Char>
@@ -1529,7 +1529,7 @@ using format_context = buffer_context<char>;
 using wformat_context = buffer_context<wchar_t>;
 
 // Workaround an alias issue: https://stackoverflow.com/q/62767544/471164.
-#define FMT_BUFFER_CONTEXT(Char) \
+#define UMPIRE_FMT_BUFFER_CONTEXT(Char) \
   basic_format_context<detail::buffer_appender<Char>, Char>
 
 template <typename T, typename Char = char>
@@ -1546,7 +1546,7 @@ using is_formattable = bool_constant<!std::is_same<
  */
 template <typename Context, typename... Args>
 class format_arg_store
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
+#if UMPIRE_FMT_GCC_VERSION && UMPIRE_FMT_GCC_VERSION < 409
     // Workaround a GCC template argument substitution bug.
     : public basic_format_args<Context>
 #endif
@@ -1573,9 +1573,9 @@ class format_arg_store
            : 0);
 
  public:
-  FMT_CONSTEXPR format_arg_store(const Args&... args)
+  UMPIRE_FMT_CONSTEXPR format_arg_store(const Args&... args)
       :
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
+#if UMPIRE_FMT_GCC_VERSION && UMPIRE_FMT_GCC_VERSION < 409
         basic_format_args<Context>(*this),
 #endif
         data_{detail::make_arg<
@@ -1675,7 +1675,7 @@ template <typename Context> class basic_format_args {
     return (desc_ & detail::has_named_args_bit) != 0;
   }
 
-  FMT_CONSTEXPR detail::type type(int index) const {
+  UMPIRE_FMT_CONSTEXPR detail::type type(int index) const {
     int shift = index * detail::packed_arg_bits;
     unsigned int mask = (1 << detail::packed_arg_bits) - 1;
     return static_cast<detail::type>((desc_ >> shift) & mask);
@@ -1696,7 +1696,7 @@ template <typename Context> class basic_format_args {
    \endrst
    */
   template <typename... Args>
-  constexpr FMT_INLINE basic_format_args(
+  constexpr UMPIRE_FMT_INLINE basic_format_args(
       const format_arg_store<Context, Args...>& store)
       : basic_format_args(format_arg_store<Context, Args...>::desc,
                           store.data_.args()) {}
@@ -1707,7 +1707,7 @@ template <typename Context> class basic_format_args {
    `~umpire::fmt::dynamic_format_arg_store`.
    \endrst
    */
-  constexpr FMT_INLINE basic_format_args(
+  constexpr UMPIRE_FMT_INLINE basic_format_args(
       const dynamic_format_arg_store<Context>& store)
       : basic_format_args(store.get_types(), store.data()) {}
 
@@ -1721,7 +1721,7 @@ template <typename Context> class basic_format_args {
                           args) {}
 
   /** Returns the argument with the specified id. */
-  FMT_CONSTEXPR format_arg get(int id) const {
+  UMPIRE_FMT_CONSTEXPR format_arg get(int id) const {
     format_arg arg;
     if (!is_packed()) {
       if (id < max_size()) arg = args_[id];
@@ -1756,7 +1756,7 @@ template <typename Context> class basic_format_args {
   }
 };
 
-#ifdef FMT_ARM_ABI_COMPATIBILITY
+#ifdef UMPIRE_FMT_ARM_ABI_COMPATIBILITY
 /** An alias to ``basic_format_args<format_context>``. */
 // Separate types would result in shorter symbols but break ABI compatibility
 // between clang and gcc on ARM (#1919).
@@ -1767,7 +1767,7 @@ using wformat_args = basic_format_args<wformat_context>;
 // It is a separate type rather than an alias to make symbols readable.
 struct format_args : basic_format_args<format_context> {
   template <typename... Args>
-  FMT_INLINE format_args(const Args&... args) : basic_format_args(args...) {}
+  UMPIRE_FMT_INLINE format_args(const Args&... args) : basic_format_args(args...) {}
 };
 struct wformat_args : basic_format_args<wformat_context> {
   using basic_format_args::basic_format_args;
@@ -1776,24 +1776,24 @@ struct wformat_args : basic_format_args<wformat_context> {
 
 namespace detail {
 
-template <typename Char, FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
+template <typename Char, UMPIRE_FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
 std::basic_string<Char> vformat(
     basic_string_view<Char> format_str,
     basic_format_args<buffer_context<type_identity_t<Char>>> args);
 
-FMT_API std::string vformat(string_view format_str, format_args args);
+UMPIRE_FMT_API std::string vformat(string_view format_str, format_args args);
 
 template <typename Char>
 void vformat_to(
     buffer<Char>& buf, basic_string_view<Char> format_str,
-    basic_format_args<FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args,
+    basic_format_args<UMPIRE_FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args,
     detail::locale_ref loc = {});
 
 template <typename Char, typename Args,
-          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
+          UMPIRE_FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
 inline void vprint_mojibake(std::FILE*, basic_string_view<Char>, const Args&) {}
 
-FMT_API void vprint_mojibake(std::FILE*, string_view, format_args);
+UMPIRE_FMT_API void vprint_mojibake(std::FILE*, string_view, format_args);
 #ifndef _WIN32
 inline void vprint_mojibake(std::FILE*, string_view, format_args) {}
 #endif
@@ -1823,7 +1823,7 @@ auto vformat_to(OutputIt out, const S& format_str,
    umpire::fmt::format_to(std::back_inserter(out), "{}", 42);
  \endrst
  */
-// We cannot use FMT_ENABLE_IF because of a bug in gcc 8.3.
+// We cannot use UMPIRE_FMT_ENABLE_IF because of a bug in gcc 8.3.
 template <typename OutputIt, typename S, typename... Args,
           bool enable = detail::is_output_iterator<OutputIt, char_t<S>>::value>
 inline auto format_to(OutputIt out, const S& format_str, Args&&... args) ->
@@ -1840,7 +1840,7 @@ template <typename OutputIt> struct format_to_n_result {
 };
 
 template <typename OutputIt, typename Char, typename... Args,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value)>
+          UMPIRE_FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value)>
 inline format_to_n_result<OutputIt> vformat_to_n(
     OutputIt out, size_t n, basic_string_view<Char> format_str,
     basic_format_args<buffer_context<type_identity_t<Char>>> args) {
@@ -1879,7 +1879,7 @@ inline size_t formatted_size(const S& format_str, Args&&... args) {
 }
 
 template <typename S, typename Char = char_t<S>>
-FMT_INLINE std::basic_string<Char> vformat(
+UMPIRE_FMT_INLINE std::basic_string<Char> vformat(
     const S& format_str,
     basic_format_args<buffer_context<type_identity_t<Char>>> args) {
   return detail::vformat(to_string_view(format_str), args);
@@ -1898,21 +1898,21 @@ FMT_INLINE std::basic_string<Char> vformat(
 // Pass char_t as a default template parameter instead of using
 // std::basic_string<char_t<S>> to reduce the symbol size.
 template <typename S, typename... Args, typename Char = char_t<S>,
-          FMT_ENABLE_IF(!FMT_COMPILE_TIME_CHECKS ||
+          UMPIRE_FMT_ENABLE_IF(!UMPIRE_FMT_COMPILE_TIME_CHECKS ||
                         !std::is_same<Char, char>::value)>
-FMT_INLINE std::basic_string<Char> format(const S& format_str, Args&&... args) {
+UMPIRE_FMT_INLINE std::basic_string<Char> format(const S& format_str, Args&&... args) {
   const auto& vargs = umpire::fmt::make_args_checked<Args...>(format_str, args...);
   return detail::vformat(to_string_view(format_str), vargs);
 }
 
-FMT_API void vprint(string_view, format_args);
-FMT_API void vprint(std::FILE*, string_view, format_args);
+UMPIRE_FMT_API void vprint(string_view, format_args);
+UMPIRE_FMT_API void vprint(std::FILE*, string_view, format_args);
 
 /**
   \rst
   Formats ``args`` according to specifications in ``format_str`` and writes the
   output to the file ``f``. Strings are assumed to be Unicode-encoded unless the
-  ``FMT_UNICODE`` macro is set to 0.
+  ``UMPIRE_FMT_UNICODE`` macro is set to 0.
 
   **Example**::
 
@@ -1931,7 +1931,7 @@ inline void print(std::FILE* f, const S& format_str, Args&&... args) {
   \rst
   Formats ``args`` according to specifications in ``format_str`` and writes
   the output to ``stdout``. Strings are assumed to be Unicode-encoded unless
-  the ``FMT_UNICODE`` macro is set to 0.
+  the ``UMPIRE_FMT_UNICODE`` macro is set to 0.
 
   **Example**::
 
@@ -1946,12 +1946,12 @@ inline void print(const S& format_str, Args&&... args) {
              : detail::vprint_mojibake(stdout, to_string_view(format_str),
                                        vargs);
 }
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_CORE_H_
+#endif  // UMPIRE_FMT_CORE_H_
 
-// Define FMT_DYNAMIC_ARGS to make core.h provide dynamic_format_arg_store
+// Define UMPIRE_FMT_DYNAMIC_ARGS to make core.h provide dynamic_format_arg_store
 // DEPRECATED! Include fmt/args.h directly instead.
-#ifdef FMT_DYNAMIC_ARGS
+#ifdef UMPIRE_FMT_DYNAMIC_ARGS
 #include "args.h"
 #endif
diff --git a/src/tpl/umpire/fmt/fmt.hpp b/src/tpl/umpire/fmt/fmt.hpp
index 6a9e70f42..a1d92bb63 100644
--- a/src/tpl/umpire/fmt/fmt.hpp
+++ b/src/tpl/umpire/fmt/fmt.hpp
@@ -6,9 +6,9 @@
 #ifndef UMPIRE_fmt_HPP
 #define UMPIRE_fmt_HPP
 
-#define FMT_EXCEPTIONS 0
-#define FMT_HEADER_ONLY 1
-#define FMT_DEPRECATED
+#define UMPIRE_FMT_EXCEPTIONS 0
+#define UMPIRE_FMT_HEADER_ONLY 1
+#define UMPIRE_FMT_DEPRECATED
 
 #include "args.h"
 #include "chrono.h"
diff --git a/src/tpl/umpire/fmt/format-inl.h b/src/tpl/umpire/fmt/format-inl.h
index 568f17db5..0a76aa784 100644
--- a/src/tpl/umpire/fmt/format-inl.h
+++ b/src/tpl/umpire/fmt/format-inl.h
@@ -5,8 +5,8 @@
 //
 // For the license information refer to format.h.
 
-#ifndef FMT_FORMAT_INL_H_
-#define FMT_FORMAT_INL_H_
+#ifndef UMPIRE_FMT_FORMAT_INL_H_
+#define UMPIRE_FMT_FORMAT_INL_H_
 
 #include <algorithm>
 #include <cctype>
@@ -17,7 +17,7 @@
 #include <cwchar>
 #include <exception>
 
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
+#ifndef UMPIRE_FMT_STATIC_THOUSANDS_SEPARATOR
 #  include <locale>
 #endif
 
@@ -32,10 +32,10 @@
 inline umpire::fmt::detail::null<> strerror_r(int, char*, ...) { return {}; }
 inline umpire::fmt::detail::null<> strerror_s(char*, size_t, ...) { return {}; }
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 namespace detail {
 
-FMT_FUNC void assert_fail(const char* file, int line, const char* message) {
+UMPIRE_FMT_FUNC void assert_fail(const char* file, int line, const char* message) {
   // Use unchecked std::fprintf to avoid triggering another assertion when
   // writing to stderr fails
   std::fprintf(stderr, "%s:%d: assertion failed: %s", file, line, message);
@@ -45,7 +45,7 @@ FMT_FUNC void assert_fail(const char* file, int line, const char* message) {
 }
 
 #ifndef _MSC_VER
-#  define FMT_SNPRINTF snprintf
+#  define UMPIRE_FMT_SNPRINTF snprintf
 #else  // _MSC_VER
 inline int fmt_snprintf(char* buffer, size_t size, const char* format, ...) {
   va_list args;
@@ -54,7 +54,7 @@ inline int fmt_snprintf(char* buffer, size_t size, const char* format, ...) {
   va_end(args);
   return result;
 }
-#  define FMT_SNPRINTF fmt_snprintf
+#  define UMPIRE_FMT_SNPRINTF fmt_snprintf
 #endif  // _MSC_VER
 
 // A portable thread-safe version of strerror.
@@ -67,8 +67,8 @@ inline int fmt_snprintf(char* buffer, size_t size, const char* format, ...) {
 //   other  - failure
 // Buffer should be at least of size 1.
 inline int safe_strerror(int error_code, char*& buffer,
-                         size_t buffer_size) FMT_NOEXCEPT {
-  FMT_ASSERT(buffer != nullptr && buffer_size != 0, "invalid buffer");
+                         size_t buffer_size) UMPIRE_FMT_NOEXCEPT {
+  UMPIRE_FMT_ASSERT(buffer != nullptr && buffer_size != 0, "invalid buffer");
 
   class dispatcher {
    private:
@@ -86,7 +86,7 @@ inline int safe_strerror(int error_code, char*& buffer,
     }
 
     // Handle the result of GNU-specific version of strerror_r.
-    FMT_MAYBE_UNUSED
+    UMPIRE_FMT_MAYBE_UNUSED
     int handle(char* message) {
       // If the buffer is full then the message is probably truncated.
       if (message == buffer_ && strlen(buffer_) == buffer_size_ - 1)
@@ -96,20 +96,20 @@ inline int safe_strerror(int error_code, char*& buffer,
     }
 
     // Handle the case when strerror_r is not available.
-    FMT_MAYBE_UNUSED
+    UMPIRE_FMT_MAYBE_UNUSED
     int handle(detail::null<>) {
       return fallback(strerror_s(buffer_, buffer_size_, error_code_));
     }
 
     // Fallback to strerror_s when strerror_r is not available.
-    FMT_MAYBE_UNUSED
+    UMPIRE_FMT_MAYBE_UNUSED
     int fallback(int result) {
       // If the buffer is full then the message is probably truncated.
       return result == 0 && strlen(buffer_) == buffer_size_ - 1 ? ERANGE
                                                                 : result;
     }
 
-#if !FMT_MSC_VER
+#if !UMPIRE_FMT_MSC_VER
     // Fallback to strerror if strerror_r and strerror_s are not available.
     int fallback(detail::null<>) {
       errno = 0;
@@ -127,8 +127,8 @@ inline int safe_strerror(int error_code, char*& buffer,
   return dispatcher(error_code, buffer, buffer_size).run();
 }
 
-FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
-                                string_view message) FMT_NOEXCEPT {
+UMPIRE_FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
+                                string_view message) UMPIRE_FMT_NOEXCEPT {
   // Report error code making sure that the output fits into
   // inline_buffer_size to avoid dynamic memory allocation and potential
   // bad_alloc.
@@ -145,13 +145,13 @@ FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
   error_code_size += detail::to_unsigned(detail::count_digits(abs_value));
   auto it = buffer_appender<char>(out);
   if (message.size() <= inline_buffer_size - error_code_size)
-    format_to(it, FMT_STRING("{}{}"), message, SEP);
-  format_to(it, FMT_STRING("{}{}"), ERROR_STR, error_code);
-  FMT_ASSERT(out.size() <= inline_buffer_size, "");
+    format_to(it, UMPIRE_FMT_STRING("{}{}"), message, SEP);
+  format_to(it, UMPIRE_FMT_STRING("{}{}"), ERROR_STR, error_code);
+  UMPIRE_FMT_ASSERT(out.size() <= inline_buffer_size, "");
 }
 
-FMT_FUNC void report_error(format_func func, int error_code,
-                           string_view message) FMT_NOEXCEPT {
+UMPIRE_FMT_FUNC void report_error(format_func func, int error_code,
+                           string_view message) UMPIRE_FMT_NOEXCEPT {
   memory_buffer full_message;
   func(full_message, error_code, message);
   // Don't use fwrite_fully because the latter may throw.
@@ -163,10 +163,10 @@ FMT_FUNC void report_error(format_func func, int error_code,
 inline void fwrite_fully(const void* ptr, size_t size, size_t count,
                          FILE* stream) {
   size_t written = std::fwrite(ptr, size, count, stream);
-  if (written < count) FMT_THROW(system_error(errno, "cannot write to file"));
+  if (written < count) UMPIRE_FMT_THROW(system_error(errno, "cannot write to file"));
 }
 
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
+#ifndef UMPIRE_FMT_STATIC_THOUSANDS_SEPARATOR
 template <typename Locale>
 locale_ref::locale_ref(const Locale& loc) : locale_(&loc) {
   static_assert(std::is_same<Locale, std::locale>::value, "");
@@ -177,34 +177,34 @@ template <typename Locale> Locale locale_ref::get() const {
   return locale_ ? *static_cast<const std::locale*>(locale_) : std::locale();
 }
 
-template <typename Char> FMT_FUNC std::string grouping_impl(locale_ref loc) {
+template <typename Char> UMPIRE_FMT_FUNC std::string grouping_impl(locale_ref loc) {
   return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>()).grouping();
 }
-template <typename Char> FMT_FUNC Char thousands_sep_impl(locale_ref loc) {
+template <typename Char> UMPIRE_FMT_FUNC Char thousands_sep_impl(locale_ref loc) {
   return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
       .thousands_sep();
 }
-template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref loc) {
+template <typename Char> UMPIRE_FMT_FUNC Char decimal_point_impl(locale_ref loc) {
   return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
       .decimal_point();
 }
 #else
-template <typename Char> FMT_FUNC std::string grouping_impl(locale_ref) {
+template <typename Char> UMPIRE_FMT_FUNC std::string grouping_impl(locale_ref) {
   return "\03";
 }
-template <typename Char> FMT_FUNC Char thousands_sep_impl(locale_ref) {
-  return FMT_STATIC_THOUSANDS_SEPARATOR;
+template <typename Char> UMPIRE_FMT_FUNC Char thousands_sep_impl(locale_ref) {
+  return UMPIRE_FMT_STATIC_THOUSANDS_SEPARATOR;
 }
-template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref) {
+template <typename Char> UMPIRE_FMT_FUNC Char decimal_point_impl(locale_ref) {
   return '.';
 }
 #endif
 }  // namespace detail
 
-FMT_API FMT_FUNC format_error::~format_error() FMT_NOEXCEPT = default;
-FMT_API FMT_FUNC system_error::~system_error() FMT_NOEXCEPT = default;
+UMPIRE_FMT_API UMPIRE_FMT_FUNC format_error::~format_error() UMPIRE_FMT_NOEXCEPT = default;
+UMPIRE_FMT_API UMPIRE_FMT_FUNC system_error::~system_error() UMPIRE_FMT_NOEXCEPT = default;
 
-FMT_FUNC void system_error::init(int err_code, string_view format_str,
+UMPIRE_FMT_FUNC void system_error::init(int err_code, string_view format_str,
                                  format_args args) {
   error_code_ = err_code;
   memory_buffer buffer;
@@ -215,7 +215,7 @@ FMT_FUNC void system_error::init(int err_code, string_view format_str,
 
 namespace detail {
 
-template <> FMT_FUNC int count_digits<4>(detail::fallback_uintptr n) {
+template <> UMPIRE_FMT_FUNC int count_digits<4>(detail::fallback_uintptr n) {
   // fallback_uintptr is always stored in little endian.
   int i = static_cast<int>(sizeof(void*)) - 1;
   while (i > 0 && n.value[i] == 0) --i;
@@ -243,31 +243,31 @@ const typename basic_data<T>::digit_pair basic_data<T>::digits[] = {
     {'9', '0'}, {'9', '1'}, {'9', '2'}, {'9', '3'}, {'9', '4'}, {'9', '5'},
     {'9', '6'}, {'9', '7'}, {'9', '8'}, {'9', '9'}};
 
-#define FMT_POWERS_OF_10(factor)                                             \
+#define UMPIRE_FMT_POWERS_OF_10(factor)                                             \
   factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
       (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
       (factor)*1000000000
 
 template <typename T>
 const uint64_t basic_data<T>::powers_of_10_64[] = {
-    1, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
+    1, UMPIRE_FMT_POWERS_OF_10(1), UMPIRE_FMT_POWERS_OF_10(1000000000ULL),
     10000000000000000000ULL};
 
 template <typename T>
 const uint32_t basic_data<T>::zero_or_powers_of_10_32[] = {0,
-                                                           FMT_POWERS_OF_10(1)};
+                                                           UMPIRE_FMT_POWERS_OF_10(1)};
 template <typename T>
 const uint64_t basic_data<T>::zero_or_powers_of_10_64[] = {
-    0, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
+    0, UMPIRE_FMT_POWERS_OF_10(1), UMPIRE_FMT_POWERS_OF_10(1000000000ULL),
     10000000000000000000ULL};
 
 template <typename T>
 const uint32_t basic_data<T>::zero_or_powers_of_10_32_new[] = {
-    0, 0, FMT_POWERS_OF_10(1)};
+    0, 0, UMPIRE_FMT_POWERS_OF_10(1)};
 
 template <typename T>
 const uint64_t basic_data<T>::zero_or_powers_of_10_64_new[] = {
-    0, 0, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
+    0, 0, UMPIRE_FMT_POWERS_OF_10(1), UMPIRE_FMT_POWERS_OF_10(1000000000ULL),
     10000000000000000000ULL};
 
 // Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.
@@ -385,7 +385,7 @@ const uint64_t basic_data<T>::dragonbox_pow10_significands_64[] = {
 
 template <typename T>
 const uint128_wrapper basic_data<T>::dragonbox_pow10_significands_128[] = {
-#if FMT_USE_FULL_CACHE_DRAGONBOX
+#if UMPIRE_FMT_USE_FULL_CACHE_DRAGONBOX
     {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
     {0x9faacf3df73609b1, 0x77b191618c54e9ad},
     {0xc795830d75038c1d, 0xd59df5b9ef6a2418},
@@ -1032,7 +1032,7 @@ const uint128_wrapper basic_data<T>::dragonbox_pow10_significands_128[] = {
 #endif
 };
 
-#if !FMT_USE_FULL_CACHE_DRAGONBOX
+#if !UMPIRE_FMT_USE_FULL_CACHE_DRAGONBOX
 template <typename T>
 const uint64_t basic_data<T>::powers_of_5_64[] = {
     0x0000000000000001, 0x0000000000000005, 0x0000000000000019,
@@ -1073,7 +1073,7 @@ constexpr const char basic_data<T>::right_padding_shifts[];
 #endif
 
 template <typename T> struct bits {
-  static FMT_CONSTEXPR_DECL const int value =
+  static UMPIRE_FMT_CONSTEXPR_DECL const int value =
       static_cast<int>(sizeof(T) * std::numeric_limits<unsigned char>::digits);
 };
 
@@ -1104,11 +1104,11 @@ class fp {
   // All sizes are in bits.
   // Subtract 1 to account for an implicit most significant bit in the
   // normalized form.
-  static FMT_CONSTEXPR_DECL const int double_significand_size =
+  static UMPIRE_FMT_CONSTEXPR_DECL const int double_significand_size =
       std::numeric_limits<double>::digits - 1;
-  static FMT_CONSTEXPR_DECL const uint64_t implicit_bit =
+  static UMPIRE_FMT_CONSTEXPR_DECL const uint64_t implicit_bit =
       1ULL << double_significand_size;
-  static FMT_CONSTEXPR_DECL const int significand_size =
+  static UMPIRE_FMT_CONSTEXPR_DECL const int significand_size =
       bits<significand_type>::value;
 
   fp() : f(0), e(0) {}
@@ -1119,7 +1119,7 @@ class fp {
   template <typename Double> explicit fp(Double d) { assign(d); }
 
   // Assigns d to this and return true iff predecessor is closer than successor.
-  template <typename Float, FMT_ENABLE_IF(is_supported_float<Float>::value)>
+  template <typename Float, UMPIRE_FMT_ENABLE_IF(is_supported_float<Float>::value)>
   bool assign(Float d) {
     // Assume float is in the format [sign][exponent][significand].
     using limits = std::numeric_limits<Float>;
@@ -1146,7 +1146,7 @@ class fp {
     return is_predecessor_closer;
   }
 
-  template <typename Float, FMT_ENABLE_IF(!is_supported_float<Float>::value)>
+  template <typename Float, UMPIRE_FMT_ENABLE_IF(!is_supported_float<Float>::value)>
   bool assign(Float) {
     *this = fp();
     return false;
@@ -1173,7 +1173,7 @@ inline bool operator==(fp x, fp y) { return x.f == y.f && x.e == y.e; }
 
 // Computes lhs * rhs / pow(2, 64) rounded to nearest with half-up tie breaking.
 inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {
-#if FMT_USE_INT128
+#if UMPIRE_FMT_USE_INT128
   auto product = static_cast<__uint128_t>(lhs) * rhs;
   auto f = static_cast<uint64_t>(product >> 64);
   return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;
@@ -1225,7 +1225,7 @@ struct accumulator {
     if (lower < n) ++upper;
   }
   void operator>>=(int shift) {
-    FMT_ASSERT(shift == 32, "");
+    UMPIRE_FMT_ASSERT(shift == 32, "");
     (void)shift;
     lower = (upper << 32) | (lower >> 32);
     upper >>= 32;
@@ -1245,7 +1245,7 @@ class bigint {
   bigit operator[](int index) const { return bigits_[to_unsigned(index)]; }
   bigit& operator[](int index) { return bigits_[to_unsigned(index)]; }
 
-  static FMT_CONSTEXPR_DECL const int bigit_bits = bits<bigit>::value;
+  static UMPIRE_FMT_CONSTEXPR_DECL const int bigit_bits = bits<bigit>::value;
 
   friend struct formatter<bigint>;
 
@@ -1263,8 +1263,8 @@ class bigint {
 
   // Computes *this -= other assuming aligned bigints and *this >= other.
   void subtract_aligned(const bigint& other) {
-    FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
-    FMT_ASSERT(compare(*this, other) >= 0, "");
+    UMPIRE_FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
+    UMPIRE_FMT_ASSERT(compare(*this, other) >= 0, "");
     bigit borrow = 0;
     int i = other.exp_ - exp_;
     for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
@@ -1304,7 +1304,7 @@ class bigint {
  public:
   bigint() : exp_(0) {}
   explicit bigint(uint64_t n) { assign(n); }
-  ~bigint() { FMT_ASSERT(bigits_.capacity() <= bigits_capacity, ""); }
+  ~bigint() { UMPIRE_FMT_ASSERT(bigits_.capacity() <= bigits_capacity, ""); }
 
   bigint(const bigint&) = delete;
   void operator=(const bigint&) = delete;
@@ -1329,8 +1329,8 @@ class bigint {
 
   int num_bigits() const { return static_cast<int>(bigits_.size()) + exp_; }
 
-  FMT_NOINLINE bigint& operator<<=(int shift) {
-    FMT_ASSERT(shift >= 0, "");
+  UMPIRE_FMT_NOINLINE bigint& operator<<=(int shift) {
+    UMPIRE_FMT_ASSERT(shift >= 0, "");
     exp_ += shift / bigit_bits;
     shift %= bigit_bits;
     if (shift == 0) return *this;
@@ -1345,7 +1345,7 @@ class bigint {
   }
 
   template <typename Int> bigint& operator*=(Int value) {
-    FMT_ASSERT(value > 0, "");
+    UMPIRE_FMT_ASSERT(value > 0, "");
     multiply(uint32_or_64_or_128_t<Int>(value));
     return *this;
   }
@@ -1392,7 +1392,7 @@ class bigint {
 
   // Assigns pow(10, exp) to this bigint.
   void assign_pow10(int exp) {
-    FMT_ASSERT(exp >= 0, "");
+    UMPIRE_FMT_ASSERT(exp >= 0, "");
     if (exp == 0) return assign(1);
     // Find the top bit.
     int bitmask = 1;
@@ -1415,7 +1415,7 @@ class bigint {
     int num_bigits = static_cast<int>(bigits_.size());
     int num_result_bigits = 2 * num_bigits;
     bigits_.resize(to_unsigned(num_result_bigits));
-    using accumulator_t = conditional_t<FMT_USE_INT128, uint128_t, accumulator>;
+    using accumulator_t = conditional_t<UMPIRE_FMT_USE_INT128, uint128_t, accumulator>;
     auto sum = accumulator_t();
     for (int bigit_index = 0; bigit_index < num_bigits; ++bigit_index) {
       // Compute bigit at position bigit_index of the result by adding
@@ -1456,9 +1456,9 @@ class bigint {
   // Divides this bignum by divisor, assigning the remainder to this and
   // returning the quotient.
   int divmod_assign(const bigint& divisor) {
-    FMT_ASSERT(this != &divisor, "");
+    UMPIRE_FMT_ASSERT(this != &divisor, "");
     if (compare(*this, divisor) < 0) return 0;
-    FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
+    UMPIRE_FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
     align(divisor);
     int quotient = 0;
     do {
@@ -1477,9 +1477,9 @@ enum class round_direction { unknown, up, down };
 // error should be less than divisor / 2.
 inline round_direction get_round_direction(uint64_t divisor, uint64_t remainder,
                                            uint64_t error) {
-  FMT_ASSERT(remainder < divisor, "");  // divisor - remainder won't overflow.
-  FMT_ASSERT(error < divisor, "");      // divisor - error won't overflow.
-  FMT_ASSERT(error < divisor - error, "");  // error * 2 won't overflow.
+  UMPIRE_FMT_ASSERT(remainder < divisor, "");  // divisor - remainder won't overflow.
+  UMPIRE_FMT_ASSERT(error < divisor, "");      // divisor - error won't overflow.
+  UMPIRE_FMT_ASSERT(error < divisor - error, "");  // error * 2 won't overflow.
   // Round down if (remainder + error) * 2 <= divisor.
   if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)
     return round_direction::down;
@@ -1503,15 +1503,15 @@ enum result {
 // error: the size of the region (lower, upper) outside of which numbers
 // definitely do not round to value (Delta in Grisu3).
 template <typename Handler>
-FMT_ALWAYS_INLINE digits::result grisu_gen_digits(fp value, uint64_t error,
+UMPIRE_FMT_ALWAYS_INLINE digits::result grisu_gen_digits(fp value, uint64_t error,
                                                   int& exp, Handler& handler) {
   const fp one(1ULL << -value.e, value.e);
   // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be
   // zero because it contains a product of two 64-bit numbers with MSB set (due
   // to normalization) - 1, shifted right by at most 60 bits.
   auto integral = static_cast<uint32_t>(value.f >> -one.e);
-  FMT_ASSERT(integral != 0, "");
-  FMT_ASSERT(integral == value.f >> -one.e, "");
+  UMPIRE_FMT_ASSERT(integral != 0, "");
+  UMPIRE_FMT_ASSERT(integral == value.f >> -one.e, "");
   // The fractional part of scaled value (p2 in Grisu) c = value % one.
   uint64_t fractional = value.f & (one.f - 1);
   exp = count_digits(integral);  // kappa in Grisu.
@@ -1561,7 +1561,7 @@ FMT_ALWAYS_INLINE digits::result grisu_gen_digits(fp value, uint64_t error,
       integral = 0;
       break;
     default:
-      FMT_ASSERT(false, "invalid number of digits");
+      UMPIRE_FMT_ASSERT(false, "invalid number of digits");
     }
     --exp;
     auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;
@@ -1609,7 +1609,7 @@ struct fixed_handler {
 
   digits::result on_digit(char digit, uint64_t divisor, uint64_t remainder,
                           uint64_t error, int, bool integral) {
-    FMT_ASSERT(remainder < divisor, "");
+    UMPIRE_FMT_ASSERT(remainder < divisor, "");
     buf[size++] = digit;
     if (!integral && error >= remainder) return digits::error;
     if (size < precision) return digits::more;
@@ -1619,7 +1619,7 @@ struct fixed_handler {
       // and divisor > (1 << 32) there.
       if (error >= divisor || error >= divisor - error) return digits::error;
     } else {
-      FMT_ASSERT(error == 1 && divisor > 2, "");
+      UMPIRE_FMT_ASSERT(error == 1 && divisor > 2, "");
     }
     auto dir = get_round_direction(divisor, remainder, error);
     if (dir != round_direction::up)
@@ -1643,8 +1643,8 @@ struct fixed_handler {
 // Implementation of Dragonbox algorithm: https://github.com/jk-jeon/dragonbox.
 namespace dragonbox {
 // Computes 128-bit result of multiplication of two 64-bit unsigned integers.
-inline uint128_wrapper umul128(uint64_t x, uint64_t y) FMT_NOEXCEPT {
-#if FMT_USE_INT128
+inline uint128_wrapper umul128(uint64_t x, uint64_t y) UMPIRE_FMT_NOEXCEPT {
+#if UMPIRE_FMT_USE_INT128
   return static_cast<uint128_t>(x) * static_cast<uint128_t>(y);
 #elif defined(_MSC_VER) && defined(_M_X64)
   uint128_wrapper result;
@@ -1671,8 +1671,8 @@ inline uint128_wrapper umul128(uint64_t x, uint64_t y) FMT_NOEXCEPT {
 }
 
 // Computes upper 64 bits of multiplication of two 64-bit unsigned integers.
-inline uint64_t umul128_upper64(uint64_t x, uint64_t y) FMT_NOEXCEPT {
-#if FMT_USE_INT128
+inline uint64_t umul128_upper64(uint64_t x, uint64_t y) UMPIRE_FMT_NOEXCEPT {
+#if UMPIRE_FMT_USE_INT128
   auto p = static_cast<uint128_t>(x) * static_cast<uint128_t>(y);
   return static_cast<uint64_t>(p >> 64);
 #elif defined(_MSC_VER) && defined(_M_X64)
@@ -1684,7 +1684,7 @@ inline uint64_t umul128_upper64(uint64_t x, uint64_t y) FMT_NOEXCEPT {
 
 // Computes upper 64 bits of multiplication of a 64-bit unsigned integer and a
 // 128-bit unsigned integer.
-inline uint64_t umul192_upper64(uint64_t x, uint128_wrapper y) FMT_NOEXCEPT {
+inline uint64_t umul192_upper64(uint64_t x, uint128_wrapper y) UMPIRE_FMT_NOEXCEPT {
   uint128_wrapper g0 = umul128(x, y.high());
   g0 += umul128_upper64(x, y.low());
   return g0.high();
@@ -1692,13 +1692,13 @@ inline uint64_t umul192_upper64(uint64_t x, uint128_wrapper y) FMT_NOEXCEPT {
 
 // Computes upper 32 bits of multiplication of a 32-bit unsigned integer and a
 // 64-bit unsigned integer.
-inline uint32_t umul96_upper32(uint32_t x, uint64_t y) FMT_NOEXCEPT {
+inline uint32_t umul96_upper32(uint32_t x, uint64_t y) UMPIRE_FMT_NOEXCEPT {
   return static_cast<uint32_t>(umul128_upper64(x, y));
 }
 
 // Computes middle 64 bits of multiplication of a 64-bit unsigned integer and a
 // 128-bit unsigned integer.
-inline uint64_t umul192_middle64(uint64_t x, uint128_wrapper y) FMT_NOEXCEPT {
+inline uint64_t umul192_middle64(uint64_t x, uint128_wrapper y) UMPIRE_FMT_NOEXCEPT {
   uint64_t g01 = x * y.high();
   uint64_t g10 = umul128_upper64(x, y.low());
   return g01 + g10;
@@ -1706,22 +1706,22 @@ inline uint64_t umul192_middle64(uint64_t x, uint128_wrapper y) FMT_NOEXCEPT {
 
 // Computes lower 64 bits of multiplication of a 32-bit unsigned integer and a
 // 64-bit unsigned integer.
-inline uint64_t umul96_lower64(uint32_t x, uint64_t y) FMT_NOEXCEPT {
+inline uint64_t umul96_lower64(uint32_t x, uint64_t y) UMPIRE_FMT_NOEXCEPT {
   return x * y;
 }
 
 // Computes floor(log10(pow(2, e))) for e in [-1700, 1700] using the method from
 // https://fmt.dev/papers/Grisu-Exact.pdf#page=5, section 3.4.
-inline int floor_log10_pow2(int e) FMT_NOEXCEPT {
-  FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
+inline int floor_log10_pow2(int e) UMPIRE_FMT_NOEXCEPT {
+  UMPIRE_FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
   const int shift = 22;
   return (e * static_cast<int>(data::log10_2_significand >> (64 - shift))) >>
          shift;
 }
 
 // Various fast log computations.
-inline int floor_log2_pow10(int e) FMT_NOEXCEPT {
-  FMT_ASSERT(e <= 1233 && e >= -1233, "too large exponent");
+inline int floor_log2_pow10(int e) UMPIRE_FMT_NOEXCEPT {
+  UMPIRE_FMT_ASSERT(e <= 1233 && e >= -1233, "too large exponent");
   const uint64_t log2_10_integer_part = 3;
   const uint64_t log2_10_fractional_digits = 0x5269e12f346e2bf9;
   const int shift_amount = 19;
@@ -1730,8 +1730,8 @@ inline int floor_log2_pow10(int e) FMT_NOEXCEPT {
                   (log2_10_fractional_digits >> (64 - shift_amount)))) >>
          shift_amount;
 }
-inline int floor_log10_pow2_minus_log10_4_over_3(int e) FMT_NOEXCEPT {
-  FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
+inline int floor_log10_pow2_minus_log10_4_over_3(int e) UMPIRE_FMT_NOEXCEPT {
+  UMPIRE_FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
   const uint64_t log10_4_over_3_fractional_digits = 0x1ffbfc2bbc780375;
   const int shift_amount = 22;
   return (e * static_cast<int>(data::log10_2_significand >>
@@ -1742,33 +1742,33 @@ inline int floor_log10_pow2_minus_log10_4_over_3(int e) FMT_NOEXCEPT {
 }
 
 // Returns true iff x is divisible by pow(2, exp).
-inline bool divisible_by_power_of_2(uint32_t x, int exp) FMT_NOEXCEPT {
-  FMT_ASSERT(exp >= 1, "");
-  FMT_ASSERT(x != 0, "");
-#ifdef FMT_BUILTIN_CTZ
-  return FMT_BUILTIN_CTZ(x) >= exp;
+inline bool divisible_by_power_of_2(uint32_t x, int exp) UMPIRE_FMT_NOEXCEPT {
+  UMPIRE_FMT_ASSERT(exp >= 1, "");
+  UMPIRE_FMT_ASSERT(x != 0, "");
+#ifdef UMPIRE_FMT_BUILTIN_CTZ
+  return UMPIRE_FMT_BUILTIN_CTZ(x) >= exp;
 #else
   return exp < num_bits<uint32_t>() && x == ((x >> exp) << exp);
 #endif
 }
-inline bool divisible_by_power_of_2(uint64_t x, int exp) FMT_NOEXCEPT {
-  FMT_ASSERT(exp >= 1, "");
-  FMT_ASSERT(x != 0, "");
-#ifdef FMT_BUILTIN_CTZLL
-  return FMT_BUILTIN_CTZLL(x) >= exp;
+inline bool divisible_by_power_of_2(uint64_t x, int exp) UMPIRE_FMT_NOEXCEPT {
+  UMPIRE_FMT_ASSERT(exp >= 1, "");
+  UMPIRE_FMT_ASSERT(x != 0, "");
+#ifdef UMPIRE_FMT_BUILTIN_CTZLL
+  return UMPIRE_FMT_BUILTIN_CTZLL(x) >= exp;
 #else
   return exp < num_bits<uint64_t>() && x == ((x >> exp) << exp);
 #endif
 }
 
 // Returns true iff x is divisible by pow(5, exp).
-inline bool divisible_by_power_of_5(uint32_t x, int exp) FMT_NOEXCEPT {
-  FMT_ASSERT(exp <= 10, "too large exponent");
+inline bool divisible_by_power_of_5(uint32_t x, int exp) UMPIRE_FMT_NOEXCEPT {
+  UMPIRE_FMT_ASSERT(exp <= 10, "too large exponent");
   return x * data::divtest_table_for_pow5_32[exp].mod_inv <=
          data::divtest_table_for_pow5_32[exp].max_quotient;
 }
-inline bool divisible_by_power_of_5(uint64_t x, int exp) FMT_NOEXCEPT {
-  FMT_ASSERT(exp <= 23, "too large exponent");
+inline bool divisible_by_power_of_5(uint64_t x, int exp) UMPIRE_FMT_NOEXCEPT {
+  UMPIRE_FMT_ASSERT(exp <= 23, "too large exponent");
   return x * data::divtest_table_for_pow5_64[exp].mod_inv <=
          data::divtest_table_for_pow5_64[exp].max_quotient;
 }
@@ -1777,7 +1777,7 @@ inline bool divisible_by_power_of_5(uint64_t x, int exp) FMT_NOEXCEPT {
 // divisible by pow(5, N).
 // Precondition: n <= 2 * pow(5, N + 1).
 template <int N>
-bool check_divisibility_and_divide_by_pow5(uint32_t& n) FMT_NOEXCEPT {
+bool check_divisibility_and_divide_by_pow5(uint32_t& n) UMPIRE_FMT_NOEXCEPT {
   static constexpr struct {
     uint32_t magic_number;
     int bits_for_comparison;
@@ -1794,23 +1794,23 @@ bool check_divisibility_and_divide_by_pow5(uint32_t& n) FMT_NOEXCEPT {
 
 // Computes floor(n / pow(10, N)) for small n and N.
 // Precondition: n <= pow(10, N + 1).
-template <int N> uint32_t small_division_by_pow10(uint32_t n) FMT_NOEXCEPT {
+template <int N> uint32_t small_division_by_pow10(uint32_t n) UMPIRE_FMT_NOEXCEPT {
   static constexpr struct {
     uint32_t magic_number;
     int shift_amount;
     uint32_t divisor_times_10;
   } infos[] = {{0xcccd, 19, 100}, {0xa3d8, 22, 1000}};
   constexpr auto info = infos[N - 1];
-  FMT_ASSERT(n <= info.divisor_times_10, "n is too large");
+  UMPIRE_FMT_ASSERT(n <= info.divisor_times_10, "n is too large");
   return n * info.magic_number >> info.shift_amount;
 }
 
 // Computes floor(n / 10^(kappa + 1)) (float)
-inline uint32_t divide_by_10_to_kappa_plus_1(uint32_t n) FMT_NOEXCEPT {
+inline uint32_t divide_by_10_to_kappa_plus_1(uint32_t n) UMPIRE_FMT_NOEXCEPT {
   return n / float_info<float>::big_divisor;
 }
 // Computes floor(n / 10^(kappa + 1)) (double)
-inline uint64_t divide_by_10_to_kappa_plus_1(uint64_t n) FMT_NOEXCEPT {
+inline uint64_t divide_by_10_to_kappa_plus_1(uint64_t n) UMPIRE_FMT_NOEXCEPT {
   return umul128_upper64(n, 0x83126e978d4fdf3c) >> 9;
 }
 
@@ -1821,47 +1821,47 @@ template <> struct cache_accessor<float> {
   using carrier_uint = float_info<float>::carrier_uint;
   using cache_entry_type = uint64_t;
 
-  static uint64_t get_cached_power(int k) FMT_NOEXCEPT {
-    FMT_ASSERT(k >= float_info<float>::min_k && k <= float_info<float>::max_k,
+  static uint64_t get_cached_power(int k) UMPIRE_FMT_NOEXCEPT {
+    UMPIRE_FMT_ASSERT(k >= float_info<float>::min_k && k <= float_info<float>::max_k,
                "k is out of range");
     return data::dragonbox_pow10_significands_64[k - float_info<float>::min_k];
   }
 
   static carrier_uint compute_mul(carrier_uint u,
-                                  const cache_entry_type& cache) FMT_NOEXCEPT {
+                                  const cache_entry_type& cache) UMPIRE_FMT_NOEXCEPT {
     return umul96_upper32(u, cache);
   }
 
   static uint32_t compute_delta(const cache_entry_type& cache,
-                                int beta_minus_1) FMT_NOEXCEPT {
+                                int beta_minus_1) UMPIRE_FMT_NOEXCEPT {
     return static_cast<uint32_t>(cache >> (64 - 1 - beta_minus_1));
   }
 
   static bool compute_mul_parity(carrier_uint two_f,
                                  const cache_entry_type& cache,
-                                 int beta_minus_1) FMT_NOEXCEPT {
-    FMT_ASSERT(beta_minus_1 >= 1, "");
-    FMT_ASSERT(beta_minus_1 < 64, "");
+                                 int beta_minus_1) UMPIRE_FMT_NOEXCEPT {
+    UMPIRE_FMT_ASSERT(beta_minus_1 >= 1, "");
+    UMPIRE_FMT_ASSERT(beta_minus_1 < 64, "");
 
     return ((umul96_lower64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;
   }
 
   static carrier_uint compute_left_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
+      const cache_entry_type& cache, int beta_minus_1) UMPIRE_FMT_NOEXCEPT {
     return static_cast<carrier_uint>(
         (cache - (cache >> (float_info<float>::significand_bits + 2))) >>
         (64 - float_info<float>::significand_bits - 1 - beta_minus_1));
   }
 
   static carrier_uint compute_right_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
+      const cache_entry_type& cache, int beta_minus_1) UMPIRE_FMT_NOEXCEPT {
     return static_cast<carrier_uint>(
         (cache + (cache >> (float_info<float>::significand_bits + 1))) >>
         (64 - float_info<float>::significand_bits - 1 - beta_minus_1));
   }
 
   static carrier_uint compute_round_up_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
+      const cache_entry_type& cache, int beta_minus_1) UMPIRE_FMT_NOEXCEPT {
     return (static_cast<carrier_uint>(
                 cache >>
                 (64 - float_info<float>::significand_bits - 2 - beta_minus_1)) +
@@ -1874,11 +1874,11 @@ template <> struct cache_accessor<double> {
   using carrier_uint = float_info<double>::carrier_uint;
   using cache_entry_type = uint128_wrapper;
 
-  static uint128_wrapper get_cached_power(int k) FMT_NOEXCEPT {
-    FMT_ASSERT(k >= float_info<double>::min_k && k <= float_info<double>::max_k,
+  static uint128_wrapper get_cached_power(int k) UMPIRE_FMT_NOEXCEPT {
+    UMPIRE_FMT_ASSERT(k >= float_info<double>::min_k && k <= float_info<double>::max_k,
                "k is out of range");
 
-#if FMT_USE_FULL_CACHE_DRAGONBOX
+#if UMPIRE_FMT_USE_FULL_CACHE_DRAGONBOX
     return data::dragonbox_pow10_significands_128[k -
                                                   float_info<double>::min_k];
 #else
@@ -1896,7 +1896,7 @@ template <> struct cache_accessor<double> {
 
     // Compute the required amount of bit-shift.
     int alpha = floor_log2_pow10(kb + offset) - floor_log2_pow10(kb) - offset;
-    FMT_ASSERT(alpha > 0 && alpha < 64, "shifting error detected");
+    UMPIRE_FMT_ASSERT(alpha > 0 && alpha < 64, "shifting error detected");
 
     // Try to recover the real cache.
     uint64_t pow5 = data::powers_of_5_64[offset];
@@ -1922,46 +1922,46 @@ template <> struct cache_accessor<double> {
                      0x3;
 
     // Add the error back.
-    FMT_ASSERT(recovered_cache.low() + error >= recovered_cache.low(), "");
+    UMPIRE_FMT_ASSERT(recovered_cache.low() + error >= recovered_cache.low(), "");
     return {recovered_cache.high(), recovered_cache.low() + error};
 #endif
   }
 
   static carrier_uint compute_mul(carrier_uint u,
-                                  const cache_entry_type& cache) FMT_NOEXCEPT {
+                                  const cache_entry_type& cache) UMPIRE_FMT_NOEXCEPT {
     return umul192_upper64(u, cache);
   }
 
   static uint32_t compute_delta(cache_entry_type const& cache,
-                                int beta_minus_1) FMT_NOEXCEPT {
+                                int beta_minus_1) UMPIRE_FMT_NOEXCEPT {
     return static_cast<uint32_t>(cache.high() >> (64 - 1 - beta_minus_1));
   }
 
   static bool compute_mul_parity(carrier_uint two_f,
                                  const cache_entry_type& cache,
-                                 int beta_minus_1) FMT_NOEXCEPT {
-    FMT_ASSERT(beta_minus_1 >= 1, "");
-    FMT_ASSERT(beta_minus_1 < 64, "");
+                                 int beta_minus_1) UMPIRE_FMT_NOEXCEPT {
+    UMPIRE_FMT_ASSERT(beta_minus_1 >= 1, "");
+    UMPIRE_FMT_ASSERT(beta_minus_1 < 64, "");
 
     return ((umul192_middle64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;
   }
 
   static carrier_uint compute_left_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
+      const cache_entry_type& cache, int beta_minus_1) UMPIRE_FMT_NOEXCEPT {
     return (cache.high() -
             (cache.high() >> (float_info<double>::significand_bits + 2))) >>
            (64 - float_info<double>::significand_bits - 1 - beta_minus_1);
   }
 
   static carrier_uint compute_right_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
+      const cache_entry_type& cache, int beta_minus_1) UMPIRE_FMT_NOEXCEPT {
     return (cache.high() +
             (cache.high() >> (float_info<double>::significand_bits + 1))) >>
            (64 - float_info<double>::significand_bits - 1 - beta_minus_1);
   }
 
   static carrier_uint compute_round_up_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
+      const cache_entry_type& cache, int beta_minus_1) UMPIRE_FMT_NOEXCEPT {
     return ((cache.high() >>
              (64 - float_info<double>::significand_bits - 2 - beta_minus_1)) +
             1) /
@@ -1971,7 +1971,7 @@ template <> struct cache_accessor<double> {
 
 // Various integer checks
 template <class T>
-bool is_left_endpoint_integer_shorter_interval(int exponent) FMT_NOEXCEPT {
+bool is_left_endpoint_integer_shorter_interval(int exponent) UMPIRE_FMT_NOEXCEPT {
   return exponent >=
              float_info<
                  T>::case_shorter_interval_left_endpoint_lower_threshold &&
@@ -1980,7 +1980,7 @@ bool is_left_endpoint_integer_shorter_interval(int exponent) FMT_NOEXCEPT {
 }
 template <class T>
 bool is_endpoint_integer(typename float_info<T>::carrier_uint two_f,
-                         int exponent, int minus_k) FMT_NOEXCEPT {
+                         int exponent, int minus_k) UMPIRE_FMT_NOEXCEPT {
   if (exponent < float_info<T>::case_fc_pm_half_lower_threshold) return false;
   // For k >= 0.
   if (exponent <= float_info<T>::case_fc_pm_half_upper_threshold) return true;
@@ -1991,7 +1991,7 @@ bool is_endpoint_integer(typename float_info<T>::carrier_uint two_f,
 
 template <class T>
 bool is_center_integer(typename float_info<T>::carrier_uint two_f, int exponent,
-                       int minus_k) FMT_NOEXCEPT {
+                       int minus_k) UMPIRE_FMT_NOEXCEPT {
   // Exponent for 5 is negative.
   if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;
   if (exponent > float_info<T>::case_fc_upper_threshold)
@@ -2003,9 +2003,9 @@ bool is_center_integer(typename float_info<T>::carrier_uint two_f, int exponent,
 }
 
 // Remove trailing zeros from n and return the number of zeros removed (float)
-FMT_ALWAYS_INLINE int remove_trailing_zeros(uint32_t& n) FMT_NOEXCEPT {
-#ifdef FMT_BUILTIN_CTZ
-  int t = FMT_BUILTIN_CTZ(n);
+UMPIRE_FMT_ALWAYS_INLINE int remove_trailing_zeros(uint32_t& n) UMPIRE_FMT_NOEXCEPT {
+#ifdef UMPIRE_FMT_BUILTIN_CTZ
+  int t = UMPIRE_FMT_BUILTIN_CTZ(n);
 #else
   int t = ctz(n);
 #endif
@@ -2031,9 +2031,9 @@ FMT_ALWAYS_INLINE int remove_trailing_zeros(uint32_t& n) FMT_NOEXCEPT {
 }
 
 // Removes trailing zeros and returns the number of zeros removed (double)
-FMT_ALWAYS_INLINE int remove_trailing_zeros(uint64_t& n) FMT_NOEXCEPT {
-#ifdef FMT_BUILTIN_CTZLL
-  int t = FMT_BUILTIN_CTZLL(n);
+UMPIRE_FMT_ALWAYS_INLINE int remove_trailing_zeros(uint64_t& n) UMPIRE_FMT_NOEXCEPT {
+#ifdef UMPIRE_FMT_BUILTIN_CTZLL
+  int t = UMPIRE_FMT_BUILTIN_CTZLL(n);
 #else
   int t = ctzll(n);
 #endif
@@ -2117,8 +2117,8 @@ FMT_ALWAYS_INLINE int remove_trailing_zeros(uint64_t& n) FMT_NOEXCEPT {
 
 // The main algorithm for shorter interval case
 template <class T>
-FMT_ALWAYS_INLINE decimal_fp<T> shorter_interval_case(int exponent)
-    FMT_NOEXCEPT {
+UMPIRE_FMT_ALWAYS_INLINE decimal_fp<T> shorter_interval_case(int exponent)
+    UMPIRE_FMT_NOEXCEPT {
   decimal_fp<T> ret_value;
   // Compute k and beta
   const int minus_k = floor_log10_pow2_minus_log10_4_over_3(exponent);
@@ -2164,7 +2164,7 @@ FMT_ALWAYS_INLINE decimal_fp<T> shorter_interval_case(int exponent)
   return ret_value;
 }
 
-template <typename T> decimal_fp<T> to_decimal(T x) FMT_NOEXCEPT {
+template <typename T> decimal_fp<T> to_decimal(T x) UMPIRE_FMT_NOEXCEPT {
   // Step 1: integer promotion & Schubfach multiplier calculation.
 
   using carrier_uint = typename float_info<T>::carrier_uint;
@@ -2421,7 +2421,7 @@ void fallback_format(Double d, int num_digits, bool binary32, buffer<char>& buf,
 template <typename T>
 int format_float(T value, int precision, float_specs specs, buffer<char>& buf) {
   static_assert(!std::is_same<T, float>::value, "");
-  FMT_ASSERT(value >= 0, "value is negative");
+  UMPIRE_FMT_ASSERT(value >= 0, "value is negative");
 
   const bool fixed = specs.format == float_format::fixed;
   if (value <= 0) {  // <= instead of == to silence a warning.
@@ -2485,7 +2485,7 @@ template <typename T>
 int snprintf_float(T value, int precision, float_specs specs,
                    buffer<char>& buf) {
   // Buffer capacity must be non-zero, otherwise MSVC's vsnprintf_s will fail.
-  FMT_ASSERT(buf.capacity() > buf.size(), "empty buffer");
+  UMPIRE_FMT_ASSERT(buf.capacity() > buf.size(), "empty buffer");
   static_assert(!std::is_same<T, float>::value, "");
 
   // Subtract 1 to account for the difference in precision since we use %e for
@@ -2515,14 +2515,14 @@ int snprintf_float(T value, int precision, float_specs specs,
   for (;;) {
     auto begin = buf.data() + offset;
     auto capacity = buf.capacity() - offset;
-#ifdef FMT_FUZZ
+#ifdef UMPIRE_FMT_FUZZ
     if (precision > 100000)
       throw std::runtime_error(
           "fuzz mode - avoid large allocation inside snprintf");
 #endif
     // Suppress the warning about a nonliteral format string.
     // Cannot use auto because of a bug in MinGW (#1532).
-    int (*snprintf_ptr)(char*, size_t, const char*, ...) = FMT_SNPRINTF;
+    int (*snprintf_ptr)(char*, size_t, const char*, ...) = UMPIRE_FMT_SNPRINTF;
     int result = precision >= 0
                      ? snprintf_ptr(begin, capacity, format, precision, value)
                      : snprintf_ptr(begin, capacity, format, value);
@@ -2563,11 +2563,11 @@ int snprintf_float(T value, int precision, float_specs specs,
       --exp_pos;
     } while (*exp_pos != 'e');
     char sign = exp_pos[1];
-    FMT_ASSERT(sign == '+' || sign == '-', "");
+    UMPIRE_FMT_ASSERT(sign == '+' || sign == '-', "");
     int exp = 0;
     auto p = exp_pos + 2;  // Skip 'e' and sign.
     do {
-      FMT_ASSERT(is_digit(*p), "");
+      UMPIRE_FMT_ASSERT(is_digit(*p), "");
       exp = exp * 10 + (*p++ - '0');
     } while (p != end);
     if (sign == '-') exp = -exp;
@@ -2586,7 +2586,7 @@ int snprintf_float(T value, int precision, float_specs specs,
 }
 
 struct stringifier {
-  template <typename T> FMT_INLINE std::string operator()(T value) const {
+  template <typename T> UMPIRE_FMT_INLINE std::string operator()(T value) const {
     return to_string(value);
   }
   std::string operator()(basic_format_arg<format_context>::handle h) const {
@@ -2600,7 +2600,7 @@ struct stringifier {
 }  // namespace detail
 
 template <> struct formatter<detail::bigint> {
-  FMT_CONSTEXPR format_parse_context::iterator parse(
+  UMPIRE_FMT_CONSTEXPR format_parse_context::iterator parse(
       format_parse_context& ctx) {
     return ctx.begin();
   }
@@ -2612,22 +2612,22 @@ template <> struct formatter<detail::bigint> {
     for (auto i = n.bigits_.size(); i > 0; --i) {
       auto value = n.bigits_[i - 1u];
       if (first) {
-        out = format_to(out, FMT_STRING("{:x}"), value);
+        out = format_to(out, UMPIRE_FMT_STRING("{:x}"), value);
         first = false;
         continue;
       }
-      out = format_to(out, FMT_STRING("{:08x}"), value);
+      out = format_to(out, UMPIRE_FMT_STRING("{:08x}"), value);
     }
     if (n.exp_ > 0)
-      out = format_to(out, FMT_STRING("p{}"),
+      out = format_to(out, UMPIRE_FMT_STRING("p{}"),
                       n.exp_ * detail::bigint::bigit_bits);
     return out;
   }
 };
 
-FMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {
+UMPIRE_FMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {
   for_each_codepoint(s, [this](uint32_t cp, int error) {
-    if (error != 0) FMT_THROW(std::runtime_error("invalid utf8"));
+    if (error != 0) UMPIRE_FMT_THROW(std::runtime_error("invalid utf8"));
     if (cp <= 0xFFFF) {
       buffer_.push_back(static_cast<wchar_t>(cp));
     } else {
@@ -2639,9 +2639,9 @@ FMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {
   buffer_.push_back(0);
 }
 
-FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
-                                  string_view message) FMT_NOEXCEPT {
-  FMT_TRY {
+UMPIRE_FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
+                                  string_view message) UMPIRE_FMT_NOEXCEPT {
+  UMPIRE_FMT_TRY {
     memory_buffer buf;
     buf.resize(inline_buffer_size);
     for (;;) {
@@ -2649,7 +2649,7 @@ FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
       int result =
           detail::safe_strerror(error_code, system_message, buf.size());
       if (result == 0) {
-        format_to(detail::buffer_appender<char>(out), FMT_STRING("{}: {}"),
+        format_to(detail::buffer_appender<char>(out), UMPIRE_FMT_STRING("{}: {}"),
                   message, system_message);
         return;
       }
@@ -2658,20 +2658,20 @@ FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
       buf.resize(buf.size() * 2);
     }
   }
-  FMT_CATCH(...) {}
+  UMPIRE_FMT_CATCH(...) {}
   format_error_code(out, error_code, message);
 }
 
-FMT_FUNC void detail::error_handler::on_error(const char* message) {
-  FMT_THROW(format_error(message));
+UMPIRE_FMT_FUNC void detail::error_handler::on_error(const char* message) {
+  UMPIRE_FMT_THROW(format_error(message));
 }
 
-FMT_FUNC void report_system_error(int error_code,
-                                  umpire::fmt::string_view message) FMT_NOEXCEPT {
+UMPIRE_FMT_FUNC void report_system_error(int error_code,
+                                  umpire::fmt::string_view message) UMPIRE_FMT_NOEXCEPT {
   report_error(format_system_error, error_code, message);
 }
 
-FMT_FUNC std::string detail::vformat(string_view format_str, format_args args) {
+UMPIRE_FMT_FUNC std::string detail::vformat(string_view format_str, format_args args) {
   if (format_str.size() == 2 && equal2(format_str.data(), "{}")) {
     auto arg = args.get(0);
     if (!arg) error_handler().on_error("argument not found");
@@ -2690,7 +2690,7 @@ extern "C" __declspec(dllimport) int __stdcall WriteConsoleW(  //
 }  // namespace detail
 #endif
 
-FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
+UMPIRE_FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
   memory_buffer buffer;
   detail::vformat_to(buffer, format_str,
                      basic_format_args<buffer_context<char>>(args));
@@ -2713,7 +2713,7 @@ FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
 
 #ifdef _WIN32
 // Print assuming legacy (non-Unicode) encoding.
-FMT_FUNC void detail::vprint_mojibake(std::FILE* f, string_view format_str,
+UMPIRE_FMT_FUNC void detail::vprint_mojibake(std::FILE* f, string_view format_str,
                                       format_args args) {
   memory_buffer buffer;
   detail::vformat_to(buffer, format_str,
@@ -2722,10 +2722,10 @@ FMT_FUNC void detail::vprint_mojibake(std::FILE* f, string_view format_str,
 }
 #endif
 
-FMT_FUNC void vprint(string_view format_str, format_args args) {
+UMPIRE_FMT_FUNC void vprint(string_view format_str, format_args args) {
   vprint(stdout, format_str, args);
 }
 
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_FORMAT_INL_H_
+#endif  // UMPIRE_FMT_FORMAT_INL_H_
diff --git a/src/tpl/umpire/fmt/format.h b/src/tpl/umpire/fmt/format.h
index 8cceae731..4717a682f 100644
--- a/src/tpl/umpire/fmt/format.h
+++ b/src/tpl/umpire/fmt/format.h
@@ -30,8 +30,8 @@
  without including the above copyright and permission notices.
  */
 
-#ifndef FMT_FORMAT_H_
-#define FMT_FORMAT_H_
+#ifndef UMPIRE_FMT_FORMAT_H_
+#define UMPIRE_FMT_FORMAT_H_
 
 #include <cerrno>
 #include <cmath>
@@ -46,67 +46,67 @@
 #include "core.h"
 
 #ifdef __INTEL_COMPILER
-#  define FMT_ICC_VERSION __INTEL_COMPILER
+#  define UMPIRE_FMT_ICC_VERSION __INTEL_COMPILER
 #elif defined(__ICL)
-#  define FMT_ICC_VERSION __ICL
+#  define UMPIRE_FMT_ICC_VERSION __ICL
 #else
-#  define FMT_ICC_VERSION 0
+#  define UMPIRE_FMT_ICC_VERSION 0
 #endif
 
 #ifdef __NVCC__
-#  define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)
+#  define UMPIRE_FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)
 #else
-#  define FMT_CUDA_VERSION 0
+#  define UMPIRE_FMT_CUDA_VERSION 0
 #endif
 
 #ifdef __has_builtin
-#  define FMT_HAS_BUILTIN(x) __has_builtin(x)
+#  define UMPIRE_FMT_HAS_BUILTIN(x) __has_builtin(x)
 #else
-#  define FMT_HAS_BUILTIN(x) 0
+#  define UMPIRE_FMT_HAS_BUILTIN(x) 0
 #endif
 
-#if FMT_GCC_VERSION || FMT_CLANG_VERSION
-#  define FMT_NOINLINE __attribute__((noinline))
+#if UMPIRE_FMT_GCC_VERSION || UMPIRE_FMT_CLANG_VERSION
+#  define UMPIRE_FMT_NOINLINE __attribute__((noinline))
 #else
-#  define FMT_NOINLINE
+#  define UMPIRE_FMT_NOINLINE
 #endif
 
-#if FMT_GCC_VERSION
-#  define FMT_GCC_VISIBILITY_HIDDEN __attribute__((visibility("hidden")))
+#if UMPIRE_FMT_GCC_VERSION
+#  define UMPIRE_FMT_GCC_VISIBILITY_HIDDEN __attribute__((visibility("hidden")))
 #else
-#  define FMT_GCC_VISIBILITY_HIDDEN
+#  define UMPIRE_FMT_GCC_VISIBILITY_HIDDEN
 #endif
 
 #if __cplusplus == 201103L || __cplusplus == 201402L
 #  if defined(__INTEL_COMPILER) || defined(__PGI)
-#    define FMT_FALLTHROUGH
+#    define UMPIRE_FMT_FALLTHROUGH
 #  elif defined(__clang__)
-#    define FMT_FALLTHROUGH [[clang::fallthrough]]
-#  elif FMT_GCC_VERSION >= 700 && \
+#    define UMPIRE_FMT_FALLTHROUGH [[clang::fallthrough]]
+#  elif UMPIRE_FMT_GCC_VERSION >= 700 && \
       (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= 520)
-#    define FMT_FALLTHROUGH [[gnu::fallthrough]]
+#    define UMPIRE_FMT_FALLTHROUGH [[gnu::fallthrough]]
 #  else
-#    define FMT_FALLTHROUGH
+#    define UMPIRE_FMT_FALLTHROUGH
 #  endif
-#elif FMT_HAS_CPP17_ATTRIBUTE(fallthrough) || \
+#elif UMPIRE_FMT_HAS_CPP17_ATTRIBUTE(fallthrough) || \
     (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
-#  define FMT_FALLTHROUGH [[fallthrough]]
+#  define UMPIRE_FMT_FALLTHROUGH [[fallthrough]]
 #else
-#  define FMT_FALLTHROUGH
+#  define UMPIRE_FMT_FALLTHROUGH
 #endif
 
-#ifndef FMT_MAYBE_UNUSED
-#  if FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)
-#    define FMT_MAYBE_UNUSED [[maybe_unused]]
+#ifndef UMPIRE_FMT_MAYBE_UNUSED
+#  if UMPIRE_FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)
+#    define UMPIRE_FMT_MAYBE_UNUSED [[maybe_unused]]
 #  else
-#    define FMT_MAYBE_UNUSED
+#    define UMPIRE_FMT_MAYBE_UNUSED
 #  endif
 #endif
 
-#ifndef FMT_THROW
-#  if FMT_EXCEPTIONS
-#    if FMT_MSC_VER || FMT_NVCC
-FMT_BEGIN_NAMESPACE
+#ifndef UMPIRE_FMT_THROW
+#  if UMPIRE_FMT_EXCEPTIONS
+#    if UMPIRE_FMT_MSC_VER || UMPIRE_FMT_NVCC
+UMPIRE_FMT_BEGIN_NAMESPACE
 namespace detail {
 template <typename Exception> inline void do_throw(const Exception& x) {
   // Silence unreachable code warnings in MSVC and NVCC because these
@@ -115,82 +115,82 @@ template <typename Exception> inline void do_throw(const Exception& x) {
   if (b) throw x;
 }
 }  // namespace detail
-FMT_END_NAMESPACE
-#      define FMT_THROW(x) detail::do_throw(x)
+UMPIRE_FMT_END_NAMESPACE
+#      define UMPIRE_FMT_THROW(x) detail::do_throw(x)
 #    else
-#      define FMT_THROW(x) throw x
+#      define UMPIRE_FMT_THROW(x) throw x
 #    endif
 #  else
-#    define FMT_THROW(x)               \
+#    define UMPIRE_FMT_THROW(x)               \
       do {                             \
-        FMT_ASSERT(false, (x).what()); \
+        UMPIRE_FMT_ASSERT(false, (x).what()); \
       } while (false)
 #  endif
 #endif
 
-#if FMT_EXCEPTIONS
-#  define FMT_TRY try
-#  define FMT_CATCH(x) catch (x)
+#if UMPIRE_FMT_EXCEPTIONS
+#  define UMPIRE_FMT_TRY try
+#  define UMPIRE_FMT_CATCH(x) catch (x)
 #else
-#  define FMT_TRY if (true)
-#  define FMT_CATCH(x) if (false)
+#  define UMPIRE_FMT_TRY if (true)
+#  define UMPIRE_FMT_CATCH(x) if (false)
 #endif
 
-#ifndef FMT_USE_USER_DEFINED_LITERALS
+#ifndef UMPIRE_FMT_USE_USER_DEFINED_LITERALS
 // EDG based compilers (Intel, NVIDIA, Elbrus, etc), GCC and MSVC support UDLs.
-#  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION >= 407 || \
-       FMT_MSC_VER >= 1900) &&                                         \
+#  if (UMPIRE_FMT_HAS_FEATURE(cxx_user_literals) || UMPIRE_FMT_GCC_VERSION >= 407 || \
+       UMPIRE_FMT_MSC_VER >= 1900) &&                                         \
       (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= /* UDL feature */ 480)
-#    define FMT_USE_USER_DEFINED_LITERALS 1
+#    define UMPIRE_FMT_USE_USER_DEFINED_LITERALS 1
 #  else
-#    define FMT_USE_USER_DEFINED_LITERALS 0
+#    define UMPIRE_FMT_USE_USER_DEFINED_LITERALS 0
 #  endif
 #endif
 
-#ifndef FMT_USE_FLOAT
-#  define FMT_USE_FLOAT 1
+#ifndef UMPIRE_FMT_USE_FLOAT
+#  define UMPIRE_FMT_USE_FLOAT 1
 #endif
 
-#ifndef FMT_USE_DOUBLE
-#  define FMT_USE_DOUBLE 1
+#ifndef UMPIRE_FMT_USE_DOUBLE
+#  define UMPIRE_FMT_USE_DOUBLE 1
 #endif
 
-#ifndef FMT_USE_LONG_DOUBLE
-#  define FMT_USE_LONG_DOUBLE 1
+#ifndef UMPIRE_FMT_USE_LONG_DOUBLE
+#  define UMPIRE_FMT_USE_LONG_DOUBLE 1
 #endif
 
-// Defining FMT_REDUCE_INT_INSTANTIATIONS to 1, will reduce the number of
+// Defining UMPIRE_FMT_REDUCE_INT_INSTANTIATIONS to 1, will reduce the number of
 // integer formatter template instantiations to just one by only using the
 // largest integer type. This results in a reduction in binary size but will
 // cause a decrease in integer formatting performance.
-#if !defined(FMT_REDUCE_INT_INSTANTIATIONS)
-#  define FMT_REDUCE_INT_INSTANTIATIONS 0
+#if !defined(UMPIRE_FMT_REDUCE_INT_INSTANTIATIONS)
+#  define UMPIRE_FMT_REDUCE_INT_INSTANTIATIONS 0
 #endif
 
 // __builtin_clz is broken in clang with Microsoft CodeGen:
 // https://github.com/fmtlib/fmt/issues/519
-#if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_clz)) && !FMT_MSC_VER
-#  define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
+#if (UMPIRE_FMT_GCC_VERSION || UMPIRE_FMT_HAS_BUILTIN(__builtin_clz)) && !UMPIRE_FMT_MSC_VER
+#  define UMPIRE_FMT_BUILTIN_CLZ(n) __builtin_clz(n)
 #endif
-#if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_clzll)) && !FMT_MSC_VER
-#  define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
+#if (UMPIRE_FMT_GCC_VERSION || UMPIRE_FMT_HAS_BUILTIN(__builtin_clzll)) && !UMPIRE_FMT_MSC_VER
+#  define UMPIRE_FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
 #endif
-#if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_ctz))
-#  define FMT_BUILTIN_CTZ(n) __builtin_ctz(n)
+#if (UMPIRE_FMT_GCC_VERSION || UMPIRE_FMT_HAS_BUILTIN(__builtin_ctz))
+#  define UMPIRE_FMT_BUILTIN_CTZ(n) __builtin_ctz(n)
 #endif
-#if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_ctzll))
-#  define FMT_BUILTIN_CTZLL(n) __builtin_ctzll(n)
+#if (UMPIRE_FMT_GCC_VERSION || UMPIRE_FMT_HAS_BUILTIN(__builtin_ctzll))
+#  define UMPIRE_FMT_BUILTIN_CTZLL(n) __builtin_ctzll(n)
 #endif
 
-#if FMT_MSC_VER
+#if UMPIRE_FMT_MSC_VER
 #  include <intrin.h>  // _BitScanReverse[64], _BitScanForward[64], _umul128
 #endif
 
 // Some compilers masquerade as both MSVC and GCC-likes or otherwise support
-// __builtin_clz and __builtin_clzll, so only define FMT_BUILTIN_CLZ using the
+// __builtin_clz and __builtin_clzll, so only define UMPIRE_FMT_BUILTIN_CLZ using the
 // MSVC intrinsics if the clz and clzll builtins are not available.
-#if FMT_MSC_VER && !defined(FMT_BUILTIN_CLZLL) && !defined(FMT_BUILTIN_CTZLL)
-FMT_BEGIN_NAMESPACE
+#if UMPIRE_FMT_MSC_VER && !defined(UMPIRE_FMT_BUILTIN_CLZLL) && !defined(UMPIRE_FMT_BUILTIN_CTZLL)
+UMPIRE_FMT_BEGIN_NAMESPACE
 namespace detail {
 // Avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning.
 #  if !defined(__clang__)
@@ -206,14 +206,14 @@ namespace detail {
 inline int clz(uint32_t x) {
   unsigned long r = 0;
   _BitScanReverse(&r, x);
-  FMT_ASSERT(x != 0, "");
+  UMPIRE_FMT_ASSERT(x != 0, "");
   // Static analysis complains about using uninitialized data
   // "r", but the only way that can happen is if "x" is 0,
   // which the callers guarantee to not happen.
-  FMT_MSC_WARNING(suppress : 6102)
+  UMPIRE_FMT_MSC_WARNING(suppress : 6102)
   return 31 ^ static_cast<int>(r);
 }
-#  define FMT_BUILTIN_CLZ(n) detail::clz(n)
+#  define UMPIRE_FMT_BUILTIN_CLZ(n) detail::clz(n)
 
 inline int clzll(uint64_t x) {
   unsigned long r = 0;
@@ -225,25 +225,25 @@ inline int clzll(uint64_t x) {
   // Scan the low 32 bits.
   _BitScanReverse(&r, static_cast<uint32_t>(x));
 #  endif
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
+  UMPIRE_FMT_ASSERT(x != 0, "");
+  UMPIRE_FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
   return 63 ^ static_cast<int>(r);
 }
-#  define FMT_BUILTIN_CLZLL(n) detail::clzll(n)
+#  define UMPIRE_FMT_BUILTIN_CLZLL(n) detail::clzll(n)
 
 inline int ctz(uint32_t x) {
   unsigned long r = 0;
   _BitScanForward(&r, x);
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
+  UMPIRE_FMT_ASSERT(x != 0, "");
+  UMPIRE_FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
   return static_cast<int>(r);
 }
-#  define FMT_BUILTIN_CTZ(n) detail::ctz(n)
+#  define UMPIRE_FMT_BUILTIN_CTZ(n) detail::ctz(n)
 
 inline int ctzll(uint64_t x) {
   unsigned long r = 0;
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
+  UMPIRE_FMT_ASSERT(x != 0, "");
+  UMPIRE_FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
 #  ifdef _WIN64
   _BitScanForward64(&r, x);
 #  else
@@ -255,27 +255,27 @@ inline int ctzll(uint64_t x) {
 #  endif
   return static_cast<int>(r);
 }
-#  define FMT_BUILTIN_CTZLL(n) detail::ctzll(n)
+#  define UMPIRE_FMT_BUILTIN_CTZLL(n) detail::ctzll(n)
 #  if !defined(__clang__)
 #    pragma managed(pop)
 #  endif
 }  // namespace detail
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 #endif
 
 // Enable the deprecated numeric alignment.
-#ifndef FMT_DEPRECATED_NUMERIC_ALIGN
-#  define FMT_DEPRECATED_NUMERIC_ALIGN 0
+#ifndef UMPIRE_FMT_DEPRECATED_NUMERIC_ALIGN
+#  define UMPIRE_FMT_DEPRECATED_NUMERIC_ALIGN 0
 #endif
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 namespace detail {
 
 #if __cplusplus >= 202002L || \
-    (__cplusplus >= 201709L && FMT_GCC_VERSION >= 1002)
-#  define FMT_CONSTEXPR20 constexpr
+    (__cplusplus >= 201709L && UMPIRE_FMT_GCC_VERSION >= 1002)
+#  define UMPIRE_FMT_CONSTEXPR20 constexpr
 #else
-#  define FMT_CONSTEXPR20
+#  define UMPIRE_FMT_CONSTEXPR20
 #endif
 
 // An equivalent of `*reinterpret_cast<Dest*>(&source)` that doesn't have
@@ -336,9 +336,9 @@ template <> constexpr int num_bits<fallback_uintptr>() {
                           std::numeric_limits<unsigned char>::digits);
 }
 
-FMT_INLINE void assume(bool condition) {
+UMPIRE_FMT_INLINE void assume(bool condition) {
   (void)condition;
-#if FMT_HAS_BUILTIN(__builtin_assume)
+#if UMPIRE_FMT_HAS_BUILTIN(__builtin_assume)
   __builtin_assume(condition);
 #endif
 }
@@ -368,8 +368,8 @@ template <typename T> using checked_ptr = T*;
 template <typename T> inline T* make_checked(T* p, size_t) { return p; }
 #endif
 
-template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
-#if FMT_CLANG_VERSION >= 307
+template <typename Container, UMPIRE_FMT_ENABLE_IF(is_contiguous<Container>::value)>
+#if UMPIRE_FMT_CLANG_VERSION >= 307
 __attribute__((no_sanitize("undefined")))
 #endif
 inline checked_ptr<typename Container::value_type>
@@ -407,7 +407,7 @@ template <typename T> T* to_pointer(buffer_appender<T> it, size_t n) {
   return buf.data() + size;
 }
 
-template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
+template <typename Container, UMPIRE_FMT_ENABLE_IF(is_contiguous<Container>::value)>
 inline std::back_insert_iterator<Container> base_iterator(
     std::back_insert_iterator<Container>& it,
     checked_ptr<typename Container::value_type>) {
@@ -461,12 +461,12 @@ class counting_iterator {
 // <algorithm> is spectacularly slow to compile in C++20 so use a simple fill_n
 // instead (#1998).
 template <typename OutputIt, typename Size, typename T>
-FMT_CONSTEXPR OutputIt fill_n(OutputIt out, Size count, const T& value) {
+UMPIRE_FMT_CONSTEXPR OutputIt fill_n(OutputIt out, Size count, const T& value) {
   for (Size i = 0; i < count; ++i) *out++ = value;
   return out;
 }
 template <typename T, typename Size>
-FMT_CONSTEXPR20 T* fill_n(T* out, Size count, char value) {
+UMPIRE_FMT_CONSTEXPR20 T* fill_n(T* out, Size count, char value) {
   if (is_constant_evaluated()) {
     return fill_n<T*, Size, T>(out, count, value);
   }
@@ -481,15 +481,15 @@ using needs_conversion = bool_constant<
     std::is_same<OutChar, char8_type>::value>;
 
 template <typename OutChar, typename InputIt, typename OutputIt,
-          FMT_ENABLE_IF(!needs_conversion<InputIt, OutChar>::value)>
-FMT_CONSTEXPR OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
+          UMPIRE_FMT_ENABLE_IF(!needs_conversion<InputIt, OutChar>::value)>
+UMPIRE_FMT_CONSTEXPR OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
   while (begin != end) *it++ = *begin++;
   return it;
 }
 
 template <typename OutChar, typename InputIt,
-          FMT_ENABLE_IF(!needs_conversion<InputIt, OutChar>::value)>
-FMT_CONSTEXPR20 OutChar* copy_str(InputIt begin, InputIt end, OutChar* out) {
+          UMPIRE_FMT_ENABLE_IF(!needs_conversion<InputIt, OutChar>::value)>
+UMPIRE_FMT_CONSTEXPR20 OutChar* copy_str(InputIt begin, InputIt end, OutChar* out) {
   if (is_constant_evaluated()) {
     return copy_str<OutChar, InputIt, OutChar*>(begin, end, out);
   }
@@ -497,14 +497,14 @@ FMT_CONSTEXPR20 OutChar* copy_str(InputIt begin, InputIt end, OutChar* out) {
 }
 
 template <typename OutChar, typename InputIt, typename OutputIt,
-          FMT_ENABLE_IF(needs_conversion<InputIt, OutChar>::value)>
+          UMPIRE_FMT_ENABLE_IF(needs_conversion<InputIt, OutChar>::value)>
 OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
   while (begin != end) *it++ = static_cast<char8_type>(*begin++);
   return it;
 }
 
 template <typename OutChar, typename InputIt,
-          FMT_ENABLE_IF(!needs_conversion<InputIt, OutChar>::value)>
+          UMPIRE_FMT_ENABLE_IF(!needs_conversion<InputIt, OutChar>::value)>
 buffer_appender<OutChar> copy_str(InputIt begin, InputIt end,
                                   buffer_appender<OutChar> out) {
   get_container(out).append(begin, end);
@@ -518,7 +518,7 @@ inline counting_iterator copy_str(InputIt begin, InputIt end,
 }
 
 template <typename Char>
-FMT_CONSTEXPR int code_point_length(const Char* begin) {
+UMPIRE_FMT_CONSTEXPR int code_point_length(const Char* begin) {
   if (const_check(sizeof(Char) != 1)) return 1;
   constexpr char lengths[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                               0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0};
@@ -547,7 +547,7 @@ FMT_CONSTEXPR int code_point_length(const Char* begin) {
  * occurs, this pointer will be a guess that depends on the particular
  * error, but it will always advance at least one byte.
  */
-FMT_CONSTEXPR inline const char* utf8_decode(const char* s, uint32_t* c,
+UMPIRE_FMT_CONSTEXPR inline const char* utf8_decode(const char* s, uint32_t* c,
                                              int* e) {
   constexpr const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};
   constexpr const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};
@@ -580,7 +580,7 @@ FMT_CONSTEXPR inline const char* utf8_decode(const char* s, uint32_t* c,
 }
 
 template <typename F>
-FMT_CONSTEXPR void for_each_codepoint(string_view s, F f) {
+UMPIRE_FMT_CONSTEXPR void for_each_codepoint(string_view s, F f) {
   auto decode = [f](const char* p) {
     auto cp = uint32_t();
     auto error = 0;
@@ -609,12 +609,12 @@ inline size_t compute_width(basic_string_view<Char> s) {
 }
 
 // Computes approximate display width of a UTF-8 string.
-FMT_CONSTEXPR inline size_t compute_width(string_view s) {
+UMPIRE_FMT_CONSTEXPR inline size_t compute_width(string_view s) {
   size_t num_code_points = 0;
   // It is not a lambda for compatibility with C++14.
   struct count_code_points {
     size_t* count;
-    FMT_CONSTEXPR void operator()(uint32_t cp, int error) const {
+    UMPIRE_FMT_CONSTEXPR void operator()(uint32_t cp, int error) const {
       *count +=
           1 +
           (error == 0 && cp >= 0x1100 &&
@@ -666,8 +666,8 @@ template <typename T>
 using is_fast_float = bool_constant<std::numeric_limits<T>::is_iec559 &&
                                     sizeof(T) <= sizeof(double)>;
 
-#ifndef FMT_USE_FULL_CACHE_DRAGONBOX
-#  define FMT_USE_FULL_CACHE_DRAGONBOX 0
+#ifndef UMPIRE_FMT_USE_FULL_CACHE_DRAGONBOX
+#  define UMPIRE_FMT_USE_FULL_CACHE_DRAGONBOX 0
 #endif
 
 template <typename T>
@@ -741,7 +741,7 @@ class basic_memory_buffer final : public detail::buffer<T> {
   }
 
  protected:
-  void grow(size_t size) final FMT_OVERRIDE;
+  void grow(size_t size) final UMPIRE_FMT_OVERRIDE;
 
  public:
   using value_type = T;
@@ -779,15 +779,15 @@ class basic_memory_buffer final : public detail::buffer<T> {
     of the other object to it.
     \endrst
    */
-  basic_memory_buffer(basic_memory_buffer&& other) FMT_NOEXCEPT { move(other); }
+  basic_memory_buffer(basic_memory_buffer&& other) UMPIRE_FMT_NOEXCEPT { move(other); }
 
   /**
     \rst
     Moves the content of the other ``basic_memory_buffer`` object to this one.
     \endrst
    */
-  basic_memory_buffer& operator=(basic_memory_buffer&& other) FMT_NOEXCEPT {
-    FMT_ASSERT(this != &other, "");
+  basic_memory_buffer& operator=(basic_memory_buffer&& other) UMPIRE_FMT_NOEXCEPT {
+    UMPIRE_FMT_ASSERT(this != &other, "");
     deallocate();
     move(other);
     return *this;
@@ -815,7 +815,7 @@ class basic_memory_buffer final : public detail::buffer<T> {
 
 template <typename T, size_t SIZE, typename Allocator>
 void basic_memory_buffer<T, SIZE, Allocator>::grow(size_t size) {
-#ifdef FMT_FUZZ
+#ifdef UMPIRE_FMT_FUZZ
   if (size > 5000) throw std::runtime_error("fuzz mode - won't grow that much");
 #endif
   const size_t max_size = std::allocator_traits<Allocator>::max_size(alloc_);
@@ -846,8 +846,8 @@ struct is_contiguous<basic_memory_buffer<T, SIZE, Allocator>> : std::true_type {
 };
 
 /** A formatting error such as invalid format string. */
-FMT_CLASS_API
-class FMT_API format_error : public std::runtime_error {
+UMPIRE_FMT_CLASS_API
+class UMPIRE_FMT_API format_error : public std::runtime_error {
  public:
   explicit format_error(const char* message) : std::runtime_error(message) {}
   explicit format_error(const std::string& message)
@@ -856,7 +856,7 @@ class FMT_API format_error : public std::runtime_error {
   format_error& operator=(const format_error&) = default;
   format_error(format_error&&) = default;
   format_error& operator=(format_error&&) = default;
-  ~format_error() FMT_NOEXCEPT FMT_OVERRIDE;
+  ~format_error() UMPIRE_FMT_NOEXCEPT UMPIRE_FMT_OVERRIDE;
 };
 
 namespace detail {
@@ -868,49 +868,49 @@ using is_signed =
 
 // Returns true if value is negative, false otherwise.
 // Same as `value < 0` but doesn't produce warnings if T is an unsigned type.
-template <typename T, FMT_ENABLE_IF(is_signed<T>::value)>
-FMT_CONSTEXPR bool is_negative(T value) {
+template <typename T, UMPIRE_FMT_ENABLE_IF(is_signed<T>::value)>
+UMPIRE_FMT_CONSTEXPR bool is_negative(T value) {
   return value < 0;
 }
-template <typename T, FMT_ENABLE_IF(!is_signed<T>::value)>
-FMT_CONSTEXPR bool is_negative(T) {
+template <typename T, UMPIRE_FMT_ENABLE_IF(!is_signed<T>::value)>
+UMPIRE_FMT_CONSTEXPR bool is_negative(T) {
   return false;
 }
 
-template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
-FMT_CONSTEXPR bool is_supported_floating_point(T) {
-  return (std::is_same<T, float>::value && FMT_USE_FLOAT) ||
-         (std::is_same<T, double>::value && FMT_USE_DOUBLE) ||
-         (std::is_same<T, long double>::value && FMT_USE_LONG_DOUBLE);
+template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_floating_point<T>::value)>
+UMPIRE_FMT_CONSTEXPR bool is_supported_floating_point(T) {
+  return (std::is_same<T, float>::value && UMPIRE_FMT_USE_FLOAT) ||
+         (std::is_same<T, double>::value && UMPIRE_FMT_USE_DOUBLE) ||
+         (std::is_same<T, long double>::value && UMPIRE_FMT_USE_LONG_DOUBLE);
 }
 
 // Smallest of uint32_t, uint64_t, uint128_t that is large enough to
 // represent all values of an integral type T.
 template <typename T>
 using uint32_or_64_or_128_t =
-    conditional_t<num_bits<T>() <= 32 && !FMT_REDUCE_INT_INSTANTIATIONS,
+    conditional_t<num_bits<T>() <= 32 && !UMPIRE_FMT_REDUCE_INT_INSTANTIATIONS,
                   uint32_t,
                   conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>>;
 template <typename T>
 using uint64_or_128_t = conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>;
 
 // 128-bit integer type used internally
-struct FMT_EXTERN_TEMPLATE_API uint128_wrapper {
+struct UMPIRE_FMT_EXTERN_TEMPLATE_API uint128_wrapper {
   uint128_wrapper() = default;
 
-#if FMT_USE_INT128
+#if UMPIRE_FMT_USE_INT128
   uint128_t internal_;
 
-  uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT
+  uint128_wrapper(uint64_t high, uint64_t low) UMPIRE_FMT_NOEXCEPT
       : internal_{static_cast<uint128_t>(low) |
                   (static_cast<uint128_t>(high) << 64)} {}
 
   uint128_wrapper(uint128_t u) : internal_{u} {}
 
-  uint64_t high() const FMT_NOEXCEPT { return uint64_t(internal_ >> 64); }
-  uint64_t low() const FMT_NOEXCEPT { return uint64_t(internal_); }
+  uint64_t high() const UMPIRE_FMT_NOEXCEPT { return uint64_t(internal_ >> 64); }
+  uint64_t low() const UMPIRE_FMT_NOEXCEPT { return uint64_t(internal_); }
 
-  uint128_wrapper& operator+=(uint64_t n) FMT_NOEXCEPT {
+  uint128_wrapper& operator+=(uint64_t n) UMPIRE_FMT_NOEXCEPT {
     internal_ += n;
     return *this;
   }
@@ -918,13 +918,13 @@ struct FMT_EXTERN_TEMPLATE_API uint128_wrapper {
   uint64_t high_;
   uint64_t low_;
 
-  uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT : high_{high},
+  uint128_wrapper(uint64_t high, uint64_t low) UMPIRE_FMT_NOEXCEPT : high_{high},
                                                               low_{low} {}
 
-  uint64_t high() const FMT_NOEXCEPT { return high_; }
-  uint64_t low() const FMT_NOEXCEPT { return low_; }
+  uint64_t high() const UMPIRE_FMT_NOEXCEPT { return high_; }
+  uint64_t low() const UMPIRE_FMT_NOEXCEPT { return low_; }
 
-  uint128_wrapper& operator+=(uint64_t n) FMT_NOEXCEPT {
+  uint128_wrapper& operator+=(uint64_t n) UMPIRE_FMT_NOEXCEPT {
 #  if defined(_MSC_VER) && defined(_M_X64)
     unsigned char carry = _addcarry_u64(0, low_, n, &low_);
     _addcarry_u64(carry, high_, 0, &high_);
@@ -940,13 +940,13 @@ struct FMT_EXTERN_TEMPLATE_API uint128_wrapper {
 };
 
 // Table entry type for divisibility test used internally
-template <typename T> struct FMT_EXTERN_TEMPLATE_API divtest_table_entry {
+template <typename T> struct UMPIRE_FMT_EXTERN_TEMPLATE_API divtest_table_entry {
   T mod_inv;
   T max_quotient;
 };
 
 // Static data is placed in this class template for the header-only config.
-template <typename T = void> struct FMT_EXTERN_TEMPLATE_API basic_data {
+template <typename T = void> struct UMPIRE_FMT_EXTERN_TEMPLATE_API basic_data {
   static const uint64_t powers_of_10_64[];
   static const uint32_t zero_or_powers_of_10_32_new[];
   static const uint64_t zero_or_powers_of_10_64_new[];
@@ -958,7 +958,7 @@ template <typename T = void> struct FMT_EXTERN_TEMPLATE_API basic_data {
   static const uint128_wrapper dragonbox_pow10_significands_128[];
   // log10(2) = 0x0.4d104d427de7fbcc...
   static const uint64_t log10_2_significand = 0x4d104d427de7fbcc;
-#if !FMT_USE_FULL_CACHE_DRAGONBOX
+#if !UMPIRE_FMT_USE_FULL_CACHE_DRAGONBOX
   static const uint64_t powers_of_5_64[];
   static const uint32_t dragonbox_pow10_recovery_errors[];
 #endif
@@ -983,7 +983,7 @@ template <typename T = void> struct FMT_EXTERN_TEMPLATE_API basic_data {
 
 // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).
 // This is a function instead of an array to workaround a bug in GCC10 (#1810).
-FMT_INLINE uint16_t bsr2log10(int bsr) {
+UMPIRE_FMT_INLINE uint16_t bsr2log10(int bsr) {
   static constexpr uint16_t data[] = {
       1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
       6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
@@ -992,14 +992,14 @@ FMT_INLINE uint16_t bsr2log10(int bsr) {
   return data[bsr];
 }
 
-#ifndef FMT_EXPORTED
-FMT_EXTERN template struct basic_data<void>;
+#ifndef UMPIRE_FMT_EXPORTED
+UMPIRE_FMT_EXTERN template struct basic_data<void>;
 #endif
 
 // This is a struct rather than an alias to avoid shadowing warnings in gcc.
 struct data : basic_data<> {};
 
-template <typename T> FMT_CONSTEXPR int count_digits_fallback(T n) {
+template <typename T> UMPIRE_FMT_CONSTEXPR int count_digits_fallback(T n) {
   int count = 1;
   for (;;) {
     // Integer division is slow so do it for a group of four digits instead
@@ -1013,21 +1013,21 @@ template <typename T> FMT_CONSTEXPR int count_digits_fallback(T n) {
     count += 4;
   }
 }
-#if FMT_USE_INT128
-FMT_CONSTEXPR inline int count_digits(uint128_t n) {
+#if UMPIRE_FMT_USE_INT128
+UMPIRE_FMT_CONSTEXPR inline int count_digits(uint128_t n) {
   return count_digits_fallback(n);
 }
 #endif
 
 // Returns the number of decimal digits in n. Leading zeros are not counted
 // except for n == 0 in which case count_digits returns 1.
-FMT_CONSTEXPR20 inline int count_digits(uint64_t n) {
+UMPIRE_FMT_CONSTEXPR20 inline int count_digits(uint64_t n) {
   if (is_constant_evaluated()) {
     return count_digits_fallback(n);
   }
-#ifdef FMT_BUILTIN_CLZLL
+#ifdef UMPIRE_FMT_BUILTIN_CLZLL
   // https://github.com/fmtlib/format-benchmark/blob/master/digits10
-  auto t = bsr2log10(FMT_BUILTIN_CLZLL(n | 1) ^ 63);
+  auto t = bsr2log10(UMPIRE_FMT_BUILTIN_CLZLL(n | 1) ^ 63);
   return t - (n < data::zero_or_powers_of_10_64_new[t]);
 #else
   return count_digits_fallback(n);
@@ -1035,10 +1035,10 @@ FMT_CONSTEXPR20 inline int count_digits(uint64_t n) {
 }
 
 // Counts the number of digits in n. BITS = log2(radix).
-template <int BITS, typename UInt> FMT_CONSTEXPR int count_digits(UInt n) {
-#ifdef FMT_BUILTIN_CLZ
+template <int BITS, typename UInt> UMPIRE_FMT_CONSTEXPR int count_digits(UInt n) {
+#ifdef UMPIRE_FMT_BUILTIN_CLZ
   if (num_bits<UInt>() == 32)
-    return (FMT_BUILTIN_CLZ(static_cast<uint32_t>(n) | 1) ^ 31) / BITS + 1;
+    return (UMPIRE_FMT_BUILTIN_CLZ(static_cast<uint32_t>(n) | 1) ^ 31) / BITS + 1;
 #endif
   int num_digits = 0;
   do {
@@ -1049,33 +1049,33 @@ template <int BITS, typename UInt> FMT_CONSTEXPR int count_digits(UInt n) {
 
 template <> int count_digits<4>(detail::fallback_uintptr n);
 
-#if FMT_GCC_VERSION || FMT_CLANG_VERSION
-#  define FMT_ALWAYS_INLINE inline __attribute__((always_inline))
-#elif FMT_MSC_VER
-#  define FMT_ALWAYS_INLINE __forceinline
+#if UMPIRE_FMT_GCC_VERSION || UMPIRE_FMT_CLANG_VERSION
+#  define UMPIRE_FMT_ALWAYS_INLINE inline __attribute__((always_inline))
+#elif UMPIRE_FMT_MSC_VER
+#  define UMPIRE_FMT_ALWAYS_INLINE __forceinline
 #else
-#  define FMT_ALWAYS_INLINE inline
+#  define UMPIRE_FMT_ALWAYS_INLINE inline
 #endif
 
-#ifdef FMT_BUILTIN_CLZ
+#ifdef UMPIRE_FMT_BUILTIN_CLZ
 // Optional version of count_digits for better performance on 32-bit platforms.
-FMT_CONSTEXPR20 inline int count_digits(uint32_t n) {
+UMPIRE_FMT_CONSTEXPR20 inline int count_digits(uint32_t n) {
   if (is_constant_evaluated()) {
     return count_digits_fallback(n);
   }
-  auto t = bsr2log10(FMT_BUILTIN_CLZ(n | 1) ^ 31);
+  auto t = bsr2log10(UMPIRE_FMT_BUILTIN_CLZ(n | 1) ^ 31);
   return t - (n < data::zero_or_powers_of_10_32_new[t]);
 }
 #endif
 
-template <typename Int> constexpr int digits10() FMT_NOEXCEPT {
+template <typename Int> constexpr int digits10() UMPIRE_FMT_NOEXCEPT {
   return std::numeric_limits<Int>::digits10;
 }
-template <> constexpr int digits10<int128_t>() FMT_NOEXCEPT { return 38; }
-template <> constexpr int digits10<uint128_t>() FMT_NOEXCEPT { return 38; }
+template <> constexpr int digits10<int128_t>() UMPIRE_FMT_NOEXCEPT { return 38; }
+template <> constexpr int digits10<uint128_t>() UMPIRE_FMT_NOEXCEPT { return 38; }
 
 // DEPRECATED! grouping will be merged into thousands_sep.
-template <typename Char> FMT_API std::string grouping_impl(locale_ref loc);
+template <typename Char> UMPIRE_FMT_API std::string grouping_impl(locale_ref loc);
 template <typename Char> inline std::string grouping(locale_ref loc) {
   return grouping_impl<char>(loc);
 }
@@ -1083,7 +1083,7 @@ template <> inline std::string grouping<wchar_t>(locale_ref loc) {
   return grouping_impl<wchar_t>(loc);
 }
 
-template <typename Char> FMT_API Char thousands_sep_impl(locale_ref loc);
+template <typename Char> UMPIRE_FMT_API Char thousands_sep_impl(locale_ref loc);
 template <typename Char> inline Char thousands_sep(locale_ref loc) {
   return Char(thousands_sep_impl<char>(loc));
 }
@@ -1091,7 +1091,7 @@ template <> inline wchar_t thousands_sep(locale_ref loc) {
   return thousands_sep_impl<wchar_t>(loc);
 }
 
-template <typename Char> FMT_API Char decimal_point_impl(locale_ref loc);
+template <typename Char> UMPIRE_FMT_API Char decimal_point_impl(locale_ref loc);
 template <typename Char> inline Char decimal_point(locale_ref loc) {
   return Char(decimal_point_impl<char>(loc));
 }
@@ -1112,7 +1112,7 @@ template <typename Char> void copy2(Char* dst, const char* src) {
   *dst++ = static_cast<Char>(*src++);
   *dst = static_cast<Char>(*src);
 }
-FMT_INLINE void copy2(char* dst, const char* src) { memcpy(dst, src, 2); }
+UMPIRE_FMT_INLINE void copy2(char* dst, const char* src) { memcpy(dst, src, 2); }
 
 template <typename Iterator> struct format_decimal_result {
   Iterator begin;
@@ -1123,10 +1123,10 @@ template <typename Iterator> struct format_decimal_result {
 // buffer of specified size. The caller must ensure that the buffer is large
 // enough.
 template <typename Char, typename UInt>
-FMT_CONSTEXPR20 format_decimal_result<Char*> format_decimal(Char* out,
+UMPIRE_FMT_CONSTEXPR20 format_decimal_result<Char*> format_decimal(Char* out,
                                                             UInt value,
                                                             int size) {
-  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
+  UMPIRE_FMT_ASSERT(size >= count_digits(value), "invalid digit count");
   out += size;
   Char* end = out;
   if (is_constant_evaluated()) {
@@ -1155,7 +1155,7 @@ FMT_CONSTEXPR20 format_decimal_result<Char*> format_decimal(Char* out,
 }
 
 template <typename Char, typename UInt, typename Iterator,
-          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>
+          UMPIRE_FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>
 inline format_decimal_result<Iterator> format_decimal(Iterator out, UInt value,
                                                       int size) {
   // Buffer is large enough to hold all digits (digits10 + 1).
@@ -1165,7 +1165,7 @@ inline format_decimal_result<Iterator> format_decimal(Iterator out, UInt value,
 }
 
 template <unsigned BASE_BITS, typename Char, typename UInt>
-FMT_CONSTEXPR Char* format_uint(Char* buffer, UInt value, int num_digits,
+UMPIRE_FMT_CONSTEXPR Char* format_uint(Char* buffer, UInt value, int num_digits,
                                 bool upper = false) {
   buffer += num_digits;
   Char* end = buffer;
@@ -1218,7 +1218,7 @@ class utf8_to_utf16 {
   wmemory_buffer buffer_;
 
  public:
-  FMT_API explicit utf8_to_utf16(string_view s);
+  UMPIRE_FMT_API explicit utf8_to_utf16(string_view s);
   operator wstring_view() const { return {&buffer_[0], size()}; }
   size_t size() const { return buffer_.size() - 1; }
   const wchar_t* c_str() const { return &buffer_[0]; }
@@ -1235,10 +1235,10 @@ template <typename Char> struct fill_t {
   unsigned char size_ = 1;
 
  public:
-  FMT_CONSTEXPR void operator=(basic_string_view<Char> s) {
+  UMPIRE_FMT_CONSTEXPR void operator=(basic_string_view<Char> s) {
     auto size = s.size();
     if (size > max_size) {
-      FMT_THROW(format_error("invalid fill"));
+      UMPIRE_FMT_THROW(format_error("invalid fill"));
       return;
     }
     for (size_t i = 0; i < size; ++i) data_[i] = s[i];
@@ -1248,8 +1248,8 @@ template <typename Char> struct fill_t {
   constexpr size_t size() const { return size_; }
   constexpr const Char* data() const { return data_; }
 
-  FMT_CONSTEXPR Char& operator[](size_t index) { return data_[index]; }
-  FMT_CONSTEXPR const Char& operator[](size_t index) const {
+  UMPIRE_FMT_CONSTEXPR Char& operator[](size_t index) { return data_[index]; }
+  UMPIRE_FMT_CONSTEXPR const Char& operator[](size_t index) const {
     return data_[index];
   }
 };
@@ -1354,7 +1354,7 @@ template <typename T> struct decimal_fp {
   int exponent;
 };
 
-template <typename T> FMT_API decimal_fp<T> to_decimal(T x) FMT_NOEXCEPT;
+template <typename T> UMPIRE_FMT_API decimal_fp<T> to_decimal(T x) UMPIRE_FMT_NOEXCEPT;
 }  // namespace dragonbox
 
 template <typename T>
@@ -1385,7 +1385,7 @@ struct float_specs {
 
 // Writes the exponent exp in the form "[+-]d{2,3}" to buffer.
 template <typename Char, typename It> It write_exponent(int exp, It it) {
-  FMT_ASSERT(-10000 < exp && exp < 10000, "exponent out of range");
+  UMPIRE_FMT_ASSERT(-10000 < exp && exp < 10000, "exponent out of range");
   if (exp < 0) {
     *it++ = static_cast<Char>('-');
     exp = -exp;
@@ -1416,7 +1416,7 @@ template <typename T> T promote_float(T value) { return value; }
 inline double promote_float(float value) { return static_cast<double>(value); }
 
 template <typename ErrorHandler = error_handler, typename Char>
-FMT_CONSTEXPR float_specs parse_float_type_spec(
+UMPIRE_FMT_CONSTEXPR float_specs parse_float_type_spec(
     const basic_format_specs<Char>& specs, ErrorHandler&& eh = {}) {
   auto result = float_specs();
   result.showpoint = specs.alt;
@@ -1427,31 +1427,31 @@ FMT_CONSTEXPR float_specs parse_float_type_spec(
     break;
   case 'G':
     result.upper = true;
-    FMT_FALLTHROUGH;
+    UMPIRE_FMT_FALLTHROUGH;
   case 'g':
     result.format = float_format::general;
     break;
   case 'E':
     result.upper = true;
-    FMT_FALLTHROUGH;
+    UMPIRE_FMT_FALLTHROUGH;
   case 'e':
     result.format = float_format::exp;
     result.showpoint |= specs.precision != 0;
     break;
   case 'F':
     result.upper = true;
-    FMT_FALLTHROUGH;
+    UMPIRE_FMT_FALLTHROUGH;
   case 'f':
     result.format = float_format::fixed;
     result.showpoint |= specs.precision != 0;
     break;
   case 'A':
     result.upper = true;
-    FMT_FALLTHROUGH;
+    UMPIRE_FMT_FALLTHROUGH;
   case 'a':
     result.format = float_format::hex;
     break;
-#ifdef FMT_DEPRECATED_N_SPECIFIER
+#ifdef UMPIRE_FMT_DEPRECATED_N_SPECIFIER
   case 'n':
     result.locale = true;
     break;
@@ -1464,7 +1464,7 @@ FMT_CONSTEXPR float_specs parse_float_type_spec(
 }
 
 template <typename ErrorHandler>
-FMT_CONSTEXPR void check_int_type_spec(char spec, ErrorHandler&& eh) {
+UMPIRE_FMT_CONSTEXPR void check_int_type_spec(char spec, ErrorHandler&& eh) {
   switch (spec) {
   case 0:
   case 'd':
@@ -1473,7 +1473,7 @@ FMT_CONSTEXPR void check_int_type_spec(char spec, ErrorHandler&& eh) {
   case 'b':
   case 'B':
   case 'o':
-#ifdef FMT_DEPRECATED_N_SPECIFIER
+#ifdef UMPIRE_FMT_DEPRECATED_N_SPECIFIER
   case 'n':
 #endif
   case 'c':
@@ -1485,7 +1485,7 @@ FMT_CONSTEXPR void check_int_type_spec(char spec, ErrorHandler&& eh) {
 }
 
 template <typename Char, typename Handler>
-FMT_CONSTEXPR void handle_char_specs(const basic_format_specs<Char>& specs,
+UMPIRE_FMT_CONSTEXPR void handle_char_specs(const basic_format_specs<Char>& specs,
                                      Handler&& handler) {
   if (specs.type && specs.type != 'c') return handler.on_int();
   if (specs.align == align::numeric || specs.sign != sign::none || specs.alt)
@@ -1494,7 +1494,7 @@ FMT_CONSTEXPR void handle_char_specs(const basic_format_specs<Char>& specs,
 }
 
 template <typename Char, typename Handler>
-FMT_CONSTEXPR void handle_cstring_type_spec(Char spec, Handler&& handler) {
+UMPIRE_FMT_CONSTEXPR void handle_cstring_type_spec(Char spec, Handler&& handler) {
   if (spec == 0 || spec == 's')
     handler.on_string();
   else if (spec == 'p')
@@ -1504,12 +1504,12 @@ FMT_CONSTEXPR void handle_cstring_type_spec(Char spec, Handler&& handler) {
 }
 
 template <typename Char, typename ErrorHandler>
-FMT_CONSTEXPR void check_string_type_spec(Char spec, ErrorHandler&& eh) {
+UMPIRE_FMT_CONSTEXPR void check_string_type_spec(Char spec, ErrorHandler&& eh) {
   if (spec != 0 && spec != 's') eh.on_error("invalid type specifier");
 }
 
 template <typename Char, typename ErrorHandler>
-FMT_CONSTEXPR void check_pointer_type_spec(Char spec, ErrorHandler&& eh) {
+UMPIRE_FMT_CONSTEXPR void check_pointer_type_spec(Char spec, ErrorHandler&& eh) {
   if (spec != 0 && spec != 'p') eh.on_error("invalid type specifier");
 }
 
@@ -1519,25 +1519,25 @@ class char_specs_checker : public ErrorHandler {
   char type_;
 
  public:
-  FMT_CONSTEXPR char_specs_checker(char type, ErrorHandler eh)
+  UMPIRE_FMT_CONSTEXPR char_specs_checker(char type, ErrorHandler eh)
       : ErrorHandler(eh), type_(type) {}
 
-  FMT_CONSTEXPR void on_int() { check_int_type_spec(type_, *this); }
-  FMT_CONSTEXPR void on_char() {}
+  UMPIRE_FMT_CONSTEXPR void on_int() { check_int_type_spec(type_, *this); }
+  UMPIRE_FMT_CONSTEXPR void on_char() {}
 };
 
 template <typename ErrorHandler>
 class cstring_type_checker : public ErrorHandler {
  public:
-  FMT_CONSTEXPR explicit cstring_type_checker(ErrorHandler eh)
+  UMPIRE_FMT_CONSTEXPR explicit cstring_type_checker(ErrorHandler eh)
       : ErrorHandler(eh) {}
 
-  FMT_CONSTEXPR void on_string() {}
-  FMT_CONSTEXPR void on_pointer() {}
+  UMPIRE_FMT_CONSTEXPR void on_string() {}
+  UMPIRE_FMT_CONSTEXPR void on_pointer() {}
 };
 
 template <typename OutputIt, typename Char>
-FMT_NOINLINE FMT_CONSTEXPR OutputIt fill(OutputIt it, size_t n,
+UMPIRE_FMT_NOINLINE UMPIRE_FMT_CONSTEXPR OutputIt fill(OutputIt it, size_t n,
                                          const fill_t<Char>& fill) {
   auto fill_size = fill.size();
   if (fill_size == 1) return detail::fill_n(it, n, fill[0]);
@@ -1552,7 +1552,7 @@ FMT_NOINLINE FMT_CONSTEXPR OutputIt fill(OutputIt it, size_t n,
 // width: output display width in (terminal) column positions.
 template <align::type align = align::left, typename OutputIt, typename Char,
           typename F>
-FMT_CONSTEXPR OutputIt write_padded(OutputIt out,
+UMPIRE_FMT_CONSTEXPR OutputIt write_padded(OutputIt out,
                                     const basic_format_specs<Char>& specs,
                                     size_t size, size_t width, F&& f) {
   static_assert(align == align::left || align == align::right, "");
@@ -1602,7 +1602,7 @@ template <typename Char> struct write_int_data {
   size_t size;
   size_t padding;
 
-  FMT_CONSTEXPR write_int_data(int num_digits, unsigned prefix,
+  UMPIRE_FMT_CONSTEXPR write_int_data(int num_digits, unsigned prefix,
                                const basic_format_specs<Char>& specs)
       : size((prefix >> 24) + to_unsigned(num_digits)), padding(0) {
     if (specs.align == align::numeric) {
@@ -1623,7 +1623,7 @@ template <typename Char> struct write_int_data {
 // where <digits> are written by write_digits(it).
 // prefix contains chars in three lower bytes and the size in the fourth byte.
 template <typename OutputIt, typename Char, typename W>
-FMT_CONSTEXPR FMT_INLINE OutputIt
+UMPIRE_FMT_CONSTEXPR UMPIRE_FMT_INLINE OutputIt
 write_int(OutputIt out, int num_digits, unsigned prefix,
           const basic_format_specs<Char>& specs, W write_digits) {
   // Slightly faster check for specs.width == 0 && specs.precision == -1.
@@ -1699,13 +1699,13 @@ bool write_int_localized(OutputIt& out, UInt value, unsigned prefix,
   return true;
 }
 
-FMT_CONSTEXPR inline void prefix_append(unsigned& prefix, unsigned value) {
+UMPIRE_FMT_CONSTEXPR inline void prefix_append(unsigned& prefix, unsigned value) {
   prefix |= prefix != 0 ? value << 8 : value;
   prefix += (1u + (value > 0xff ? 1 : 0)) << 24;
 }
 
 template <typename OutputIt, typename T, typename Char>
-FMT_CONSTEXPR OutputIt write_int(OutputIt out, T value,
+UMPIRE_FMT_CONSTEXPR OutputIt write_int(OutputIt out, T value,
                                  const basic_format_specs<Char>& specs,
                                  locale_ref loc) {
   auto prefix = 0u;
@@ -1762,20 +1762,20 @@ FMT_CONSTEXPR OutputIt write_int(OutputIt out, T value,
                        return format_uint<3, Char>(it, abs_value, num_digits);
                      });
   }
-#ifdef FMT_DEPRECATED_N_SPECIFIER
+#ifdef UMPIRE_FMT_DEPRECATED_N_SPECIFIER
   case 'n':
     return write_int_localized(out, abs_value, prefix, specs, loc);
 #endif
   case 'c':
     return write_char(out, static_cast<Char>(abs_value), specs);
   default:
-    FMT_THROW(format_error("invalid type specifier"));
+    UMPIRE_FMT_THROW(format_error("invalid type specifier"));
   }
   return out;
 }
 
 template <typename OutputIt, typename StrChar, typename Char>
-FMT_CONSTEXPR OutputIt write(OutputIt out, basic_string_view<StrChar> s,
+UMPIRE_FMT_CONSTEXPR OutputIt write(OutputIt out, basic_string_view<StrChar> s,
                              const basic_format_specs<Char>& specs) {
   auto data = s.data();
   auto size = s.size();
@@ -1832,7 +1832,7 @@ inline OutputIt write_significand(OutputIt out, UInt significand,
 }
 
 template <typename Char, typename UInt,
-          FMT_ENABLE_IF(std::is_integral<UInt>::value)>
+          UMPIRE_FMT_ENABLE_IF(std::is_integral<UInt>::value)>
 inline Char* write_significand(Char* out, UInt significand,
                                int significand_size, int integral_size,
                                Char decimal_point) {
@@ -1848,7 +1848,7 @@ inline Char* write_significand(Char* out, UInt significand,
 }
 
 template <typename OutputIt, typename UInt, typename Char,
-          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<OutputIt>>::value)>
+          UMPIRE_FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<OutputIt>>::value)>
 inline OutputIt write_significand(OutputIt out, UInt significand,
                                   int significand_size, int integral_size,
                                   Char decimal_point) {
@@ -1924,7 +1924,7 @@ OutputIt write_float(OutputIt out, const DecimalFP& fp,
     // 1234e5 -> 123400000[.0+]
     size += to_unsigned(fp.exponent);
     int num_zeros = fspecs.precision - exp;
-#ifdef FMT_FUZZ
+#ifdef UMPIRE_FMT_FUZZ
     if (num_zeros > 5000)
       throw std::runtime_error("fuzz mode - avoiding excessive cpu use");
 #endif
@@ -1970,7 +1970,7 @@ OutputIt write_float(OutputIt out, const DecimalFP& fp,
 }
 
 template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(std::is_floating_point<T>::value)>
+          UMPIRE_FMT_ENABLE_IF(std::is_floating_point<T>::value)>
 OutputIt write(OutputIt out, T value, basic_format_specs<Char> specs,
                locale_ref loc = {}) {
   if (const_check(!is_supported_floating_point(value))) return out;
@@ -2003,7 +2003,7 @@ OutputIt write(OutputIt out, T value, basic_format_specs<Char> specs,
   int precision = specs.precision >= 0 || !specs.type ? specs.precision : 6;
   if (fspecs.format == float_format::exp) {
     if (precision == max_value<int>())
-      FMT_THROW(format_error("number is too big"));
+      UMPIRE_FMT_THROW(format_error("number is too big"));
     else
       ++precision;
   }
@@ -2018,7 +2018,7 @@ OutputIt write(OutputIt out, T value, basic_format_specs<Char> specs,
 }
 
 template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_fast_float<T>::value)>
+          UMPIRE_FMT_ENABLE_IF(is_fast_float<T>::value)>
 OutputIt write(OutputIt out, T value) {
   if (const_check(!is_supported_floating_point(value))) return out;
 
@@ -2043,7 +2043,7 @@ OutputIt write(OutputIt out, T value) {
 }
 
 template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(std::is_floating_point<T>::value &&
+          UMPIRE_FMT_ENABLE_IF(std::is_floating_point<T>::value &&
                         !is_fast_float<T>::value)>
 inline OutputIt write(OutputIt out, T value) {
   return write(out, value, basic_format_specs<Char>());
@@ -2069,12 +2069,12 @@ template <> struct is_integral<uint128_t> : std::true_type {};
 
 template <typename Char, typename OutputIt>
 OutputIt write(OutputIt out, monostate) {
-  FMT_ASSERT(false, "");
+  UMPIRE_FMT_ASSERT(false, "");
   return out;
 }
 
 template <typename Char, typename OutputIt,
-          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
+          UMPIRE_FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
 OutputIt write(OutputIt out, string_view value) {
   auto it = reserve(out, value.size());
   it = copy_str<Char>(value.begin(), value.end(), it);
@@ -2082,23 +2082,23 @@ OutputIt write(OutputIt out, string_view value) {
 }
 
 template <typename Char, typename OutputIt>
-FMT_CONSTEXPR OutputIt write(OutputIt out, basic_string_view<Char> value) {
+UMPIRE_FMT_CONSTEXPR OutputIt write(OutputIt out, basic_string_view<Char> value) {
   auto it = reserve(out, value.size());
   it = copy_str<Char>(value.begin(), value.end(), it);
   return base_iterator(out, it);
 }
 
 template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_string<T>::value)>
+          UMPIRE_FMT_ENABLE_IF(is_string<T>::value)>
 constexpr OutputIt write(OutputIt out, const T& value) {
   return write<Char>(out, to_string_view(value));
 }
 
 template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_integral<T>::value &&
+          UMPIRE_FMT_ENABLE_IF(is_integral<T>::value &&
                         !std::is_same<T, bool>::value &&
                         !std::is_same<T, Char>::value)>
-FMT_CONSTEXPR OutputIt write(OutputIt out, T value) {
+UMPIRE_FMT_CONSTEXPR OutputIt write(OutputIt out, T value) {
   auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
   bool negative = is_negative(value);
   // Don't do -abs_value since it trips unsigned-integer-overflow sanitizer.
@@ -2116,15 +2116,15 @@ FMT_CONSTEXPR OutputIt write(OutputIt out, T value) {
   return base_iterator(out, it);
 }
 
-// FMT_ENABLE_IF() condition separated to workaround MSVC bug
+// UMPIRE_FMT_ENABLE_IF() condition separated to workaround MSVC bug
 template <
     typename Char, typename OutputIt, typename T,
     bool check =
         std::is_enum<T>::value && !std::is_same<T, Char>::value &&
         mapped_type_constant<T, basic_format_context<OutputIt, Char>>::value !=
             type::custom_type,
-    FMT_ENABLE_IF(check)>
-FMT_CONSTEXPR OutputIt write(OutputIt out, T value) {
+    UMPIRE_FMT_ENABLE_IF(check)>
+UMPIRE_FMT_CONSTEXPR OutputIt write(OutputIt out, T value) {
   return write<Char>(
       out, static_cast<typename std::underlying_type<T>::type>(value));
 }
@@ -2135,16 +2135,16 @@ constexpr OutputIt write(OutputIt out, bool value) {
 }
 
 template <typename Char, typename OutputIt>
-FMT_CONSTEXPR OutputIt write(OutputIt out, Char value) {
+UMPIRE_FMT_CONSTEXPR OutputIt write(OutputIt out, Char value) {
   auto it = reserve(out, 1);
   *it++ = value;
   return base_iterator(out, it);
 }
 
 template <typename Char, typename OutputIt>
-FMT_CONSTEXPR OutputIt write(OutputIt out, const Char* value) {
+UMPIRE_FMT_CONSTEXPR OutputIt write(OutputIt out, const Char* value) {
   if (!value) {
-    FMT_THROW(format_error("string pointer is null"));
+    UMPIRE_FMT_THROW(format_error("string pointer is null"));
   } else {
     auto length = std::char_traits<Char>::length(value);
     out = write(out, basic_string_view<Char>(value, length));
@@ -2216,7 +2216,7 @@ class arg_formatter_base {
     *it++ = value;
   }
 
-  template <typename Ch, FMT_ENABLE_IF(std::is_same<Ch, Char>::value)>
+  template <typename Ch, UMPIRE_FMT_ENABLE_IF(std::is_same<Ch, Char>::value)>
   void write(Ch value) {
     out_ = detail::write<Char>(out_, value);
   }
@@ -2242,7 +2242,7 @@ class arg_formatter_base {
   }
 
   template <typename Ch>
-  FMT_CONSTEXPR void write(basic_string_view<Ch> s,
+  UMPIRE_FMT_CONSTEXPR void write(basic_string_view<Ch> s,
                            const format_specs& specs = {}) {
     out_ = detail::write(out_, s, specs);
   }
@@ -2258,13 +2258,13 @@ class arg_formatter_base {
     constexpr char_spec_handler(arg_formatter_base& f, Char val)
         : formatter(f), value(val) {}
 
-    FMT_CONSTEXPR void on_int() {
+    UMPIRE_FMT_CONSTEXPR void on_int() {
       // char is only formatted as int if there are specs.
       formatter.out_ =
           detail::write_int(formatter.out_, static_cast<int>(value),
                             formatter.specs_, formatter.locale_);
     }
-    FMT_CONSTEXPR void on_char() {
+    UMPIRE_FMT_CONSTEXPR void on_char() {
       formatter.out_ = write_char(formatter.out_, value, formatter.specs_);
     }
   };
@@ -2284,7 +2284,7 @@ class arg_formatter_base {
   iterator out() { return out_; }
   const format_specs& specs() { return specs_; }
 
-  FMT_CONSTEXPR void write(bool value) {
+  UMPIRE_FMT_CONSTEXPR void write(bool value) {
     write(string_view(value ? "true" : "false"), specs_);
   }
 
@@ -2292,7 +2292,7 @@ class arg_formatter_base {
     if (value)
       write(basic_string_view<char_type>(value), specs_);
     else
-      FMT_THROW(format_error("string pointer is null"));
+      UMPIRE_FMT_THROW(format_error("string pointer is null"));
   }
 
  public:
@@ -2300,33 +2300,33 @@ class arg_formatter_base {
       : out_(out), specs_(s), locale_(loc) {}
 
   iterator operator()(monostate) {
-    FMT_ASSERT(false, "invalid argument type");
+    UMPIRE_FMT_ASSERT(false, "invalid argument type");
     return out_;
   }
 
-  template <typename T, FMT_ENABLE_IF(is_integral<T>::value)>
-  FMT_CONSTEXPR FMT_INLINE iterator operator()(T value) {
+  template <typename T, UMPIRE_FMT_ENABLE_IF(is_integral<T>::value)>
+  UMPIRE_FMT_CONSTEXPR UMPIRE_FMT_INLINE iterator operator()(T value) {
     return out_ = detail::write_int(out_, value, specs_, locale_);
   }
 
-  FMT_CONSTEXPR iterator operator()(Char value) {
+  UMPIRE_FMT_CONSTEXPR iterator operator()(Char value) {
     handle_char_specs(specs_,
                       char_spec_handler(*this, static_cast<Char>(value)));
     return out_;
   }
 
-  FMT_CONSTEXPR iterator operator()(bool value) {
+  UMPIRE_FMT_CONSTEXPR iterator operator()(bool value) {
     if (specs_.type && specs_.type != 's') return (*this)(value ? 1 : 0);
     write(value != 0);
     return out_;
   }
 
-  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_floating_point<T>::value)>
   iterator operator()(T value) {
     if (const_check(is_supported_floating_point(value)))
       out_ = detail::write(out_, value, specs_, locale_);
     else
-      FMT_ASSERT(false, "unsupported float argument type");
+      UMPIRE_FMT_ASSERT(false, "unsupported float argument type");
     return out_;
   }
 
@@ -2335,7 +2335,7 @@ class arg_formatter_base {
     return out_;
   }
 
-  FMT_CONSTEXPR iterator operator()(basic_string_view<Char> value) {
+  UMPIRE_FMT_CONSTEXPR iterator operator()(basic_string_view<Char> value) {
     check_string_type_spec(specs_.type, error_handler());
     write(value, specs_);
     return out_;
@@ -2381,16 +2381,16 @@ class arg_formatter : public arg_formatter_base<OutputIt, Char> {
   }
 };
 
-template <typename Char> FMT_CONSTEXPR bool is_name_start(Char c) {
+template <typename Char> UMPIRE_FMT_CONSTEXPR bool is_name_start(Char c) {
   return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || '_' == c;
 }
 
 // Parses the range [begin, end) as an unsigned integer. This function assumes
 // that the range is non-empty and the first character is a digit.
 template <typename Char, typename ErrorHandler>
-FMT_CONSTEXPR int parse_nonnegative_int(const Char*& begin, const Char* end,
+UMPIRE_FMT_CONSTEXPR int parse_nonnegative_int(const Char*& begin, const Char* end,
                                         ErrorHandler&& eh) {
-  FMT_ASSERT(begin != end && '0' <= *begin && *begin <= '9', "");
+  UMPIRE_FMT_ASSERT(begin != end && '0' <= *begin && *begin <= '9', "");
   unsigned value = 0;
   // Convert to unsigned to prevent a warning.
   constexpr unsigned max_int = max_value<int>();
@@ -2435,16 +2435,16 @@ using is_integer =
 
 template <typename ErrorHandler> class width_checker {
  public:
-  explicit FMT_CONSTEXPR width_checker(ErrorHandler& eh) : handler_(eh) {}
+  explicit UMPIRE_FMT_CONSTEXPR width_checker(ErrorHandler& eh) : handler_(eh) {}
 
-  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
-  FMT_CONSTEXPR unsigned long long operator()(T value) {
+  template <typename T, UMPIRE_FMT_ENABLE_IF(is_integer<T>::value)>
+  UMPIRE_FMT_CONSTEXPR unsigned long long operator()(T value) {
     if (is_negative(value)) handler_.on_error("negative width");
     return static_cast<unsigned long long>(value);
   }
 
-  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
-  FMT_CONSTEXPR unsigned long long operator()(T) {
+  template <typename T, UMPIRE_FMT_ENABLE_IF(!is_integer<T>::value)>
+  UMPIRE_FMT_CONSTEXPR unsigned long long operator()(T) {
     handler_.on_error("width is not integer");
     return 0;
   }
@@ -2455,16 +2455,16 @@ template <typename ErrorHandler> class width_checker {
 
 template <typename ErrorHandler> class precision_checker {
  public:
-  explicit FMT_CONSTEXPR precision_checker(ErrorHandler& eh) : handler_(eh) {}
+  explicit UMPIRE_FMT_CONSTEXPR precision_checker(ErrorHandler& eh) : handler_(eh) {}
 
-  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
-  FMT_CONSTEXPR unsigned long long operator()(T value) {
+  template <typename T, UMPIRE_FMT_ENABLE_IF(is_integer<T>::value)>
+  UMPIRE_FMT_CONSTEXPR unsigned long long operator()(T value) {
     if (is_negative(value)) handler_.on_error("negative precision");
     return static_cast<unsigned long long>(value);
   }
 
-  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
-  FMT_CONSTEXPR unsigned long long operator()(T) {
+  template <typename T, UMPIRE_FMT_ENABLE_IF(!is_integer<T>::value)>
+  UMPIRE_FMT_CONSTEXPR unsigned long long operator()(T) {
     handler_.on_error("precision is not integer");
     return 0;
   }
@@ -2476,34 +2476,34 @@ template <typename ErrorHandler> class precision_checker {
 // A format specifier handler that sets fields in basic_format_specs.
 template <typename Char> class specs_setter {
  public:
-  explicit FMT_CONSTEXPR specs_setter(basic_format_specs<Char>& specs)
+  explicit UMPIRE_FMT_CONSTEXPR specs_setter(basic_format_specs<Char>& specs)
       : specs_(specs) {}
 
-  FMT_CONSTEXPR specs_setter(const specs_setter& other)
+  UMPIRE_FMT_CONSTEXPR specs_setter(const specs_setter& other)
       : specs_(other.specs_) {}
 
-  FMT_CONSTEXPR void on_align(align_t align) { specs_.align = align; }
-  FMT_CONSTEXPR void on_fill(basic_string_view<Char> fill) {
+  UMPIRE_FMT_CONSTEXPR void on_align(align_t align) { specs_.align = align; }
+  UMPIRE_FMT_CONSTEXPR void on_fill(basic_string_view<Char> fill) {
     specs_.fill = fill;
   }
-  FMT_CONSTEXPR void on_plus() { specs_.sign = sign::plus; }
-  FMT_CONSTEXPR void on_minus() { specs_.sign = sign::minus; }
-  FMT_CONSTEXPR void on_space() { specs_.sign = sign::space; }
-  FMT_CONSTEXPR void on_hash() { specs_.alt = true; }
-  FMT_CONSTEXPR void on_localized() { specs_.localized = true; }
+  UMPIRE_FMT_CONSTEXPR void on_plus() { specs_.sign = sign::plus; }
+  UMPIRE_FMT_CONSTEXPR void on_minus() { specs_.sign = sign::minus; }
+  UMPIRE_FMT_CONSTEXPR void on_space() { specs_.sign = sign::space; }
+  UMPIRE_FMT_CONSTEXPR void on_hash() { specs_.alt = true; }
+  UMPIRE_FMT_CONSTEXPR void on_localized() { specs_.localized = true; }
 
-  FMT_CONSTEXPR void on_zero() {
+  UMPIRE_FMT_CONSTEXPR void on_zero() {
     specs_.align = align::numeric;
     specs_.fill[0] = Char('0');
   }
 
-  FMT_CONSTEXPR void on_width(int width) { specs_.width = width; }
-  FMT_CONSTEXPR void on_precision(int precision) {
+  UMPIRE_FMT_CONSTEXPR void on_width(int width) { specs_.width = width; }
+  UMPIRE_FMT_CONSTEXPR void on_precision(int precision) {
     specs_.precision = precision;
   }
-  FMT_CONSTEXPR void end_precision() {}
+  UMPIRE_FMT_CONSTEXPR void end_precision() {}
 
-  FMT_CONSTEXPR void on_type(Char type) {
+  UMPIRE_FMT_CONSTEXPR void on_type(Char type) {
     specs_.type = static_cast<char>(type);
   }
 
@@ -2513,15 +2513,15 @@ template <typename Char> class specs_setter {
 
 template <typename ErrorHandler> class numeric_specs_checker {
  public:
-  FMT_CONSTEXPR numeric_specs_checker(ErrorHandler& eh, detail::type arg_type)
+  UMPIRE_FMT_CONSTEXPR numeric_specs_checker(ErrorHandler& eh, detail::type arg_type)
       : error_handler_(eh), arg_type_(arg_type) {}
 
-  FMT_CONSTEXPR void require_numeric_argument() {
+  UMPIRE_FMT_CONSTEXPR void require_numeric_argument() {
     if (!is_arithmetic_type(arg_type_))
       error_handler_.on_error("format specifier requires numeric argument");
   }
 
-  FMT_CONSTEXPR void check_sign() {
+  UMPIRE_FMT_CONSTEXPR void check_sign() {
     require_numeric_argument();
     if (is_integral_type(arg_type_) && arg_type_ != type::int_type &&
         arg_type_ != type::long_long_type && arg_type_ != type::char_type) {
@@ -2529,7 +2529,7 @@ template <typename ErrorHandler> class numeric_specs_checker {
     }
   }
 
-  FMT_CONSTEXPR void check_precision() {
+  UMPIRE_FMT_CONSTEXPR void check_precision() {
     if (is_integral_type(arg_type_) || arg_type_ == type::pointer_type)
       error_handler_.on_error("precision not allowed for this argument type");
   }
@@ -2546,56 +2546,56 @@ template <typename Handler> class specs_checker : public Handler {
   numeric_specs_checker<Handler> checker_;
 
   // Suppress an MSVC warning about using this in initializer list.
-  FMT_CONSTEXPR Handler& error_handler() { return *this; }
+  UMPIRE_FMT_CONSTEXPR Handler& error_handler() { return *this; }
 
  public:
-  FMT_CONSTEXPR specs_checker(const Handler& handler, detail::type arg_type)
+  UMPIRE_FMT_CONSTEXPR specs_checker(const Handler& handler, detail::type arg_type)
       : Handler(handler), checker_(error_handler(), arg_type) {}
 
-  FMT_CONSTEXPR specs_checker(const specs_checker& other)
+  UMPIRE_FMT_CONSTEXPR specs_checker(const specs_checker& other)
       : Handler(other), checker_(error_handler(), other.arg_type_) {}
 
-  FMT_CONSTEXPR void on_align(align_t align) {
+  UMPIRE_FMT_CONSTEXPR void on_align(align_t align) {
     if (align == align::numeric) checker_.require_numeric_argument();
     Handler::on_align(align);
   }
 
-  FMT_CONSTEXPR void on_plus() {
+  UMPIRE_FMT_CONSTEXPR void on_plus() {
     checker_.check_sign();
     Handler::on_plus();
   }
 
-  FMT_CONSTEXPR void on_minus() {
+  UMPIRE_FMT_CONSTEXPR void on_minus() {
     checker_.check_sign();
     Handler::on_minus();
   }
 
-  FMT_CONSTEXPR void on_space() {
+  UMPIRE_FMT_CONSTEXPR void on_space() {
     checker_.check_sign();
     Handler::on_space();
   }
 
-  FMT_CONSTEXPR void on_hash() {
+  UMPIRE_FMT_CONSTEXPR void on_hash() {
     checker_.require_numeric_argument();
     Handler::on_hash();
   }
 
-  FMT_CONSTEXPR void on_localized() {
+  UMPIRE_FMT_CONSTEXPR void on_localized() {
     checker_.require_numeric_argument();
     Handler::on_localized();
   }
 
-  FMT_CONSTEXPR void on_zero() {
+  UMPIRE_FMT_CONSTEXPR void on_zero() {
     checker_.require_numeric_argument();
     Handler::on_zero();
   }
 
-  FMT_CONSTEXPR void end_precision() { checker_.check_precision(); }
+  UMPIRE_FMT_CONSTEXPR void end_precision() { checker_.check_precision(); }
 };
 
 template <template <typename> class Handler, typename FormatArg,
           typename ErrorHandler>
-FMT_CONSTEXPR int get_dynamic_spec(FormatArg arg, ErrorHandler eh) {
+UMPIRE_FMT_CONSTEXPR int get_dynamic_spec(FormatArg arg, ErrorHandler eh) {
   unsigned long long value = visit_format_arg(Handler<ErrorHandler>(eh), arg);
   if (value > to_unsigned(max_value<int>())) eh.on_error("number is too big");
   return static_cast<int>(value);
@@ -2604,7 +2604,7 @@ FMT_CONSTEXPR int get_dynamic_spec(FormatArg arg, ErrorHandler eh) {
 struct auto_id {};
 
 template <typename Context, typename ID>
-FMT_CONSTEXPR typename Context::format_arg get_arg(Context& ctx, ID id) {
+UMPIRE_FMT_CONSTEXPR typename Context::format_arg get_arg(Context& ctx, ID id) {
   auto arg = ctx.arg(id);
   if (!arg) ctx.on_error("argument not found");
   return arg;
@@ -2616,18 +2616,18 @@ class specs_handler : public specs_setter<typename Context::char_type> {
  public:
   using char_type = typename Context::char_type;
 
-  FMT_CONSTEXPR specs_handler(basic_format_specs<char_type>& specs,
+  UMPIRE_FMT_CONSTEXPR specs_handler(basic_format_specs<char_type>& specs,
                               ParseContext& parse_ctx, Context& ctx)
       : specs_setter<char_type>(specs),
         parse_context_(parse_ctx),
         context_(ctx) {}
 
-  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
+  template <typename Id> UMPIRE_FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
     this->specs_.width = get_dynamic_spec<width_checker>(
         get_arg(arg_id), context_.error_handler());
   }
 
-  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
+  template <typename Id> UMPIRE_FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
     this->specs_.precision = get_dynamic_spec<precision_checker>(
         get_arg(arg_id), context_.error_handler());
   }
@@ -2638,16 +2638,16 @@ class specs_handler : public specs_setter<typename Context::char_type> {
   // This is only needed for compatibility with gcc 4.4.
   using format_arg = typename Context::format_arg;
 
-  FMT_CONSTEXPR format_arg get_arg(auto_id) {
+  UMPIRE_FMT_CONSTEXPR format_arg get_arg(auto_id) {
     return detail::get_arg(context_, parse_context_.next_arg_id());
   }
 
-  FMT_CONSTEXPR format_arg get_arg(int arg_id) {
+  UMPIRE_FMT_CONSTEXPR format_arg get_arg(int arg_id) {
     parse_context_.check_arg_id(arg_id);
     return detail::get_arg(context_, arg_id);
   }
 
-  FMT_CONSTEXPR format_arg get_arg(basic_string_view<char_type> arg_id) {
+  UMPIRE_FMT_CONSTEXPR format_arg get_arg(basic_string_view<char_type> arg_id) {
     parse_context_.check_arg_id(arg_id);
     return detail::get_arg(context_, arg_id);
   }
@@ -2660,14 +2660,14 @@ enum class arg_id_kind { none, index, name };
 
 // An argument reference.
 template <typename Char> struct arg_ref {
-  FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}
+  UMPIRE_FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}
 
-  FMT_CONSTEXPR explicit arg_ref(int index)
+  UMPIRE_FMT_CONSTEXPR explicit arg_ref(int index)
       : kind(arg_id_kind::index), val(index) {}
-  FMT_CONSTEXPR explicit arg_ref(basic_string_view<Char> name)
+  UMPIRE_FMT_CONSTEXPR explicit arg_ref(basic_string_view<Char> name)
       : kind(arg_id_kind::name), val(name) {}
 
-  FMT_CONSTEXPR arg_ref& operator=(int idx) {
+  UMPIRE_FMT_CONSTEXPR arg_ref& operator=(int idx) {
     kind = arg_id_kind::index;
     val.index = idx;
     return *this;
@@ -2675,8 +2675,8 @@ template <typename Char> struct arg_ref {
 
   arg_id_kind kind;
   union value {
-    FMT_CONSTEXPR value(int id = 0) : index{id} {}
-    FMT_CONSTEXPR value(basic_string_view<Char> n) : name(n) {}
+    UMPIRE_FMT_CONSTEXPR value(int id = 0) : index{id} {}
+    UMPIRE_FMT_CONSTEXPR value(basic_string_view<Char> n) : name(n) {}
 
     int index;
     basic_string_view<Char> name;
@@ -2700,40 +2700,40 @@ class dynamic_specs_handler
  public:
   using char_type = typename ParseContext::char_type;
 
-  FMT_CONSTEXPR dynamic_specs_handler(dynamic_format_specs<char_type>& specs,
+  UMPIRE_FMT_CONSTEXPR dynamic_specs_handler(dynamic_format_specs<char_type>& specs,
                                       ParseContext& ctx)
       : specs_setter<char_type>(specs), specs_(specs), context_(ctx) {}
 
-  FMT_CONSTEXPR dynamic_specs_handler(const dynamic_specs_handler& other)
+  UMPIRE_FMT_CONSTEXPR dynamic_specs_handler(const dynamic_specs_handler& other)
       : specs_setter<char_type>(other),
         specs_(other.specs_),
         context_(other.context_) {}
 
-  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
+  template <typename Id> UMPIRE_FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
     specs_.width_ref = make_arg_ref(arg_id);
   }
 
-  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
+  template <typename Id> UMPIRE_FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
     specs_.precision_ref = make_arg_ref(arg_id);
   }
 
-  FMT_CONSTEXPR void on_error(const char* message) {
+  UMPIRE_FMT_CONSTEXPR void on_error(const char* message) {
     context_.on_error(message);
   }
 
  private:
   using arg_ref_type = arg_ref<char_type>;
 
-  FMT_CONSTEXPR arg_ref_type make_arg_ref(int arg_id) {
+  UMPIRE_FMT_CONSTEXPR arg_ref_type make_arg_ref(int arg_id) {
     context_.check_arg_id(arg_id);
     return arg_ref_type(arg_id);
   }
 
-  FMT_CONSTEXPR arg_ref_type make_arg_ref(auto_id) {
+  UMPIRE_FMT_CONSTEXPR arg_ref_type make_arg_ref(auto_id) {
     return arg_ref_type(context_.next_arg_id());
   }
 
-  FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<char_type> arg_id) {
+  UMPIRE_FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<char_type> arg_id) {
     context_.check_arg_id(arg_id);
     basic_string_view<char_type> format_str(
         context_.begin(), to_unsigned(context_.end() - context_.begin()));
@@ -2745,9 +2745,9 @@ class dynamic_specs_handler
 };
 
 template <typename Char, typename IDHandler>
-FMT_CONSTEXPR const Char* do_parse_arg_id(const Char* begin, const Char* end,
+UMPIRE_FMT_CONSTEXPR const Char* do_parse_arg_id(const Char* begin, const Char* end,
                                           IDHandler&& handler) {
-  FMT_ASSERT(begin != end, "");
+  UMPIRE_FMT_ASSERT(begin != end, "");
   Char c = *begin;
   if (c >= '0' && c <= '9') {
     int index = 0;
@@ -2774,7 +2774,7 @@ FMT_CONSTEXPR const Char* do_parse_arg_id(const Char* begin, const Char* end,
 }
 
 template <typename Char, typename IDHandler>
-FMT_CONSTEXPR_DECL FMT_INLINE const Char* parse_arg_id(const Char* begin,
+UMPIRE_FMT_CONSTEXPR_DECL UMPIRE_FMT_INLINE const Char* parse_arg_id(const Char* begin,
                                                        const Char* end,
                                                        IDHandler&& handler) {
   Char c = *begin;
@@ -2785,15 +2785,15 @@ FMT_CONSTEXPR_DECL FMT_INLINE const Char* parse_arg_id(const Char* begin,
 
 // Adapts SpecHandler to IDHandler API for dynamic width.
 template <typename SpecHandler, typename Char> struct width_adapter {
-  explicit FMT_CONSTEXPR width_adapter(SpecHandler& h) : handler(h) {}
+  explicit UMPIRE_FMT_CONSTEXPR width_adapter(SpecHandler& h) : handler(h) {}
 
-  FMT_CONSTEXPR void operator()() { handler.on_dynamic_width(auto_id()); }
-  FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_width(id); }
-  FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
+  UMPIRE_FMT_CONSTEXPR void operator()() { handler.on_dynamic_width(auto_id()); }
+  UMPIRE_FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_width(id); }
+  UMPIRE_FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
     handler.on_dynamic_width(id);
   }
 
-  FMT_CONSTEXPR void on_error(const char* message) {
+  UMPIRE_FMT_CONSTEXPR void on_error(const char* message) {
     handler.on_error(message);
   }
 
@@ -2802,15 +2802,15 @@ template <typename SpecHandler, typename Char> struct width_adapter {
 
 // Adapts SpecHandler to IDHandler API for dynamic precision.
 template <typename SpecHandler, typename Char> struct precision_adapter {
-  explicit FMT_CONSTEXPR precision_adapter(SpecHandler& h) : handler(h) {}
+  explicit UMPIRE_FMT_CONSTEXPR precision_adapter(SpecHandler& h) : handler(h) {}
 
-  FMT_CONSTEXPR void operator()() { handler.on_dynamic_precision(auto_id()); }
-  FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_precision(id); }
-  FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
+  UMPIRE_FMT_CONSTEXPR void operator()() { handler.on_dynamic_precision(auto_id()); }
+  UMPIRE_FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_precision(id); }
+  UMPIRE_FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
     handler.on_dynamic_precision(id);
   }
 
-  FMT_CONSTEXPR void on_error(const char* message) {
+  UMPIRE_FMT_CONSTEXPR void on_error(const char* message) {
     handler.on_error(message);
   }
 
@@ -2822,20 +2822,20 @@ template <typename Char> constexpr bool is_ascii_letter(Char c) {
 }
 
 // Converts a character to ASCII. Returns a number > 127 on conversion failure.
-template <typename Char, FMT_ENABLE_IF(std::is_integral<Char>::value)>
+template <typename Char, UMPIRE_FMT_ENABLE_IF(std::is_integral<Char>::value)>
 constexpr Char to_ascii(Char value) {
   return value;
 }
-template <typename Char, FMT_ENABLE_IF(std::is_enum<Char>::value)>
+template <typename Char, UMPIRE_FMT_ENABLE_IF(std::is_enum<Char>::value)>
 constexpr typename std::underlying_type<Char>::type to_ascii(Char value) {
   return value;
 }
 
 // Parses fill and alignment.
 template <typename Char, typename Handler>
-FMT_CONSTEXPR const Char* parse_align(const Char* begin, const Char* end,
+UMPIRE_FMT_CONSTEXPR const Char* parse_align(const Char* begin, const Char* end,
                                       Handler&& handler) {
-  FMT_ASSERT(begin != end, "");
+  UMPIRE_FMT_ASSERT(begin != end, "");
   auto align = align::none;
   auto p = begin + code_point_length(begin);
   if (p >= end) p = begin;
@@ -2847,7 +2847,7 @@ FMT_CONSTEXPR const Char* parse_align(const Char* begin, const Char* end,
     case '>':
       align = align::right;
       break;
-#if FMT_DEPRECATED_NUMERIC_ALIGN
+#if UMPIRE_FMT_DEPRECATED_NUMERIC_ALIGN
     case '=':
       align = align::numeric;
       break;
@@ -2878,9 +2878,9 @@ FMT_CONSTEXPR const Char* parse_align(const Char* begin, const Char* end,
 }
 
 template <typename Char, typename Handler>
-FMT_CONSTEXPR const Char* parse_width(const Char* begin, const Char* end,
+UMPIRE_FMT_CONSTEXPR const Char* parse_width(const Char* begin, const Char* end,
                                       Handler&& handler) {
-  FMT_ASSERT(begin != end, "");
+  UMPIRE_FMT_ASSERT(begin != end, "");
   if ('0' <= *begin && *begin <= '9') {
     handler.on_width(parse_nonnegative_int(begin, end, handler));
   } else if (*begin == '{') {
@@ -2895,7 +2895,7 @@ FMT_CONSTEXPR const Char* parse_width(const Char* begin, const Char* end,
 }
 
 template <typename Char, typename Handler>
-FMT_CONSTEXPR const Char* parse_precision(const Char* begin, const Char* end,
+UMPIRE_FMT_CONSTEXPR const Char* parse_precision(const Char* begin, const Char* end,
                                           Handler&& handler) {
   ++begin;
   auto c = begin != end ? *begin : Char();
@@ -2919,7 +2919,7 @@ FMT_CONSTEXPR const Char* parse_precision(const Char* begin, const Char* end,
 // Parses standard format specifiers and sends notifications about parsed
 // components to handler.
 template <typename Char, typename SpecHandler>
-FMT_CONSTEXPR_DECL FMT_INLINE const Char* parse_format_specs(
+UMPIRE_FMT_CONSTEXPR_DECL UMPIRE_FMT_INLINE const Char* parse_format_specs(
     const Char* begin, const Char* end, SpecHandler&& handler) {
   if (begin + 1 < end && begin[1] == '}' && is_ascii_letter(*begin) &&
       *begin != 'L') {
@@ -2983,7 +2983,7 @@ FMT_CONSTEXPR_DECL FMT_INLINE const Char* parse_format_specs(
 
 // Return the result via the out param to workaround gcc bug 77539.
 template <bool IS_CONSTEXPR, typename T, typename Ptr = const T*>
-FMT_CONSTEXPR bool find(Ptr first, Ptr last, T value, Ptr& out) {
+UMPIRE_FMT_CONSTEXPR bool find(Ptr first, Ptr last, T value, Ptr& out) {
   for (out = first; out != last; ++out) {
     if (*out == value) return true;
   }
@@ -3002,18 +3002,18 @@ template <typename Handler, typename Char> struct id_adapter {
   Handler& handler;
   int arg_id;
 
-  FMT_CONSTEXPR void operator()() { arg_id = handler.on_arg_id(); }
-  FMT_CONSTEXPR void operator()(int id) { arg_id = handler.on_arg_id(id); }
-  FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
+  UMPIRE_FMT_CONSTEXPR void operator()() { arg_id = handler.on_arg_id(); }
+  UMPIRE_FMT_CONSTEXPR void operator()(int id) { arg_id = handler.on_arg_id(id); }
+  UMPIRE_FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
     arg_id = handler.on_arg_id(id);
   }
-  FMT_CONSTEXPR void on_error(const char* message) {
+  UMPIRE_FMT_CONSTEXPR void on_error(const char* message) {
     handler.on_error(message);
   }
 };
 
 template <typename Char, typename Handler>
-FMT_CONSTEXPR const Char* parse_replacement_field(const Char* begin,
+UMPIRE_FMT_CONSTEXPR const Char* parse_replacement_field(const Char* begin,
                                                   const Char* end,
                                                   Handler&& handler) {
   ++begin;
@@ -3040,7 +3040,7 @@ FMT_CONSTEXPR const Char* parse_replacement_field(const Char* begin,
 }
 
 template <bool IS_CONSTEXPR, typename Char, typename Handler>
-FMT_CONSTEXPR_DECL FMT_INLINE void parse_format_string(
+UMPIRE_FMT_CONSTEXPR_DECL UMPIRE_FMT_INLINE void parse_format_string(
     basic_string_view<Char> format_str, Handler&& handler) {
   auto begin = format_str.data();
   auto end = begin + format_str.size();
@@ -3063,7 +3063,7 @@ FMT_CONSTEXPR_DECL FMT_INLINE void parse_format_string(
     return;
   }
   struct writer {
-    FMT_CONSTEXPR void operator()(const Char* pbegin, const Char* pend) {
+    UMPIRE_FMT_CONSTEXPR void operator()(const Char* pbegin, const Char* pend) {
       if (pbegin == pend) return;
       for (;;) {
         const Char* p = nullptr;
@@ -3090,7 +3090,7 @@ FMT_CONSTEXPR_DECL FMT_INLINE void parse_format_string(
 }
 
 template <typename T, typename ParseContext>
-FMT_CONSTEXPR const typename ParseContext::char_type* parse_format_specs(
+UMPIRE_FMT_CONSTEXPR const typename ParseContext::char_type* parse_format_specs(
     ParseContext& ctx) {
   using char_type = typename ParseContext::char_type;
   using context = buffer_context<char_type>;
@@ -3125,7 +3125,7 @@ struct format_handler : detail::error_handler {
     return arg_id;
   }
 
-  FMT_INLINE void on_replacement_field(int id, const Char*) {
+  UMPIRE_FMT_INLINE void on_replacement_field(int id, const Char*) {
     auto arg = get_arg(context, id);
     context.advance_to(visit_format_arg(
         default_arg_formatter<OutputIt, Char>{context.out(), context.args(),
@@ -3165,18 +3165,18 @@ class compile_parse_context
   using base = basic_format_parse_context<Char, ErrorHandler>;
 
  public:
-  explicit FMT_CONSTEXPR compile_parse_context(
+  explicit UMPIRE_FMT_CONSTEXPR compile_parse_context(
       basic_string_view<Char> format_str, int num_args = max_value<int>(),
       ErrorHandler eh = {})
       : base(format_str, eh), num_args_(num_args) {}
 
-  FMT_CONSTEXPR int next_arg_id() {
+  UMPIRE_FMT_CONSTEXPR int next_arg_id() {
     int id = base::next_arg_id();
     if (id >= num_args_) this->on_error("argument not found");
     return id;
   }
 
-  FMT_CONSTEXPR void check_arg_id(int id) {
+  UMPIRE_FMT_CONSTEXPR void check_arg_id(int id) {
     base::check_arg_id(id);
     if (id >= num_args_) this->on_error("argument not found");
   }
@@ -3186,30 +3186,30 @@ class compile_parse_context
 template <typename Char, typename ErrorHandler, typename... Args>
 class format_string_checker {
  public:
-  explicit FMT_CONSTEXPR format_string_checker(
+  explicit UMPIRE_FMT_CONSTEXPR format_string_checker(
       basic_string_view<Char> format_str, ErrorHandler eh)
       : context_(format_str, num_args, eh),
         parse_funcs_{&parse_format_specs<Args, parse_context_type>...} {}
 
-  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
+  UMPIRE_FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
 
-  FMT_CONSTEXPR int on_arg_id() { return context_.next_arg_id(); }
-  FMT_CONSTEXPR int on_arg_id(int id) { return context_.check_arg_id(id), id; }
-  FMT_CONSTEXPR int on_arg_id(basic_string_view<Char>) {
+  UMPIRE_FMT_CONSTEXPR int on_arg_id() { return context_.next_arg_id(); }
+  UMPIRE_FMT_CONSTEXPR int on_arg_id(int id) { return context_.check_arg_id(id), id; }
+  UMPIRE_FMT_CONSTEXPR int on_arg_id(basic_string_view<Char>) {
     on_error("compile-time checks don't support named arguments");
     return 0;
   }
 
-  FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}
+  UMPIRE_FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}
 
-  FMT_CONSTEXPR const Char* on_format_specs(int id, const Char* begin,
+  UMPIRE_FMT_CONSTEXPR const Char* on_format_specs(int id, const Char* begin,
                                             const Char*) {
     advance_to(context_, begin);
     // id >= 0 check is a workaround for gcc 10 bug (#2065).
     return id >= 0 && id < num_args ? parse_funcs_[id](context_) : begin;
   }
 
-  FMT_CONSTEXPR void on_error(const char* message) {
+  UMPIRE_FMT_CONSTEXPR void on_error(const char* message) {
     context_.on_error(message);
   }
 
@@ -3226,7 +3226,7 @@ class format_string_checker {
 
 // Converts string literals to basic_string_view.
 template <typename Char, size_t N>
-FMT_CONSTEXPR basic_string_view<Char> compile_string_to_view(
+UMPIRE_FMT_CONSTEXPR basic_string_view<Char> compile_string_to_view(
     const Char (&s)[N]) {
   // Remove trailing null character if needed. Won't be present if this is used
   // with raw character array (i.e. not defined as a string).
@@ -3236,23 +3236,23 @@ FMT_CONSTEXPR basic_string_view<Char> compile_string_to_view(
 
 // Converts string_view to basic_string_view.
 template <typename Char>
-FMT_CONSTEXPR basic_string_view<Char> compile_string_to_view(
+UMPIRE_FMT_CONSTEXPR basic_string_view<Char> compile_string_to_view(
     const std_string_view<Char>& s) {
   return {s.data(), s.size()};
 }
 
-#define FMT_STRING_IMPL(s, base)                                           \
+#define UMPIRE_FMT_STRING_IMPL(s, base)                                           \
   [] {                                                                     \
     /* Use the hidden visibility as a workaround for a GCC bug (#1973). */ \
     /* Use a macro-like name to avoid shadowing warnings. */               \
-    struct FMT_GCC_VISIBILITY_HIDDEN FMT_COMPILE_STRING : base {           \
+    struct UMPIRE_FMT_GCC_VISIBILITY_HIDDEN UMPIRE_FMT_COMPILE_STRING : base {           \
       using char_type = umpire::fmt::remove_cvref_t<decltype(s[0])>;               \
-      FMT_MAYBE_UNUSED FMT_CONSTEXPR                                       \
+      UMPIRE_FMT_MAYBE_UNUSED UMPIRE_FMT_CONSTEXPR                                       \
       operator umpire::fmt::basic_string_view<char_type>() const {                 \
         return umpire::fmt::detail::compile_string_to_view<char_type>(s);          \
       }                                                                    \
     };                                                                     \
-    return FMT_COMPILE_STRING();                                           \
+    return UMPIRE_FMT_COMPILE_STRING();                                           \
   }()
 
 /**
@@ -3262,24 +3262,24 @@ FMT_CONSTEXPR basic_string_view<Char> compile_string_to_view(
   **Example**::
 
     // A compile-time error because 'd' is an invalid specifier for strings.
-    std::string s = umpire::fmt::format(FMT_STRING("{:d}"), "foo");
+    std::string s = umpire::fmt::format(UMPIRE_FMT_STRING("{:d}"), "foo");
   \endrst
  */
-#define FMT_STRING(s) FMT_STRING_IMPL(s, umpire::fmt::compile_string)
+#define UMPIRE_FMT_STRING(s) UMPIRE_FMT_STRING_IMPL(s, umpire::fmt::compile_string)
 
 template <typename... Args, typename S,
           enable_if_t<(is_compile_string<S>::value), int>>
 void check_format_string(S format_str) {
-  FMT_CONSTEXPR_DECL auto s = to_string_view(format_str);
+  UMPIRE_FMT_CONSTEXPR_DECL auto s = to_string_view(format_str);
   using checker = format_string_checker<typename S::char_type, error_handler,
                                         remove_cvref_t<Args>...>;
-  FMT_CONSTEXPR_DECL bool invalid_format =
+  UMPIRE_FMT_CONSTEXPR_DECL bool invalid_format =
       (parse_format_string<true>(s, checker(s, {})), true);
   (void)invalid_format;
 }
 
 template <template <typename> class Handler, typename Context>
-FMT_CONSTEXPR void handle_dynamic_spec(int& value,
+UMPIRE_FMT_CONSTEXPR void handle_dynamic_spec(int& value,
                                        arg_ref<typename Context::char_type> ref,
                                        Context& ctx) {
   switch (ref.kind) {
@@ -3298,23 +3298,23 @@ FMT_CONSTEXPR void handle_dynamic_spec(int& value,
 
 using format_func = void (*)(detail::buffer<char>&, int, string_view);
 
-FMT_API void format_error_code(buffer<char>& out, int error_code,
-                               string_view message) FMT_NOEXCEPT;
+UMPIRE_FMT_API void format_error_code(buffer<char>& out, int error_code,
+                               string_view message) UMPIRE_FMT_NOEXCEPT;
 
-FMT_API void report_error(format_func func, int error_code,
-                          string_view message) FMT_NOEXCEPT;
+UMPIRE_FMT_API void report_error(format_func func, int error_code,
+                          string_view message) UMPIRE_FMT_NOEXCEPT;
 }  // namespace detail
 
 template <typename OutputIt, typename Char>
-using arg_formatter FMT_DEPRECATED_ALIAS =
+using arg_formatter UMPIRE_FMT_DEPRECATED_ALIAS =
     detail::arg_formatter<OutputIt, Char>;
 
 /**
  An error returned by an operating system or a language runtime,
  for example a file opening error.
 */
-FMT_CLASS_API
-class FMT_API system_error : public std::runtime_error {
+UMPIRE_FMT_CLASS_API
+class UMPIRE_FMT_API system_error : public std::runtime_error {
  private:
   void init(int err_code, string_view format_str, format_args args);
 
@@ -3351,7 +3351,7 @@ class FMT_API system_error : public std::runtime_error {
   system_error& operator=(const system_error&) = default;
   system_error(system_error&&) = default;
   system_error& operator=(system_error&&) = default;
-  ~system_error() FMT_NOEXCEPT FMT_OVERRIDE;
+  ~system_error() UMPIRE_FMT_NOEXCEPT UMPIRE_FMT_OVERRIDE;
 
   int error_code() const { return error_code_; }
 };
@@ -3372,13 +3372,13 @@ class FMT_API system_error : public std::runtime_error {
   may look like "Unknown error -1" and is platform-dependent.
   \endrst
  */
-FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
-                                 string_view message) FMT_NOEXCEPT;
+UMPIRE_FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
+                                 string_view message) UMPIRE_FMT_NOEXCEPT;
 
 // Reports a system error without throwing an exception.
 // Can be used to report errors from destructors.
-FMT_API void report_system_error(int error_code,
-                                 string_view message) FMT_NOEXCEPT;
+UMPIRE_FMT_API void report_system_error(int error_code,
+                                 string_view message) UMPIRE_FMT_NOEXCEPT;
 
 /** Fast integer formatter. */
 class format_int {
@@ -3446,12 +3446,12 @@ template <typename T, typename Char>
 struct formatter<T, Char,
                  enable_if_t<detail::type_constant<T, Char>::value !=
                              detail::type::custom_type>> {
-  FMT_CONSTEXPR formatter() = default;
+  UMPIRE_FMT_CONSTEXPR formatter() = default;
 
   // Parses format specifiers stopping either at the end of the range or at the
   // terminating '}'.
   template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  UMPIRE_FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
     auto begin = ctx.begin(), end = ctx.end();
     if (begin == end) return begin;
     using handler_type = detail::dynamic_specs_handler<ParseContext>;
@@ -3462,11 +3462,11 @@ struct formatter<T, Char,
     auto eh = ctx.error_handler();
     switch (type) {
     case detail::type::none_type:
-      FMT_ASSERT(false, "invalid argument type");
+      UMPIRE_FMT_ASSERT(false, "invalid argument type");
       break;
     case detail::type::bool_type:
       if (!specs_.type || specs_.type == 's') break;
-      FMT_FALLTHROUGH;
+      UMPIRE_FMT_FALLTHROUGH;
     case detail::type::int_type:
     case detail::type::uint_type:
     case detail::type::long_long_type:
@@ -3480,22 +3480,22 @@ struct formatter<T, Char,
           specs_, detail::char_specs_checker<decltype(eh)>(specs_.type, eh));
       break;
     case detail::type::float_type:
-      if (detail::const_check(FMT_USE_FLOAT))
+      if (detail::const_check(UMPIRE_FMT_USE_FLOAT))
         detail::parse_float_type_spec(specs_, eh);
       else
-        FMT_ASSERT(false, "float support disabled");
+        UMPIRE_FMT_ASSERT(false, "float support disabled");
       break;
     case detail::type::double_type:
-      if (detail::const_check(FMT_USE_DOUBLE))
+      if (detail::const_check(UMPIRE_FMT_USE_DOUBLE))
         detail::parse_float_type_spec(specs_, eh);
       else
-        FMT_ASSERT(false, "double support disabled");
+        UMPIRE_FMT_ASSERT(false, "double support disabled");
       break;
     case detail::type::long_double_type:
-      if (detail::const_check(FMT_USE_LONG_DOUBLE))
+      if (detail::const_check(UMPIRE_FMT_USE_LONG_DOUBLE))
         detail::parse_float_type_spec(specs_, eh);
       else
-        FMT_ASSERT(false, "long double support disabled");
+        UMPIRE_FMT_ASSERT(false, "long double support disabled");
       break;
     case detail::type::cstring_type:
       detail::handle_cstring_type_spec(
@@ -3516,7 +3516,7 @@ struct formatter<T, Char,
   }
 
   template <typename FormatContext>
-  FMT_CONSTEXPR auto format(const T& val, FormatContext& ctx) const
+  UMPIRE_FMT_CONSTEXPR auto format(const T& val, FormatContext& ctx) const
       -> decltype(ctx.out()) {
     auto specs = specs_;
     detail::handle_dynamic_spec<detail::width_checker>(specs.width,
@@ -3533,7 +3533,7 @@ struct formatter<T, Char,
   detail::dynamic_format_specs<Char> specs_;
 };
 
-#define FMT_FORMAT_AS(Type, Base)                                        \
+#define UMPIRE_FMT_FORMAT_AS(Type, Base)                                        \
   template <typename Char>                                               \
   struct formatter<Type, Char> : formatter<Base, Char> {                 \
     template <typename FormatContext>                                    \
@@ -3543,18 +3543,18 @@ struct formatter<T, Char,
     }                                                                    \
   }
 
-FMT_FORMAT_AS(signed char, int);
-FMT_FORMAT_AS(unsigned char, unsigned);
-FMT_FORMAT_AS(short, int);
-FMT_FORMAT_AS(unsigned short, unsigned);
-FMT_FORMAT_AS(long, long long);
-FMT_FORMAT_AS(unsigned long, unsigned long long);
-FMT_FORMAT_AS(Char*, const Char*);
-FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);
-FMT_FORMAT_AS(std::nullptr_t, const void*);
-FMT_FORMAT_AS(detail::std_string_view<Char>, basic_string_view<Char>);
+UMPIRE_FMT_FORMAT_AS(signed char, int);
+UMPIRE_FMT_FORMAT_AS(unsigned char, unsigned);
+UMPIRE_FMT_FORMAT_AS(short, int);
+UMPIRE_FMT_FORMAT_AS(unsigned short, unsigned);
+UMPIRE_FMT_FORMAT_AS(long, long long);
+UMPIRE_FMT_FORMAT_AS(unsigned long, unsigned long long);
+UMPIRE_FMT_FORMAT_AS(Char*, const Char*);
+UMPIRE_FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);
+UMPIRE_FMT_FORMAT_AS(std::nullptr_t, const void*);
+UMPIRE_FMT_FORMAT_AS(detail::std_string_view<Char>, basic_string_view<Char>);
 #ifdef __cpp_lib_byte
-FMT_FORMAT_AS(std::byte, unsigned);
+UMPIRE_FMT_FORMAT_AS(std::byte, unsigned);
 #endif
 
 template <typename Char>
@@ -3568,7 +3568,7 @@ struct formatter<void*, Char> : formatter<const void*, Char> {
 template <typename Char, size_t N>
 struct formatter<Char[N], Char> : formatter<basic_string_view<Char>, Char> {
   template <typename FormatContext>
-  FMT_CONSTEXPR auto format(const Char* val, FormatContext& ctx) const
+  UMPIRE_FMT_CONSTEXPR auto format(const Char* val, FormatContext& ctx) const
       -> decltype(ctx.out()) {
     return formatter<basic_string_view<Char>, Char>::format(val, ctx);
   }
@@ -3598,7 +3598,7 @@ template <typename Char = char> class dynamic_formatter {
 
  public:
   template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  UMPIRE_FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
     format_str_ = ctx.begin();
     // Checks are deferred to formatting time when the argument type is known.
     detail::dynamic_specs_handler<ParseContext> handler(specs_, ctx);
@@ -3645,7 +3645,7 @@ template <typename Char = char> class dynamic_formatter {
 };
 
 template <typename Char, typename ErrorHandler>
-FMT_CONSTEXPR void advance_to(
+UMPIRE_FMT_CONSTEXPR void advance_to(
     basic_format_parse_context<Char, ErrorHandler>& ctx, const Char* p) {
   ctx.advance_to(ctx.begin() + (p - &*ctx.begin()));
 }
@@ -3685,7 +3685,7 @@ template <> struct formatter<bytes> {
 
  public:
   template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  UMPIRE_FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
     using handler_type = detail::dynamic_specs_handler<ParseContext>;
     detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),
                                                 detail::type::string_type);
@@ -3727,7 +3727,7 @@ struct formatter<arg_join<It, Sentinel, Char>, Char> {
 
  public:
   template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  UMPIRE_FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
     return value_formatter_.parse(ctx);
   }
 
@@ -3801,14 +3801,14 @@ arg_join<detail::iterator_t<Range>, detail::sentinel_t<Range>, wchar_t> join(
     std::string answer = umpire::fmt::to_string(42);
   \endrst
  */
-template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+template <typename T, UMPIRE_FMT_ENABLE_IF(!std::is_integral<T>::value)>
 inline std::string to_string(const T& value) {
   std::string result;
   detail::write<char>(std::back_inserter(result), value);
   return result;
 }
 
-template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_integral<T>::value)>
 inline std::string to_string(T value) {
   // The buffer should be large enough to store the number including the sign or
   // "false" for bool.
@@ -3822,7 +3822,7 @@ inline std::string to_string(T value) {
   Converts *value* to ``std::wstring`` using the default format for type *T*.
  */
 template <typename T> inline std::wstring to_wstring(const T& value) {
-  return format(FMT_STRING(L"{}"), value);
+  return format(UMPIRE_FMT_STRING(L"{}"), value);
 }
 
 template <typename Char, size_t SIZE>
@@ -3851,18 +3851,18 @@ void detail::vformat_to(
   parse_format_string<false>(format_str, h);
 }
 
-#ifndef FMT_HEADER_ONLY
+#ifndef UMPIRE_FMT_HEADER_ONLY
 extern template void detail::vformat_to(detail::buffer<char>&, string_view,
                                         basic_format_args<format_context>,
                                         detail::locale_ref);
 namespace detail {
 
-extern template FMT_API std::string grouping_impl<char>(locale_ref loc);
-extern template FMT_API std::string grouping_impl<wchar_t>(locale_ref loc);
-extern template FMT_API char thousands_sep_impl<char>(locale_ref loc);
-extern template FMT_API wchar_t thousands_sep_impl<wchar_t>(locale_ref loc);
-extern template FMT_API char decimal_point_impl(locale_ref loc);
-extern template FMT_API wchar_t decimal_point_impl(locale_ref loc);
+extern template UMPIRE_FMT_API std::string grouping_impl<char>(locale_ref loc);
+extern template UMPIRE_FMT_API std::string grouping_impl<wchar_t>(locale_ref loc);
+extern template UMPIRE_FMT_API char thousands_sep_impl<char>(locale_ref loc);
+extern template UMPIRE_FMT_API wchar_t thousands_sep_impl<wchar_t>(locale_ref loc);
+extern template UMPIRE_FMT_API char decimal_point_impl(locale_ref loc);
+extern template UMPIRE_FMT_API wchar_t decimal_point_impl(locale_ref loc);
 extern template int format_float<double>(double value, int precision,
                                          float_specs specs, buffer<char>& buf);
 extern template int format_float<long double>(long double value, int precision,
@@ -3881,10 +3881,10 @@ extern template int snprintf_float<long double>(long double value,
 #endif
 
 template <typename S, typename Char = char_t<S>,
-          FMT_ENABLE_IF(detail::is_string<S>::value)>
+          UMPIRE_FMT_ENABLE_IF(detail::is_string<S>::value)>
 inline void vformat_to(
     detail::buffer<Char>& buf, const S& format_str,
-    basic_format_args<FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args) {
+    basic_format_args<UMPIRE_FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args) {
   return detail::vformat_to(buf, to_string_view(format_str), args);
 }
 
@@ -3904,19 +3904,19 @@ template <typename OutputIt, typename Char = char>
 using format_args_t = basic_format_args<format_context_t<OutputIt, Char>>;
 
 template <typename OutputIt, typename Char = typename OutputIt::value_type>
-using format_to_n_context FMT_DEPRECATED_ALIAS = buffer_context<Char>;
+using format_to_n_context UMPIRE_FMT_DEPRECATED_ALIAS = buffer_context<Char>;
 
 template <typename OutputIt, typename Char = typename OutputIt::value_type>
-using format_to_n_args FMT_DEPRECATED_ALIAS =
+using format_to_n_args UMPIRE_FMT_DEPRECATED_ALIAS =
     basic_format_args<buffer_context<Char>>;
 
 template <typename OutputIt, typename Char, typename... Args>
-FMT_DEPRECATED format_arg_store<buffer_context<Char>, Args...>
+UMPIRE_FMT_DEPRECATED format_arg_store<buffer_context<Char>, Args...>
 make_format_to_n_args(const Args&... args) {
   return format_arg_store<buffer_context<Char>, Args...>(args...);
 }
 
-#if FMT_COMPILE_TIME_CHECKS
+#if UMPIRE_FMT_COMPILE_TIME_CHECKS
 template <typename... Args> struct format_string {
   string_view str;
 
@@ -3929,12 +3929,12 @@ template <typename... Args> struct format_string {
   }
 
   template <typename T,
-            FMT_ENABLE_IF(std::is_constructible_v<string_view, const T&>)>
+            UMPIRE_FMT_ENABLE_IF(std::is_constructible_v<string_view, const T&>)>
   format_string(const T& s) : str(s) {}
 };
 
 template <typename... Args>
-FMT_INLINE std::string format(
+UMPIRE_FMT_INLINE std::string format(
     format_string<std::type_identity_t<Args>...> format_str, Args&&... args) {
   return detail::vformat(format_str.str, make_format_args(args...));
 }
@@ -3949,22 +3949,22 @@ std::basic_string<Char> detail::vformat(
   return to_string(buffer);
 }
 
-template <typename Char, FMT_ENABLE_IF(std::is_same<Char, wchar_t>::value)>
+template <typename Char, UMPIRE_FMT_ENABLE_IF(std::is_same<Char, wchar_t>::value)>
 void vprint(std::FILE* f, basic_string_view<Char> format_str,
             wformat_args args) {
   wmemory_buffer buffer;
   detail::vformat_to(buffer, format_str, args);
   buffer.push_back(L'\0');
   if (std::fputws(buffer.data(), f) == -1)
-    FMT_THROW(system_error(errno, "cannot write to file"));
+    UMPIRE_FMT_THROW(system_error(errno, "cannot write to file"));
 }
 
-template <typename Char, FMT_ENABLE_IF(std::is_same<Char, wchar_t>::value)>
+template <typename Char, UMPIRE_FMT_ENABLE_IF(std::is_same<Char, wchar_t>::value)>
 void vprint(basic_string_view<Char> format_str, wformat_args args) {
   vprint(stdout, format_str, args);
 }
 
-#if FMT_USE_USER_DEFINED_LITERALS
+#if UMPIRE_FMT_USE_USER_DEFINED_LITERALS
 namespace detail {
 template <typename Char> struct udl_formatter {
   basic_string_view<Char> str;
@@ -4021,14 +4021,14 @@ constexpr detail::udl_arg<wchar_t> operator"" _a(const wchar_t* s, size_t) {
   return {s};
 }
 }  // namespace literals
-#endif  // FMT_USE_USER_DEFINED_LITERALS
-FMT_END_NAMESPACE
+#endif  // UMPIRE_FMT_USE_USER_DEFINED_LITERALS
+UMPIRE_FMT_END_NAMESPACE
 
-#ifdef FMT_HEADER_ONLY
-#  define FMT_FUNC inline
+#ifdef UMPIRE_FMT_HEADER_ONLY
+#  define UMPIRE_FMT_FUNC inline
 #  include "format-inl.h"
 #else
-#  define FMT_FUNC
+#  define UMPIRE_FMT_FUNC
 #endif
 
-#endif  // FMT_FORMAT_H_
+#endif  // UMPIRE_FMT_FORMAT_H_
diff --git a/src/tpl/umpire/fmt/locale.h b/src/tpl/umpire/fmt/locale.h
index ad1e2f616..866b0d0ca 100644
--- a/src/tpl/umpire/fmt/locale.h
+++ b/src/tpl/umpire/fmt/locale.h
@@ -5,14 +5,14 @@
 //
 // For the license information refer to format.h.
 
-#ifndef FMT_LOCALE_H_
-#define FMT_LOCALE_H_
+#ifndef UMPIRE_FMT_LOCALE_H_
+#define UMPIRE_FMT_LOCALE_H_
 
 #include <locale>
 
 #include "format.h"
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 
 namespace detail {
 template <typename Char>
@@ -41,7 +41,7 @@ inline std::basic_string<Char> format(const std::locale& loc,
 
 template <typename S, typename OutputIt, typename... Args,
           typename Char = char_t<S>,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value)>
+          UMPIRE_FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value)>
 inline OutputIt vformat_to(
     OutputIt out, const std::locale& loc, const S& format_str,
     basic_format_args<buffer_context<type_identity_t<Char>>> args) {
@@ -59,6 +59,6 @@ inline auto format_to(OutputIt out, const std::locale& loc, const S& format_str,
   return vformat_to(out, loc, to_string_view(format_str), vargs);
 }
 
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_LOCALE_H_
+#endif  // UMPIRE_FMT_LOCALE_H_
diff --git a/src/tpl/umpire/fmt/os.h b/src/tpl/umpire/fmt/os.h
index 7e0947ec6..d7a5eb37e 100644
--- a/src/tpl/umpire/fmt/os.h
+++ b/src/tpl/umpire/fmt/os.h
@@ -5,8 +5,8 @@
 //
 // For the license information refer to format.h.
 
-#ifndef FMT_OS_H_
-#define FMT_OS_H_
+#ifndef UMPIRE_FMT_OS_H_
+#define UMPIRE_FMT_OS_H_
 
 #include <cerrno>
 #include <clocale>  // for locale_t
@@ -21,54 +21,54 @@
 #include "format.h"
 
 // UWP doesn't provide _pipe.
-#if FMT_HAS_INCLUDE("winapifamily.h")
+#if UMPIRE_FMT_HAS_INCLUDE("winapifamily.h")
 #  include <winapifamily.h>
 #endif
-#if (FMT_HAS_INCLUDE(<fcntl.h>) || defined(__APPLE__) || \
+#if (UMPIRE_FMT_HAS_INCLUDE(<fcntl.h>) || defined(__APPLE__) || \
      defined(__linux__)) &&                              \
     (!defined(WINAPI_FAMILY) || (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP))
 #  include <fcntl.h>  // for O_RDONLY
-#  define FMT_USE_FCNTL 1
+#  define UMPIRE_FMT_USE_FCNTL 1
 #else
-#  define FMT_USE_FCNTL 0
+#  define UMPIRE_FMT_USE_FCNTL 0
 #endif
 
-#ifndef FMT_POSIX
+#ifndef UMPIRE_FMT_POSIX
 #  if defined(_WIN32) && !defined(__MINGW32__)
 // Fix warnings about deprecated symbols.
-#    define FMT_POSIX(call) _##call
+#    define UMPIRE_FMT_POSIX(call) _##call
 #  else
-#    define FMT_POSIX(call) call
+#    define UMPIRE_FMT_POSIX(call) call
 #  endif
 #endif
 
-// Calls to system functions are wrapped in FMT_SYSTEM for testability.
-#ifdef FMT_SYSTEM
-#  define FMT_POSIX_CALL(call) FMT_SYSTEM(call)
+// Calls to system functions are wrapped in UMPIRE_FMT_SYSTEM for testability.
+#ifdef UMPIRE_FMT_SYSTEM
+#  define UMPIRE_FMT_POSIX_CALL(call) UMPIRE_FMT_SYSTEM(call)
 #else
-#  define FMT_SYSTEM(call) ::call
+#  define UMPIRE_FMT_SYSTEM(call) ::call
 #  ifdef _WIN32
 // Fix warnings about deprecated symbols.
-#    define FMT_POSIX_CALL(call) ::_##call
+#    define UMPIRE_FMT_POSIX_CALL(call) ::_##call
 #  else
-#    define FMT_POSIX_CALL(call) ::call
+#    define UMPIRE_FMT_POSIX_CALL(call) ::call
 #  endif
 #endif
 
 // Retries the expression while it evaluates to error_result and errno
 // equals to EINTR.
 #ifndef _WIN32
-#  define FMT_RETRY_VAL(result, expression, error_result) \
+#  define UMPIRE_FMT_RETRY_VAL(result, expression, error_result) \
     do {                                                  \
       (result) = (expression);                            \
     } while ((result) == (error_result) && errno == EINTR)
 #else
-#  define FMT_RETRY_VAL(result, expression, error_result) result = (expression)
+#  define UMPIRE_FMT_RETRY_VAL(result, expression, error_result) result = (expression)
 #endif
 
-#define FMT_RETRY(result, expression) FMT_RETRY_VAL(result, expression, -1)
+#define UMPIRE_FMT_RETRY(result, expression) UMPIRE_FMT_RETRY_VAL(result, expression, -1)
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 
 /**
   \rst
@@ -123,9 +123,9 @@ class error_code {
   int value_;
 
  public:
-  explicit error_code(int value = 0) FMT_NOEXCEPT : value_(value) {}
+  explicit error_code(int value = 0) UMPIRE_FMT_NOEXCEPT : value_(value) {}
 
-  int get() const FMT_NOEXCEPT { return value_; }
+  int get() const UMPIRE_FMT_NOEXCEPT { return value_; }
 };
 
 #ifdef _WIN32
@@ -138,7 +138,7 @@ class utf16_to_utf8 {
 
  public:
   utf16_to_utf8() {}
-  FMT_API explicit utf16_to_utf8(wstring_view s);
+  UMPIRE_FMT_API explicit utf16_to_utf8(wstring_view s);
   operator string_view() const { return string_view(&buffer_[0], size()); }
   size_t size() const { return buffer_.size() - 1; }
   const char* c_str() const { return &buffer_[0]; }
@@ -147,17 +147,17 @@ class utf16_to_utf8 {
   // Performs conversion returning a system error code instead of
   // throwing exception on conversion error. This method may still throw
   // in case of memory allocation error.
-  FMT_API int convert(wstring_view s);
+  UMPIRE_FMT_API int convert(wstring_view s);
 };
 
-FMT_API void format_windows_error(buffer<char>& out, int error_code,
-                                  string_view message) FMT_NOEXCEPT;
+UMPIRE_FMT_API void format_windows_error(buffer<char>& out, int error_code,
+                                  string_view message) UMPIRE_FMT_NOEXCEPT;
 }  // namespace detail
 
 /** A Windows error. */
 class windows_error : public system_error {
  private:
-  FMT_API void init(int error_code, string_view format_str, format_args args);
+  UMPIRE_FMT_API void init(int error_code, string_view format_str, format_args args);
 
  public:
   /**
@@ -196,8 +196,8 @@ class windows_error : public system_error {
 
 // Reports a Windows error without throwing an exception.
 // Can be used to report errors from destructors.
-FMT_API void report_windows_error(int error_code,
-                                  string_view message) FMT_NOEXCEPT;
+UMPIRE_FMT_API void report_windows_error(int error_code,
+                                  string_view message) UMPIRE_FMT_NOEXCEPT;
 #endif  // _WIN32
 
 // A buffered file.
@@ -214,13 +214,13 @@ class buffered_file {
   void operator=(const buffered_file&) = delete;
 
   // Constructs a buffered_file object which doesn't represent any file.
-  buffered_file() FMT_NOEXCEPT : file_(nullptr) {}
+  buffered_file() UMPIRE_FMT_NOEXCEPT : file_(nullptr) {}
 
   // Destroys the object closing the file it represents if any.
-  FMT_API ~buffered_file() FMT_NOEXCEPT;
+  UMPIRE_FMT_API ~buffered_file() UMPIRE_FMT_NOEXCEPT;
 
  public:
-  buffered_file(buffered_file&& other) FMT_NOEXCEPT : file_(other.file_) {
+  buffered_file(buffered_file&& other) UMPIRE_FMT_NOEXCEPT : file_(other.file_) {
     other.file_ = nullptr;
   }
 
@@ -232,17 +232,17 @@ class buffered_file {
   }
 
   // Opens a file.
-  FMT_API buffered_file(cstring_view filename, cstring_view mode);
+  UMPIRE_FMT_API buffered_file(cstring_view filename, cstring_view mode);
 
   // Closes the file.
-  FMT_API void close();
+  UMPIRE_FMT_API void close();
 
   // Returns the pointer to a FILE object representing this file.
-  FILE* get() const FMT_NOEXCEPT { return file_; }
+  FILE* get() const UMPIRE_FMT_NOEXCEPT { return file_; }
 
   // We place parentheses around fileno to workaround a bug in some versions
   // of MinGW that define fileno as a macro.
-  FMT_API int(fileno)() const;
+  UMPIRE_FMT_API int(fileno)() const;
 
   void vprint(string_view format_str, format_args args) {
     umpire::fmt::vprint(file_, format_str, args);
@@ -254,9 +254,9 @@ class buffered_file {
   }
 };
 
-#if FMT_USE_FCNTL
+#if UMPIRE_FMT_USE_FCNTL
 // A file. Closed file is represented by a file object with descriptor -1.
-// Methods that are not declared with FMT_NOEXCEPT may throw
+// Methods that are not declared with UMPIRE_FMT_NOEXCEPT may throw
 // umpire::fmt::system_error in case of failure. Note that some errors such as
 // closing the file multiple times will cause a crash on Windows rather
 // than an exception. You can get standard behavior by overriding the
@@ -271,27 +271,27 @@ class file {
  public:
   // Possible values for the oflag argument to the constructor.
   enum {
-    RDONLY = FMT_POSIX(O_RDONLY),  // Open for reading only.
-    WRONLY = FMT_POSIX(O_WRONLY),  // Open for writing only.
-    RDWR = FMT_POSIX(O_RDWR),      // Open for reading and writing.
-    CREATE = FMT_POSIX(O_CREAT),   // Create if the file doesn't exist.
-    APPEND = FMT_POSIX(O_APPEND),  // Open in append mode.
-    TRUNC = FMT_POSIX(O_TRUNC)     // Truncate the content of the file.
+    RDONLY = UMPIRE_FMT_POSIX(O_RDONLY),  // Open for reading only.
+    WRONLY = UMPIRE_FMT_POSIX(O_WRONLY),  // Open for writing only.
+    RDWR = UMPIRE_FMT_POSIX(O_RDWR),      // Open for reading and writing.
+    CREATE = UMPIRE_FMT_POSIX(O_CREAT),   // Create if the file doesn't exist.
+    APPEND = UMPIRE_FMT_POSIX(O_APPEND),  // Open in append mode.
+    TRUNC = UMPIRE_FMT_POSIX(O_TRUNC)     // Truncate the content of the file.
   };
 
   // Constructs a file object which doesn't represent any file.
-  file() FMT_NOEXCEPT : fd_(-1) {}
+  file() UMPIRE_FMT_NOEXCEPT : fd_(-1) {}
 
   // Opens a file and constructs a file object representing this file.
-  FMT_API file(cstring_view path, int oflag);
+  UMPIRE_FMT_API file(cstring_view path, int oflag);
 
  public:
   file(const file&) = delete;
   void operator=(const file&) = delete;
 
-  file(file&& other) FMT_NOEXCEPT : fd_(other.fd_) { other.fd_ = -1; }
+  file(file&& other) UMPIRE_FMT_NOEXCEPT : fd_(other.fd_) { other.fd_ = -1; }
 
-  file& operator=(file&& other) FMT_NOEXCEPT {
+  file& operator=(file&& other) UMPIRE_FMT_NOEXCEPT {
     close();
     fd_ = other.fd_;
     other.fd_ = -1;
@@ -299,43 +299,43 @@ class file {
   }
 
   // Destroys the object closing the file it represents if any.
-  FMT_API ~file() FMT_NOEXCEPT;
+  UMPIRE_FMT_API ~file() UMPIRE_FMT_NOEXCEPT;
 
   // Returns the file descriptor.
-  int descriptor() const FMT_NOEXCEPT { return fd_; }
+  int descriptor() const UMPIRE_FMT_NOEXCEPT { return fd_; }
 
   // Closes the file.
-  FMT_API void close();
+  UMPIRE_FMT_API void close();
 
   // Returns the file size. The size has signed type for consistency with
   // stat::st_size.
-  FMT_API long long size() const;
+  UMPIRE_FMT_API long long size() const;
 
   // Attempts to read count bytes from the file into the specified buffer.
-  FMT_API size_t read(void* buffer, size_t count);
+  UMPIRE_FMT_API size_t read(void* buffer, size_t count);
 
   // Attempts to write count bytes from the specified buffer to the file.
-  FMT_API size_t write(const void* buffer, size_t count);
+  UMPIRE_FMT_API size_t write(const void* buffer, size_t count);
 
   // Duplicates a file descriptor with the dup function and returns
   // the duplicate as a file object.
-  FMT_API static file dup(int fd);
+  UMPIRE_FMT_API static file dup(int fd);
 
   // Makes fd be the copy of this file descriptor, closing fd first if
   // necessary.
-  FMT_API void dup2(int fd);
+  UMPIRE_FMT_API void dup2(int fd);
 
   // Makes fd be the copy of this file descriptor, closing fd first if
   // necessary.
-  FMT_API void dup2(int fd, error_code& ec) FMT_NOEXCEPT;
+  UMPIRE_FMT_API void dup2(int fd, error_code& ec) UMPIRE_FMT_NOEXCEPT;
 
   // Creates a pipe setting up read_end and write_end file objects for reading
   // and writing respectively.
-  FMT_API static void pipe(file& read_end, file& write_end);
+  UMPIRE_FMT_API static void pipe(file& read_end, file& write_end);
 
   // Creates a buffered_file object associated with this file and detaches
   // this file object from the file.
-  FMT_API buffered_file fdopen(const char* mode);
+  UMPIRE_FMT_API buffered_file fdopen(const char* mode);
 };
 
 // Returns the memory page size.
@@ -384,7 +384,7 @@ class ostream final : private detail::buffer<char> {
     clear();
   }
 
-  FMT_API void grow(size_t) override final;
+  UMPIRE_FMT_API void grow(size_t) override final;
 
   ostream(cstring_view path, const detail::ostream_params& params)
       : file_(path, params.oflag) {
@@ -440,9 +440,9 @@ template <typename... T>
 inline ostream output_file(cstring_view path, T... params) {
   return {path, detail::ostream_params(params...)};
 }
-#endif  // FMT_USE_FCNTL
+#endif  // UMPIRE_FMT_USE_FCNTL
 
-#ifdef FMT_LOCALE
+#ifdef UMPIRE_FMT_LOCALE
 // A "C" numeric locale.
 class locale {
  private:
@@ -465,11 +465,11 @@ class locale {
 
   locale() {
 #  ifndef _WIN32
-    locale_ = FMT_SYSTEM(newlocale(LC_NUMERIC_MASK, "C", nullptr));
+    locale_ = UMPIRE_FMT_SYSTEM(newlocale(LC_NUMERIC_MASK, "C", nullptr));
 #  else
     locale_ = _create_locale(LC_NUMERIC, "C");
 #  endif
-    if (!locale_) FMT_THROW(system_error(errno, "cannot create locale"));
+    if (!locale_) UMPIRE_FMT_THROW(system_error(errno, "cannot create locale"));
   }
   ~locale() { freelocale(locale_); }
 
@@ -484,8 +484,8 @@ class locale {
     return result;
   }
 };
-using Locale FMT_DEPRECATED_ALIAS = locale;
-#endif  // FMT_LOCALE
-FMT_END_NAMESPACE
+using Locale UMPIRE_FMT_DEPRECATED_ALIAS = locale;
+#endif  // UMPIRE_FMT_LOCALE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_OS_H_
+#endif  // UMPIRE_FMT_OS_H_
diff --git a/src/tpl/umpire/fmt/ostream.h b/src/tpl/umpire/fmt/ostream.h
index c6ecdf0c2..9effeb016 100644
--- a/src/tpl/umpire/fmt/ostream.h
+++ b/src/tpl/umpire/fmt/ostream.h
@@ -5,14 +5,14 @@
 //
 // For the license information refer to format.h.
 
-#ifndef FMT_OSTREAM_H_
-#define FMT_OSTREAM_H_
+#ifndef UMPIRE_FMT_OSTREAM_H_
+#define UMPIRE_FMT_OSTREAM_H_
 
 #include <ostream>
 
 #include "format.h"
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 
 template <typename Char> class basic_printf_parse_context;
 template <typename OutputIt, typename Char> class basic_printf_context;
@@ -37,20 +37,20 @@ template <class Char> class formatbuf : public std::basic_streambuf<Char> {
   // to overflow. There is no disadvantage here for sputn since this always
   // results in a call to xsputn.
 
-  int_type overflow(int_type ch = traits_type::eof()) FMT_OVERRIDE {
+  int_type overflow(int_type ch = traits_type::eof()) UMPIRE_FMT_OVERRIDE {
     if (!traits_type::eq_int_type(ch, traits_type::eof()))
       buffer_.push_back(static_cast<Char>(ch));
     return ch;
   }
 
-  std::streamsize xsputn(const Char* s, std::streamsize count) FMT_OVERRIDE {
+  std::streamsize xsputn(const Char* s, std::streamsize count) UMPIRE_FMT_OVERRIDE {
     buffer_.append(s, s + count);
     return count;
   }
 };
 
 struct converter {
-  template <typename T, FMT_ENABLE_IF(is_integral<T>::value)> converter(T);
+  template <typename T, UMPIRE_FMT_ENABLE_IF(is_integral<T>::value)> converter(T);
 };
 
 template <typename Char> struct test_stream : std::basic_ostream<Char> {
@@ -110,7 +110,7 @@ void format_value(buffer<Char>& buf, const T& value,
                   locale_ref loc = locale_ref()) {
   formatbuf<Char> format_buf(buf);
   std::basic_ostream<Char> output(&format_buf);
-#if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
+#if !defined(UMPIRE_FMT_STATIC_THOUSANDS_SEPARATOR)
   if (loc) output.imbue(loc.get<std::locale>());
 #endif
   output << value;
@@ -122,12 +122,12 @@ void format_value(buffer<Char>& buf, const T& value,
 template <typename T, typename Char>
 struct fallback_formatter<T, Char, enable_if_t<is_streamable<T, Char>::value>>
     : private formatter<basic_string_view<Char>, Char> {
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
+  UMPIRE_FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
       -> decltype(ctx.begin()) {
     return formatter<basic_string_view<Char>, Char>::parse(ctx);
   }
   template <typename ParseCtx,
-            FMT_ENABLE_IF(std::is_same<
+            UMPIRE_FMT_ENABLE_IF(std::is_same<
                           ParseCtx, basic_printf_parse_context<Char>>::value)>
   auto parse(ParseCtx& ctx) -> decltype(ctx.begin()) {
     return ctx.begin();
@@ -174,6 +174,6 @@ void print(std::basic_ostream<Char>& os, const S& format_str, Args&&... args) {
   vprint(os, to_string_view(format_str),
          umpire::fmt::make_args_checked<Args...>(format_str, args...));
 }
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_OSTREAM_H_
+#endif  // UMPIRE_FMT_OSTREAM_H_
diff --git a/src/tpl/umpire/fmt/printf.h b/src/tpl/umpire/fmt/printf.h
index 3b4ec5412..50ceeb423 100644
--- a/src/tpl/umpire/fmt/printf.h
+++ b/src/tpl/umpire/fmt/printf.h
@@ -5,15 +5,15 @@
 //
 // For the license information refer to format.h.
 
-#ifndef FMT_PRINTF_H_
-#define FMT_PRINTF_H_
+#ifndef UMPIRE_FMT_PRINTF_H_
+#define UMPIRE_FMT_PRINTF_H_
 
 #include <algorithm>  // std::max
 #include <limits>     // std::numeric_limits
 
 #include "ostream.h"
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 namespace detail {
 
 // Checks if a value fits in int - used to avoid warnings about comparing
@@ -36,16 +36,16 @@ template <> struct int_checker<true> {
 
 class printf_precision_handler {
  public:
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_integral<T>::value)>
   int operator()(T value) {
     if (!int_checker<std::numeric_limits<T>::is_signed>::fits_in_int(value))
-      FMT_THROW(format_error("number is too big"));
+      UMPIRE_FMT_THROW(format_error("number is too big"));
     return (std::max)(static_cast<int>(value), 0);
   }
 
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(!std::is_integral<T>::value)>
   int operator()(T) {
-    FMT_THROW(format_error("precision is not integer"));
+    UMPIRE_FMT_THROW(format_error("precision is not integer"));
     return 0;
   }
 };
@@ -53,12 +53,12 @@ class printf_precision_handler {
 // An argument visitor that returns true iff arg is a zero integer.
 class is_zero_int {
  public:
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_integral<T>::value)>
   bool operator()(T value) {
     return value == 0;
   }
 
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(!std::is_integral<T>::value)>
   bool operator()(T) {
     return false;
   }
@@ -83,7 +83,7 @@ template <typename T, typename Context> class arg_converter {
     if (type_ != 's') operator()<bool>(value);
   }
 
-  template <typename U, FMT_ENABLE_IF(std::is_integral<U>::value)>
+  template <typename U, UMPIRE_FMT_ENABLE_IF(std::is_integral<U>::value)>
   void operator()(U value) {
     bool is_signed = type_ == 'd' || type_ == 'i';
     using target_type = conditional_t<std::is_same<T, void>::value, U, T>;
@@ -110,7 +110,7 @@ template <typename T, typename Context> class arg_converter {
     }
   }
 
-  template <typename U, FMT_ENABLE_IF(!std::is_integral<U>::value)>
+  template <typename U, UMPIRE_FMT_ENABLE_IF(!std::is_integral<U>::value)>
   void operator()(U) {}  // No conversion needed for non-integral types.
 };
 
@@ -131,13 +131,13 @@ template <typename Context> class char_converter {
  public:
   explicit char_converter(basic_format_arg<Context>& arg) : arg_(arg) {}
 
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_integral<T>::value)>
   void operator()(T value) {
     arg_ = detail::make_arg<Context>(
         static_cast<typename Context::char_type>(value));
   }
 
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(!std::is_integral<T>::value)>
   void operator()(T) {}  // No conversion needed for non-integral types.
 };
 
@@ -159,7 +159,7 @@ template <typename Char> class printf_width_handler {
  public:
   explicit printf_width_handler(format_specs& specs) : specs_(specs) {}
 
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_integral<T>::value)>
   unsigned operator()(T value) {
     auto width = static_cast<uint32_or_64_or_128_t<T>>(value);
     if (detail::is_negative(value)) {
@@ -167,13 +167,13 @@ template <typename Char> class printf_width_handler {
       width = 0 - width;
     }
     unsigned int_max = max_value<int>();
-    if (width > int_max) FMT_THROW(format_error("number is too big"));
+    if (width > int_max) UMPIRE_FMT_THROW(format_error("number is too big"));
     return static_cast<unsigned>(width);
   }
 
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(!std::is_integral<T>::value)>
   unsigned operator()(T) {
-    FMT_THROW(format_error("width is not integer"));
+    UMPIRE_FMT_THROW(format_error("width is not integer"));
     return 0;
   }
 };
@@ -187,7 +187,7 @@ void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
 
 // For printing into memory_buffer.
 template <typename Char, typename Context>
-FMT_DEPRECATED void printf(detail::buffer<Char>& buf,
+UMPIRE_FMT_DEPRECATED void printf(detail::buffer<Char>& buf,
                            basic_string_view<Char> format,
                            basic_format_args<Context> args) {
   return detail::vprintf(buf, format, args);
@@ -227,7 +227,7 @@ class printf_arg_formatter : public detail::arg_formatter_base<OutputIt, Char> {
 
   OutputIt operator()(monostate value) { return base::operator()(value); }
 
-  template <typename T, FMT_ENABLE_IF(umpire::fmt::detail::is_integral<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(umpire::fmt::detail::is_integral<T>::value)>
   OutputIt operator()(T value) {
     // MSVC2013 fails to compile separate overloads for bool and Char so use
     // std::is_same instead.
@@ -247,7 +247,7 @@ class printf_arg_formatter : public detail::arg_formatter_base<OutputIt, Char> {
     return base::operator()(value);
   }
 
-  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
+  template <typename T, UMPIRE_FMT_ENABLE_IF(std::is_floating_point<T>::value)>
   OutputIt operator()(T value) {
     return base::operator()(value);
   }
@@ -344,7 +344,7 @@ template <typename OutputIt, typename Char> class basic_printf_context {
 
   parse_context_type& parse_context() { return parse_ctx_; }
 
-  FMT_CONSTEXPR void on_error(const char* message) {
+  UMPIRE_FMT_CONSTEXPR void on_error(const char* message) {
     parse_ctx_.on_error(message);
   }
 
@@ -542,7 +542,7 @@ OutputIt basic_printf_context<OutputIt, Char>::format() {
     }
 
     // Parse type.
-    if (it == end) FMT_THROW(format_error("invalid format string"));
+    if (it == end) UMPIRE_FMT_THROW(format_error("invalid format string"));
     specs.type = static_cast<char>(*it++);
     if (arg.is_integral()) {
       // Normalize type.
@@ -672,7 +672,7 @@ inline int vprintf(
   \endrst
  */
 template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_string<S>::value)>
+          UMPIRE_FMT_ENABLE_IF(detail::is_string<S>::value)>
 inline int printf(const S& format_str, const Args&... args) {
   using context = basic_printf_context_t<char_t<S>>;
   return vprintf(to_string_view(format_str),
@@ -717,6 +717,6 @@ inline int fprintf(std::basic_ostream<Char>& os, const S& format_str,
   return vfprintf(os, to_string_view(format_str),
                   make_format_args<context>(args...));
 }
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_PRINTF_H_
+#endif  // UMPIRE_FMT_PRINTF_H_
diff --git a/src/tpl/umpire/fmt/ranges.h b/src/tpl/umpire/fmt/ranges.h
index 88983d92e..af912d3e9 100644
--- a/src/tpl/umpire/fmt/ranges.h
+++ b/src/tpl/umpire/fmt/ranges.h
@@ -9,8 +9,8 @@
 // All Rights Reserved
 // {fmt} support for ranges, containers and types tuple interface.
 
-#ifndef FMT_RANGES_H_
-#define FMT_RANGES_H_
+#ifndef UMPIRE_FMT_RANGES_H_
+#define UMPIRE_FMT_RANGES_H_
 
 #include <initializer_list>
 #include <type_traits>
@@ -18,23 +18,23 @@
 #include "format.h"
 
 // output only up to N items from the range.
-#ifndef FMT_RANGE_OUTPUT_LENGTH_LIMIT
-#  define FMT_RANGE_OUTPUT_LENGTH_LIMIT 256
+#ifndef UMPIRE_FMT_RANGE_OUTPUT_LENGTH_LIMIT
+#  define UMPIRE_FMT_RANGE_OUTPUT_LENGTH_LIMIT 256
 #endif
 
-FMT_BEGIN_NAMESPACE
+UMPIRE_FMT_BEGIN_NAMESPACE
 
 template <typename Char> struct formatting_base {
   template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  UMPIRE_FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
     return ctx.begin();
   }
 };
 
 template <typename Char, typename Enable = void>
 struct formatting_range : formatting_base<Char> {
-  static FMT_CONSTEXPR_DECL const size_t range_length_limit =
-      FMT_RANGE_OUTPUT_LENGTH_LIMIT;  // output only up to N items from the
+  static UMPIRE_FMT_CONSTEXPR_DECL const size_t range_length_limit =
+      UMPIRE_FMT_RANGE_OUTPUT_LENGTH_LIMIT;  // output only up to N items from the
                                       // range.
   Char prefix = '{';
   Char postfix = '}';
@@ -75,7 +75,7 @@ template <typename T> class is_like_std_string {
   template <typename> static void check(...);
 
  public:
-  static FMT_CONSTEXPR_DECL const bool value =
+  static UMPIRE_FMT_CONSTEXPR_DECL const bool value =
       is_string<T>::value || !std::is_void<decltype(check<T>(nullptr))>::value;
 };
 
@@ -86,9 +86,9 @@ template <typename... Ts> struct conditional_helper {};
 
 template <typename T, typename _ = void> struct is_range_ : std::false_type {};
 
-#if !FMT_MSC_VER || FMT_MSC_VER > 1800
+#if !UMPIRE_FMT_MSC_VER || UMPIRE_FMT_MSC_VER > 1800
 
-#  define FMT_DECLTYPE_RETURN(val)  \
+#  define UMPIRE_FMT_DECLTYPE_RETURN(val)  \
     ->decltype(val) { return val; } \
     static_assert(                  \
         true, "")  // This makes it so that a semicolon is required after the
@@ -114,9 +114,9 @@ struct has_member_fn_begin_end_t<T, void_t<decltype(std::declval<T>().begin()),
 
 // Member function overload
 template <typename T>
-auto range_begin(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).begin());
+auto range_begin(T&& rng) UMPIRE_FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).begin());
 template <typename T>
-auto range_end(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).end());
+auto range_end(T&& rng) UMPIRE_FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).end());
 
 // ADL overload. Only participates in overload resolution if member functions
 // are not found.
@@ -163,8 +163,8 @@ struct range_to_view<T, enable_if_t<has_const_begin_end<T>::value>> {
   struct view_t {
     const T* m_range_ptr;
 
-    auto begin() const FMT_DECLTYPE_RETURN(detail::range_begin(*m_range_ptr));
-    auto end() const FMT_DECLTYPE_RETURN(detail::range_end(*m_range_ptr));
+    auto begin() const UMPIRE_FMT_DECLTYPE_RETURN(detail::range_begin(*m_range_ptr));
+    auto end() const UMPIRE_FMT_DECLTYPE_RETURN(detail::range_end(*m_range_ptr));
   };
   static auto view(const T& range) -> view_t { return {&range}; }
 };
@@ -175,12 +175,12 @@ struct range_to_view<T, enable_if_t<!has_const_begin_end<T>::value &&
   struct view_t {
     T m_range_copy;
 
-    auto begin() FMT_DECLTYPE_RETURN(detail::range_begin(m_range_copy));
-    auto end() FMT_DECLTYPE_RETURN(detail::range_end(m_range_copy));
+    auto begin() UMPIRE_FMT_DECLTYPE_RETURN(detail::range_begin(m_range_copy));
+    auto end() UMPIRE_FMT_DECLTYPE_RETURN(detail::range_end(m_range_copy));
   };
   static auto view(const T& range) -> view_t { return {range}; }
 };
-#  undef FMT_DECLTYPE_RETURN
+#  undef UMPIRE_FMT_DECLTYPE_RETURN
 #endif
 
 /// tuple_size and tuple_element check.
@@ -190,12 +190,12 @@ template <typename T> class is_tuple_like_ {
   template <typename> static void check(...);
 
  public:
-  static FMT_CONSTEXPR_DECL const bool value =
+  static UMPIRE_FMT_CONSTEXPR_DECL const bool value =
       !std::is_void<decltype(check<T>(nullptr))>::value;
 };
 
 // Check for integer_sequence
-#if defined(__cpp_lib_integer_sequence) || FMT_MSC_VER >= 1900
+#if defined(__cpp_lib_integer_sequence) || UMPIRE_FMT_MSC_VER >= 1900
 template <typename T, T... N>
 using integer_sequence = std::integer_sequence<T, N...>;
 template <size_t... N> using index_sequence = std::index_sequence<N...>;
@@ -204,7 +204,7 @@ template <size_t N> using make_index_sequence = std::make_index_sequence<N>;
 template <typename T, T... N> struct integer_sequence {
   using value_type = T;
 
-  static FMT_CONSTEXPR size_t size() { return sizeof...(N); }
+  static UMPIRE_FMT_CONSTEXPR size_t size() { return sizeof...(N); }
 };
 
 template <size_t... N> using index_sequence = integer_sequence<size_t, N...>;
@@ -219,7 +219,7 @@ using make_index_sequence = make_integer_sequence<size_t, N>;
 #endif
 
 template <class Tuple, class F, size_t... Is>
-void for_each(index_sequence<Is...>, Tuple&& tup, F&& f) FMT_NOEXCEPT {
+void for_each(index_sequence<Is...>, Tuple&& tup, F&& f) UMPIRE_FMT_NOEXCEPT {
   using std::get;
   // using free function get<I>(T) now.
   const int _[] = {0, ((void)f(get<Is>(tup)), 0)...};
@@ -227,7 +227,7 @@ void for_each(index_sequence<Is...>, Tuple&& tup, F&& f) FMT_NOEXCEPT {
 }
 
 template <class T>
-FMT_CONSTEXPR make_index_sequence<std::tuple_size<T>::value> get_indexes(
+UMPIRE_FMT_CONSTEXPR make_index_sequence<std::tuple_size<T>::value> get_indexes(
     T const&) {
   return {};
 }
@@ -249,7 +249,7 @@ template <typename OutputIt> OutputIt write_delimiter(OutputIt out) {
 
 template <
     typename Char, typename OutputIt, typename Arg,
-    FMT_ENABLE_IF(is_like_std_string<typename std::decay<Arg>::type>::value)>
+    UMPIRE_FMT_ENABLE_IF(is_like_std_string<typename std::decay<Arg>::type>::value)>
 OutputIt write_range_entry(OutputIt out, const Arg& v) {
   *out++ = '"';
   out = write<Char>(out, v);
@@ -258,7 +258,7 @@ OutputIt write_range_entry(OutputIt out, const Arg& v) {
 }
 
 template <typename Char, typename OutputIt, typename Arg,
-          FMT_ENABLE_IF(std::is_same<Arg, Char>::value)>
+          UMPIRE_FMT_ENABLE_IF(std::is_same<Arg, Char>::value)>
 OutputIt write_range_entry(OutputIt out, const Arg v) {
   *out++ = '\'';
   *out++ = v;
@@ -268,7 +268,7 @@ OutputIt write_range_entry(OutputIt out, const Arg v) {
 
 template <
     typename Char, typename OutputIt, typename Arg,
-    FMT_ENABLE_IF(!is_like_std_string<typename std::decay<Arg>::type>::value &&
+    UMPIRE_FMT_ENABLE_IF(!is_like_std_string<typename std::decay<Arg>::type>::value &&
                   !std::is_same<Arg, Char>::value)>
 OutputIt write_range_entry(OutputIt out, const Arg& v) {
   return write<Char>(out, v);
@@ -277,7 +277,7 @@ OutputIt write_range_entry(OutputIt out, const Arg& v) {
 }  // namespace detail
 
 template <typename T> struct is_tuple_like {
-  static FMT_CONSTEXPR_DECL const bool value =
+  static UMPIRE_FMT_CONSTEXPR_DECL const bool value =
       detail::is_tuple_like_<T>::value && !detail::is_range_<T>::value;
 };
 
@@ -301,7 +301,7 @@ struct formatter<TupleT, Char, enable_if_t<umpire::fmt::is_tuple_like<TupleT>::v
   formatting_tuple<Char> formatting;
 
   template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  UMPIRE_FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
     return formatting.parse(ctx);
   }
 
@@ -319,7 +319,7 @@ struct formatter<TupleT, Char, enable_if_t<umpire::fmt::is_tuple_like<TupleT>::v
 };
 
 template <typename T, typename Char> struct is_range {
-  static FMT_CONSTEXPR_DECL const bool value =
+  static UMPIRE_FMT_CONSTEXPR_DECL const bool value =
       detail::is_range_<T>::value && !detail::is_like_std_string<T>::value &&
       !std::is_convertible<T, std::basic_string<Char>>::value &&
       !std::is_constructible<detail::std_string_view<Char>, T>::value;
@@ -330,7 +330,7 @@ struct formatter<
     T, Char,
     enable_if_t<umpire::fmt::is_range<T, Char>::value
 // Workaround a bug in MSVC 2017 and earlier.
-#if !FMT_MSC_VER || FMT_MSC_VER >= 1927
+#if !UMPIRE_FMT_MSC_VER || UMPIRE_FMT_MSC_VER >= 1927
                 &&
                 (has_formatter<detail::value_type<T>, format_context>::value ||
                  detail::has_fallback_formatter<detail::value_type<T>,
@@ -340,7 +340,7 @@ struct formatter<
   formatting_range<Char> formatting;
 
   template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  UMPIRE_FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
     return formatting.parse(ctx);
   }
 
@@ -355,7 +355,7 @@ struct formatter<
       if (i > 0) out = detail::write_delimiter(out);
       out = detail::write_range_entry<Char>(out, *it);
       if (++i > formatting.range_length_limit) {
-        out = format_to(out, FMT_STRING("{}"), " ... <other elements>");
+        out = format_to(out, UMPIRE_FMT_STRING("{}"), " ... <other elements>");
         break;
       }
     }
@@ -374,7 +374,7 @@ template <typename Char, typename... T> struct tuple_arg_join : detail::view {
 template <typename Char, typename... T>
 struct formatter<tuple_arg_join<Char, T...>, Char> {
   template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  UMPIRE_FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
     return ctx.begin();
   }
 
@@ -428,13 +428,13 @@ struct formatter<tuple_arg_join<Char, T...>, Char> {
   \endrst
  */
 template <typename... T>
-FMT_CONSTEXPR tuple_arg_join<char, T...> join(const std::tuple<T...>& tuple,
+UMPIRE_FMT_CONSTEXPR tuple_arg_join<char, T...> join(const std::tuple<T...>& tuple,
                                               string_view sep) {
   return {tuple, sep};
 }
 
 template <typename... T>
-FMT_CONSTEXPR tuple_arg_join<wchar_t, T...> join(const std::tuple<T...>& tuple,
+UMPIRE_FMT_CONSTEXPR tuple_arg_join<wchar_t, T...> join(const std::tuple<T...>& tuple,
                                                  wstring_view sep) {
   return {tuple, sep};
 }
@@ -462,6 +462,6 @@ arg_join<const T*, const T*, wchar_t> join(std::initializer_list<T> list,
   return join(std::begin(list), std::end(list), sep);
 }
 
-FMT_END_NAMESPACE
+UMPIRE_FMT_END_NAMESPACE
 
-#endif  // FMT_RANGES_H_
+#endif  // UMPIRE_FMT_RANGES_H_
