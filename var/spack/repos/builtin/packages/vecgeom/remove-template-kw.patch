diff --git a/VecGeom/management/TransformationSpecializations.icc b/VecGeom/management/TransformationSpecializations.icc
index 783e8c379..247468b23 100644
--- a/VecGeom/management/TransformationSpecializations.icc
+++ b/VecGeom/management/TransformationSpecializations.icc
@@ -3,224 +3,224 @@
 
 #ifndef VECGEOM_NO_SPECIALIZATION
 if (trans_code == translation::kGeneric && rot_code == 0x1b1) {
-  return VolumeType::template Create<translation::kGeneric, 0x1b1>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x1b1>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x1b1) {
-  return VolumeType::template Create<translation::kIdentity, 0x1b1>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x1b1>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x18e) {
-  return VolumeType::template Create<translation::kGeneric, 0x18e>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x18e>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x18e) {
-  return VolumeType::template Create<translation::kIdentity, 0x18e>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x18e>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x076) {
-  return VolumeType::template Create<translation::kGeneric, 0x076>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x076>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x076) {
-  return VolumeType::template Create<translation::kIdentity, 0x076>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x076>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x16a) {
-  return VolumeType::template Create<translation::kGeneric, 0x16a>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x16a>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x16a) {
-  return VolumeType::template Create<translation::kIdentity, 0x16a>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x16a>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x155) {
-  return VolumeType::template Create<translation::kGeneric, 0x155>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x155>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x155) {
-  return VolumeType::template Create<translation::kIdentity, 0x155>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x155>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x0ad) {
-  return VolumeType::template Create<translation::kGeneric, 0x0ad>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x0ad>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x0ad) {
-  return VolumeType::template Create<translation::kIdentity, 0x0ad>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x0ad>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x0dc) {
-  return VolumeType::template Create<translation::kGeneric, 0x0dc>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x0dc>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x0dc) {
-  return VolumeType::template Create<translation::kIdentity, 0x0dc>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x0dc>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x0e3) {
-  return VolumeType::template Create<translation::kGeneric, 0x0e3>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x0e3>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x0e3) {
-  return VolumeType::template Create<translation::kIdentity, 0x0e3>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x0e3>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x11b) {
-  return VolumeType::template Create<translation::kGeneric, 0x11b>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x11b>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x11b) {
-  return VolumeType::template Create<translation::kIdentity, 0x11b>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x11b>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x0a1) {
-  return VolumeType::template Create<translation::kGeneric, 0x0a1>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x0a1>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x0a1) {
-  return VolumeType::template Create<translation::kIdentity, 0x0a1>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x0a1>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x10a) {
-  return VolumeType::template Create<translation::kGeneric, 0x10a>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x10a>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x10a) {
-  return VolumeType::template Create<translation::kIdentity, 0x10a>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x10a>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x046) {
-  return VolumeType::template Create<translation::kGeneric, 0x046>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x046>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x046) {
-  return VolumeType::template Create<translation::kIdentity, 0x046>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x046>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x062) {
-  return VolumeType::template Create<translation::kGeneric, 0x062>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x062>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x062) {
-  return VolumeType::template Create<translation::kIdentity, 0x062>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x062>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x054) {
-  return VolumeType::template Create<translation::kGeneric, 0x054>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x054>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x054) {
-  return VolumeType::template Create<translation::kIdentity, 0x054>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x054>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x111) {
-  return VolumeType::template Create<translation::kGeneric, 0x111>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x111>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x111) {
-  return VolumeType::template Create<translation::kIdentity, 0x111>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x111>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
                                                                     placement);
 }
 if (trans_code == translation::kGeneric && rot_code == 0x200) {
-  return VolumeType::template Create<translation::kGeneric, 0x200>(logical_volume, transformation,
+  return VolumeType Create<translation::kGeneric, 0x200>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                    id, copy_no, child_id,
 #endif
                                                                    placement);
 }
 if (trans_code == translation::kIdentity && rot_code == 0x200) {
-  return VolumeType::template Create<translation::kIdentity, 0x200>(logical_volume, transformation,
+  return VolumeType Create<translation::kIdentity, 0x200>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                     id, copy_no, child_id,
 #endif
@@ -228,7 +228,7 @@ if (trans_code == translation::kIdentity && rot_code == 0x200) {
 }
 #endif // No specialization
 
-return VolumeType::template Create<translation::kGeneric, rotation::kGeneric>(logical_volume, transformation,
+return VolumeType Create<translation::kGeneric, rotation::kGeneric>(logical_volume, transformation,
 #ifdef VECCORE_CUDA
                                                                               id, copy_no, child_id,
 #endif
diff --git a/VecGeom/navigation/NewSimpleNavigator.h b/VecGeom/navigation/NewSimpleNavigator.h
index 772d2f024..1a7d018e1 100644
--- a/VecGeom/navigation/NewSimpleNavigator.h
+++ b/VecGeom/navigation/NewSimpleNavigator.h
@@ -235,7 +235,7 @@ public:
                                           NavigationState const *const *in_states, unsigned int from_index,
                                           Precision *out_steps, VPlacedVolume const *hitcandidates[ChunkSize])
   {
-    NewSimpleNavigator<MotherIsConvex>::template DaughterIntersectionsLooper<T, ChunkSize>(
+    NewSimpleNavigator<MotherIsConvex> DaughterIntersectionsLooper<T, ChunkSize>(
         nav, lvol, localpoint, localdir, in_states, nullptr, from_index, out_steps, hitcandidates);
   }
 
diff --git a/VecGeom/navigation/VNavigator.h b/VecGeom/navigation/VNavigator.h
index 4d6d01c2b..60c32213d 100644
--- a/VecGeom/navigation/VNavigator.h
+++ b/VecGeom/navigation/VNavigator.h
@@ -609,16 +609,16 @@ public:
     VPlacedVolume const *hitcandidates[ChunkSize] = {}; // initialize all to nullptr
 
     Vector3D<T> localpoint, localdir;
-    Impl::template DoGlobalToLocalTransformations<T, ChunkSize>(in_states, globalpoints, globaldirs, from_index,
+    Impl DoGlobalToLocalTransformations<T, ChunkSize>(in_states, globalpoints, globaldirs, from_index,
                                                                 localpoint, localdir);
 
     T slimit(vecCore::FromPtr<T>(step_limits + from_index));
     // need to calc DistanceToOut first
-    T step = Impl::template TreatDistanceToMother<T>(pvol, localpoint, localdir, slimit);
+    T step = Impl TreatDistanceToMother<T>(pvol, localpoint, localdir, slimit);
     vecCore::Store(step, out_steps + from_index);
 
     // "suck in" algorithm from Impl and treat hit detection in local coordinates for daughters
-    Impl::template DaughterIntersectionsLooper<T, ChunkSize>(nav, lvol, localpoint, localdir, in_states, out_states,
+    Impl DaughterIntersectionsLooper<T, ChunkSize>(nav, lvol, localpoint, localdir, in_states, out_states,
                                                               from_index, out_steps, hitcandidates);
 
     // fix state ( seems to be serial so we iterate over indices )
@@ -661,19 +661,19 @@ public:
     VPlacedVolume const *hitcandidates[ChunkSize] = {}; // initialize all to nullptr
 
     Vector3D<T> localpoint, localdir;
-    Impl::template DoGlobalToLocalTransformations<T, ChunkSize>(in_states, globalpoints, globaldirs, from_index,
+    Impl DoGlobalToLocalTransformations<T, ChunkSize>(in_states, globalpoints, globaldirs, from_index,
                                                                 localpoint, localdir);
 
     // safety part
-    Impl::template SafetyLooper<T, ChunkSize>(nav, pvol, localpoint, from_index, calcsafeties, out_safeties);
+    Impl SafetyLooper<T, ChunkSize>(nav, pvol, localpoint, from_index, calcsafeties, out_safeties);
 
     T slimit(vecCore::FromPtr<T>(step_limits + from_index)); // will only work with new ScalarWrapper
     // need to calc DistanceToOut first
-    T step = Impl::template TreatDistanceToMother<T>(pvol, localpoint, localdir, slimit);
+    T step = Impl TreatDistanceToMother<T>(pvol, localpoint, localdir, slimit);
     vecCore::Store(step, out_steps + from_index);
 
     // "suck in" algorithm from Impl and treat hit detection in local coordinates for daughters
-    Impl::template DaughterIntersectionsLooper<T, ChunkSize>(nav, lvol, localpoint, localdir, in_states, out_states,
+    Impl DaughterIntersectionsLooper<T, ChunkSize>(nav, lvol, localpoint, localdir, in_states, out_states,
                                                               from_index, out_steps, hitcandidates);
 
     using vecCore::LaneAt;
@@ -715,19 +715,19 @@ public:
     VPlacedVolume const *hitcandidates[ChunkSize] = {}; // initialize all to nullptr
 
     Vector3D<T> localpoint, localdir;
-    Impl::template DoGlobalToLocalTransformations<T, ChunkSize>(in_states, globalpoints, globaldirs, from_index,
+    Impl DoGlobalToLocalTransformations<T, ChunkSize>(in_states, globalpoints, globaldirs, from_index,
                                                                 localpoint, localdir);
 
     // safety part
-    Impl::template SafetyLooper<T, ChunkSize>(nav, pvol, localpoint, from_index, calcsafeties, out_safeties);
+    Impl SafetyLooper<T, ChunkSize>(nav, pvol, localpoint, from_index, calcsafeties, out_safeties);
 
     T slimit(vecCore::FromPtr<T>(step_limits + from_index)); // will only work with new ScalarWrapper
     // need to calc DistanceToOut first
-    T step = Impl::template TreatDistanceToMother<T>(pvol, localpoint, localdir, slimit);
+    T step = Impl TreatDistanceToMother<T>(pvol, localpoint, localdir, slimit);
     vecCore::Store(step, out_steps + from_index);
 
     // "suck in" algorithm from Impl and treat hit detection in local coordinates for daughters
-    Impl::template DaughterIntersectionsLooper<T, ChunkSize>(nav, lvol, localpoint, localdir, in_states, out_states,
+    Impl DaughterIntersectionsLooper<T, ChunkSize>(nav, lvol, localpoint, localdir, in_states, out_states,
                                                               from_index, out_steps, hitcandidates);
 
     using vecCore::LaneAt;
@@ -771,19 +771,19 @@ public:
     VPlacedVolume const *hitcandidates[ChunkSize] = {}; // initialize all to nullptr
 
     Vector3D<T> localpoint, localdir;
-    Impl::template DoGlobalToLocalTransformations<T, ChunkSize>(in_states, globalpoints, globaldirs, from_index,
+    Impl DoGlobalToLocalTransformations<T, ChunkSize>(in_states, globalpoints, globaldirs, from_index,
                                                                 localpoint, localdir);
 
     // safety part
-    Impl::template SafetyLooper<T, ChunkSize>(nav, pvol, localpoint, from_index, calcsafeties, out_safeties);
+    Impl SafetyLooper<T, ChunkSize>(nav, pvol, localpoint, from_index, calcsafeties, out_safeties);
 
     T slimit(vecCore::FromPtr<T>(step_limits + from_index));
     // need to calc DistanceToOut first
-    T step = Impl::template TreatDistanceToMother<T>(pvol, localpoint, localdir, slimit);
+    T step = Impl TreatDistanceToMother<T>(pvol, localpoint, localdir, slimit);
     vecCore::Store(step, out_steps + from_index);
 
     // "suck in" algorithm from Impl and treat hit detection in local coordinates for daughters
-    Impl::template DaughterIntersectionsLooper<T, ChunkSize>(nav, lvol, localpoint, localdir, in_states, from_index,
+    Impl DaughterIntersectionsLooper<T, ChunkSize>(nav, lvol, localpoint, localdir, in_states, from_index,
                                                               out_steps, hitcandidates);
   }
 
diff --git a/VecGeom/volumes/Quadrilaterals.h b/VecGeom/volumes/Quadrilaterals.h
index 99045d055..17bdd9313 100644
--- a/VecGeom/volumes/Quadrilaterals.h
+++ b/VecGeom/volumes/Quadrilaterals.h
@@ -375,7 +375,7 @@ VECCORE_ATT_HOST_DEVICE Real_v Quadrilaterals::DistanceToIn(Vector3D<Real_v> con
 
   int i       = 0;
   const int n = size();
-  AcceleratedDistanceToIn<Real_v>::template VectorLoop<behindPlanesT>(i, n, fPlanes, fSideVectors, point, direction,
+  AcceleratedDistanceToIn<Real_v> VectorLoop<behindPlanesT>(i, n, fPlanes, fSideVectors, point, direction,
                                                                       bestDistance);
 
   // TODO: IN CASE QUADRILATERALS ARE PERPENDICULAR TO Z WE COULD SAVE MANY DIVISIONS
diff --git a/VecGeom/volumes/SpecializedPlacedVolImplHelper.h b/VecGeom/volumes/SpecializedPlacedVolImplHelper.h
index 5f6397172..44fe7c3f3 100644
--- a/VecGeom/volumes/SpecializedPlacedVolImplHelper.h
+++ b/VecGeom/volumes/SpecializedPlacedVolImplHelper.h
@@ -153,7 +153,7 @@ public:
 #endif
     Transformation3D const *tr = this->GetTransformation();
     Precision output(-1.);
-    Specialization::template DistanceToOut(*this->GetUnplacedStruct(), tr->Transform<transC, rotC>(point),
+    Specialization DistanceToOut(*this->GetUnplacedStruct(), tr->Transform<transC, rotC>(point),
                                            tr->TransformDirection<rotC>(direction), stepMax, output);
 
 #ifdef VECGEOM_DISTANCE_DEBUG
@@ -193,7 +193,7 @@ static void ContainsLoopKernel(typename Specialization::UnplacedStruct_t const &
     Vector3D<Real_v> point(vecCore::FromPtr<Real_v>(points.x() + i), vecCore::FromPtr<Real_v>(points.y() + i),
                            vecCore::FromPtr<Real_v>(points.z() + i));
     Bool_v result(false);
-    Specialization::template Contains<Real_v>(shapestruct, trans.Transform<transC, rotC>(point), result);
+    Specialization Contains<Real_v>(shapestruct, trans.Transform<transC, rotC>(point), result);
     // vecCore::StoreMask(result, output);
     // StoreMask has problem -> see VECCORE-21
     for (size_t j = 0; j < vecCore::VectorSize<Real_v>(); ++j)
@@ -212,7 +212,7 @@ static void InsideLoopKernel(typename Specialization::UnplacedStruct_t const &sh
     Vector3D<Real_v> point(vecCore::FromPtr<Real_v>(points.x() + i), vecCore::FromPtr<Real_v>(points.y() + i),
                            vecCore::FromPtr<Real_v>(points.z() + i));
     Index_t result;
-    Specialization::template Inside<Real_v>(shapestruct, trans.Transform<transC, rotC>(point), result);
+    Specialization Inside<Real_v>(shapestruct, trans.Transform<transC, rotC>(point), result);
     // TODO: make a proper store here
     for (size_t j = 0; j < vecCore::VectorSize<Index_t>(); ++j)
       output[i + j] = vecCore::LaneAt<Index_t>(result, j);
@@ -230,7 +230,7 @@ static void SafetyToInLoopKernel(typename Specialization::UnplacedStruct_t const
     Vector3D<Real_v> point(vecCore::FromPtr<Real_v>(points.x() + i), vecCore::FromPtr<Real_v>(points.y() + i),
                            vecCore::FromPtr<Real_v>(points.z() + i));
     Real_v result(kInfLength);
-    Specialization::template SafetyToIn<Real_v>(shapestruct, trans.Transform<transC, rotC>(point), result);
+    Specialization SafetyToIn<Real_v>(shapestruct, trans.Transform<transC, rotC>(point), result);
     vecCore::Store(result, output + i);
   }
 }
@@ -250,7 +250,7 @@ static void DistanceToInLoopKernel(typename Specialization::UnplacedStruct_t con
                          vecCore::FromPtr<Real_v>(directions.z() + i));
     Real_v step_max(vecCore::FromPtr<Real_v>(stepMax + i));
     Real_v result(kInfLength);
-    Specialization::template DistanceToIn<Real_v>(shapestruct, trans.Transform<transC, rotC>(point),
+    Specialization DistanceToIn<Real_v>(shapestruct, trans.Transform<transC, rotC>(point),
                                                   trans.TransformDirection<rotC>(dir), step_max, result);
     vecCore::Store(result, output + i);
   }
@@ -317,7 +317,7 @@ public:
     Real_v output(kInfLength);
     Transformation3D const *tr = this->GetTransformation();
     auto unplacedstruct        = this->GetUnplacedStruct();
-    Specialization::template DistanceToIn<Real_v>(*unplacedstruct, tr->Transform<transC, rotC>(p),
+    Specialization DistanceToIn<Real_v>(*unplacedstruct, tr->Transform<transC, rotC>(p),
                                                   tr->TransformDirection<rotC>(d), step_max, output);
     return output;
   }
@@ -479,7 +479,7 @@ public:
       const Vector3D<Real_s> ps(LaneAt(p.x(), i), LaneAt(p.y(), i), LaneAt(p.z(), i)); // scalar vector
       const Vector3D<Real_s> ds(LaneAt(d.x(), i), LaneAt(d.y(), i), LaneAt(d.z(), i)); // scalar direction;
       Real_s tmp(-1.);
-      Specialization::template DistanceToIn<Real_s>(*unplacedstruct, tr->Transform<transC, rotC>(ps),
+      Specialization DistanceToIn<Real_s>(*unplacedstruct, tr->Transform<transC, rotC>(ps),
                                                     tr->TransformDirection<rotC>(ds), LaneAt(step_max, i), tmp);
       vecCore::AssignLane(output, i, tmp);
     }
diff --git a/VecGeom/volumes/UnplacedVolumeImplHelper.h b/VecGeom/volumes/UnplacedVolumeImplHelper.h
index 4b2f7b212..39f8ceb05 100644
--- a/VecGeom/volumes/UnplacedVolumeImplHelper.h
+++ b/VecGeom/volumes/UnplacedVolumeImplHelper.h
@@ -45,7 +45,7 @@ static void DistanceToOutLoop(typename Implementation::UnplacedStruct_t const *s
                          FromPtr<Real_v>(directions.z() + i));
     Real_v stepMax_v = FromPtr<Real_v>(&step_max[i]);
     Real_v result;
-    Implementation::template DistanceToOut<Real_v>(*shapestruct, point, dir, stepMax_v, result);
+    Implementation DistanceToOut<Real_v>(*shapestruct, point, dir, stepMax_v, result);
     vecCore::Store(result, &output[i]);
   }
 }
@@ -61,7 +61,7 @@ static void SafetyToOutLoop(typename Implementation::UnplacedStruct_t const *sha
     Vector3D<Real_v> point(FromPtr<Real_v>(points.x() + i), FromPtr<Real_v>(points.y() + i),
                            FromPtr<Real_v>(points.z() + i));
     Real_v result(kInfLength);
-    Implementation::template SafetyToOut<Real_v>(*shapestruct, point, result);
+    Implementation SafetyToOut<Real_v>(*shapestruct, point, result);
     vecCore::Store(result, &output[i]);
   }
 }
@@ -98,7 +98,7 @@ public:
     assert(d.IsNormalized() && " direction not normalized in call to  DistanceToOut ");
 #endif
     Precision output = kInfLength;
-    Implementation::template DistanceToOut(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), p, d, step_max,
+    Implementation DistanceToOut(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), p, d, step_max,
                                            output);
 
 // detect -inf responses which are often an indication for a real bug
@@ -193,7 +193,7 @@ public:
                                   Real_v const &step_max) const override
   {
     Real_v output;
-    Implementation::template DistanceToOut<Real_v>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), p, d,
+    Implementation DistanceToOut<Real_v>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), p, d,
                                                    step_max, output);
     return output;
   }
@@ -204,7 +204,7 @@ public:
                                  Real_v const &step_max) const override
   {
     Real_v output(kInfLength);
-    Implementation::template DistanceToIn<Real_v>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), p, d,
+    Implementation DistanceToIn<Real_v>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), p, d,
                                                   step_max, output);
     return output;
   }
@@ -214,7 +214,7 @@ public:
   virtual Real_v SafetyToOutVec(Vector3D<Real_v> const &p) const override
   {
     Real_v output(kInfLength);
-    Implementation::template SafetyToOut<Real_v>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), p, output);
+    Implementation SafetyToOut<Real_v>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), p, output);
     return output;
   }
 
@@ -223,7 +223,7 @@ public:
   virtual Real_v SafetyToInVec(Vector3D<Real_v> const &p) const override
   {
     Real_v output(kInfLength);
-    Implementation::template SafetyToIn<Real_v>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), p, output);
+    Implementation SafetyToIn<Real_v>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), p, output);
     return output;
   }
 
@@ -287,7 +287,7 @@ public:
       Vector3D<Real_s> ps(LaneAt(p.x(), i), LaneAt(p.y(), i), LaneAt(p.z(), i)); // scalar vector
       Vector3D<Real_s> ds(LaneAt(d.x(), i), LaneAt(d.y(), i), LaneAt(d.z(), i)); // scalar direction;
       Real_s result;
-      Implementation::template DistanceToOut<Real_s>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), ps, ds,
+      Implementation DistanceToOut<Real_s>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), ps, ds,
                                                      LaneAt(step_max, i), result);
       vecCore::AssignLane(output, i, result);
     }
@@ -306,7 +306,7 @@ public:
       Vector3D<Real_s> ps(LaneAt(p.x(), i), LaneAt(p.y(), i), LaneAt(p.z(), i)); // scalar vector
       Vector3D<Real_s> ds(LaneAt(d.x(), i), LaneAt(d.y(), i), LaneAt(d.z(), i)); // scalar direction;
       Real_s tmp(-1.);
-      Implementation::template DistanceToIn<Real_s>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), ps, ds,
+      Implementation DistanceToIn<Real_s>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), ps, ds,
                                                     LaneAt(step_max, i), tmp);
       vecCore::AssignLane(output, i, tmp);
     }
@@ -323,7 +323,7 @@ public:
     for (size_t i = 0; i < vecCore::VectorSize<Real_v>(); ++i) {
       Vector3D<Real_s> ps(LaneAt(p.x(), i), LaneAt(p.y(), i), LaneAt(p.z(), i)); // scalar vector
       Real_s tmp(kInfLength);
-      Implementation::template SafetyToOut<Real_s>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), ps, tmp);
+      Implementation SafetyToOut<Real_s>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), ps, tmp);
       vecCore::AssignLane(output, i, tmp);
     }
     return output;
@@ -339,7 +339,7 @@ public:
     for (size_t i = 0; i < vecCore::VectorSize<Real_v>(); ++i) {
       Vector3D<Real_s> ps(LaneAt(p.x(), i), LaneAt(p.y(), i), LaneAt(p.z(), i)); // scalar vector
       Real_s tmp;
-      Implementation::template SafetyToIn<Real_s>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), ps, tmp);
+      Implementation SafetyToIn<Real_s>(((UnplacedVolume_t *)this)->UnplacedVolume_t::GetStruct(), ps, tmp);
       vecCore::AssignLane(output, i, tmp);
     }
     return output;
diff --git a/VecGeom/volumes/kernel/CoaxialConesImplementation.h b/VecGeom/volumes/kernel/CoaxialConesImplementation.h
index baea884cb..9694a6286 100644
--- a/VecGeom/volumes/kernel/CoaxialConesImplementation.h
+++ b/VecGeom/volumes/kernel/CoaxialConesImplementation.h
@@ -66,9 +66,9 @@ struct CoaxialConesImplementation {
     using Bool_v = typename vecCore::Mask_v<Real_v>;
     Bool_v onRing(false);
     for (unsigned int i = 0; i < coaxialcones.fConeStructVector.size(); i++) {
-      onRing |= (ConeImplementation<ConeTypes::UniversalCone>::template IsOnRing<Real_v, true, ForLowerZ>(
+      onRing |= (ConeImplementation<ConeTypes::UniversalCone> IsOnRing<Real_v, true, ForLowerZ>(
                      *coaxialcones.fConeStructVector[i], point) ||
-                 ConeImplementation<ConeTypes::UniversalCone>::template IsOnRing<Real_v, false, ForLowerZ>(
+                 ConeImplementation<ConeTypes::UniversalCone> IsOnRing<Real_v, false, ForLowerZ>(
                      *coaxialcones.fConeStructVector[i], point));
     }
 
@@ -125,7 +125,7 @@ struct CoaxialConesImplementation {
       Bool_v compIn(false);
       Bool_v compOut(false);
 
-      ConeHelpers<Real_v, ConeTypes::UniversalCone>::template GenericKernelForContainsAndInside<ForInside>(
+      ConeHelpers<Real_v, ConeTypes::UniversalCone> GenericKernelForContainsAndInside<ForInside>(
           *coaxialcones.fConeStructVector[i], point, compIn, compOut);
       if (ForInside) {
         completelyinside |= compIn;
@@ -157,7 +157,7 @@ struct CoaxialConesImplementation {
     distance = kInfLength;
     for (unsigned int i = 0; i < coaxialcones.fConeStructVector.size(); i++) {
       Real_v dist(kInfLength);
-      ConeImplementation<ConeTypes::UniversalCone>::template DistanceToIn<Real_v>(*coaxialcones.fConeStructVector[i],
+      ConeImplementation<ConeTypes::UniversalCone> DistanceToIn<Real_v>(*coaxialcones.fConeStructVector[i],
                                                                                   point, direction, stepMax, dist);
 
       vecCore::MaskedAssign(distance, dist < distance, dist);
@@ -174,7 +174,7 @@ struct CoaxialConesImplementation {
     distance = -1.;
     for (unsigned int i = 0; i < coaxialcones.fConeStructVector.size(); i++) {
       Real_v dist(kInfLength);
-      ConeImplementation<ConeTypes::UniversalCone>::template DistanceToOut<Real_v>(*coaxialcones.fConeStructVector[i],
+      ConeImplementation<ConeTypes::UniversalCone> DistanceToOut<Real_v>(*coaxialcones.fConeStructVector[i],
                                                                                    point, direction, stepMax, dist);
 
       vecCore::MaskedAssign(distance, dist > distance, dist);
@@ -190,7 +190,7 @@ struct CoaxialConesImplementation {
     safety = kInfLength;
     for (unsigned int i = 0; i < coaxialcones.fConeStructVector.size(); i++) {
       Real_v safeDist(kInfLength);
-      ConeImplementation<ConeTypes::UniversalCone>::template SafetyToIn<Real_v>(*coaxialcones.fConeStructVector[i],
+      ConeImplementation<ConeTypes::UniversalCone> SafetyToIn<Real_v>(*coaxialcones.fConeStructVector[i],
                                                                                 point, safeDist);
 
       vecCore::MaskedAssign(safety, safeDist < safety, safeDist);
@@ -206,7 +206,7 @@ struct CoaxialConesImplementation {
     safety = Real_v(-1.);
     for (unsigned int i = 0; i < coaxialcones.fConeStructVector.size(); i++) {
       Real_v safeDist(kInfLength);
-      ConeImplementation<ConeTypes::UniversalCone>::template SafetyToOut<Real_v>(*coaxialcones.fConeStructVector[i],
+      ConeImplementation<ConeTypes::UniversalCone> SafetyToOut<Real_v>(*coaxialcones.fConeStructVector[i],
                                                                                  point, safeDist);
 
       vecCore::MaskedAssign(safety, safeDist > safety, safeDist);
diff --git a/VecGeom/volumes/kernel/ConeImplementation.h b/VecGeom/volumes/kernel/ConeImplementation.h
index ebe80919d..c2ea2fa58 100644
--- a/VecGeom/volumes/kernel/ConeImplementation.h
+++ b/VecGeom/volumes/kernel/ConeImplementation.h
@@ -102,7 +102,7 @@ struct ConeImplementation {
     typedef typename vecCore::Mask_v<Real_v> Bool_v;
     Bool_v unused(false);
     Bool_v outside(false);
-    ConeHelpers<Real_v, coneTypeT>::template GenericKernelForContainsAndInside<false>(cone, point, unused, outside);
+    ConeHelpers<Real_v, coneTypeT> GenericKernelForContainsAndInside<false>(cone, point, unused, outside);
     inside = !outside;
   }
 
@@ -111,7 +111,7 @@ struct ConeImplementation {
   VECCORE_ATT_HOST_DEVICE
   static void Inside(UnplacedStruct_t const &cone, Vector3D<Real_v> const &point, Inside_v &inside)
   {
-    ConeHelpers<Real_v, coneTypeT>::template Inside<Inside_v>(cone, point, inside);
+    ConeHelpers<Real_v, coneTypeT> Inside<Inside_v>(cone, point, inside);
   }
 
   template <typename Real_v>
@@ -213,7 +213,7 @@ struct ConeImplementation {
 
     Float_t dist_rOuter(kInfLength);
     Bool_t ok_outerCone =
-        ConeHelpers<Real_v, coneTypeT>::template DetectIntersectionAndCalculateDistanceToConicalSurface<true, false>(
+        ConeHelpers<Real_v, coneTypeT> DetectIntersectionAndCalculateDistanceToConicalSurface<true, false>(
             cone, point, dir, dist_rOuter);
     ok_outerCone &= dist_rOuter < distance;
     vecCore::MaskedAssign(distance, !done && ok_outerCone, dist_rOuter);
@@ -224,7 +224,7 @@ struct ConeImplementation {
     if (checkRminTreatment<coneTypeT>(cone)) {
 
       Bool_t ok_innerCone =
-          ConeHelpers<Real_v, coneTypeT>::template DetectIntersectionAndCalculateDistanceToConicalSurface<true, true>(
+          ConeHelpers<Real_v, coneTypeT> DetectIntersectionAndCalculateDistanceToConicalSurface<true, true>(
               cone, point, dir, dist_rInner);
       ok_innerCone &= dist_rInner < distance;
       vecCore::MaskedAssign(distance, !done && ok_innerCone, dist_rInner);
@@ -320,7 +320,7 @@ struct ConeImplementation {
 
     Real_v dist_rOuter(kInfLength);
     Bool_t ok_outerCone =
-        ConeHelpers<Real_v, coneTypeT>::template DetectIntersectionAndCalculateDistanceToConicalSurface<false, false>(
+        ConeHelpers<Real_v, coneTypeT> DetectIntersectionAndCalculateDistanceToConicalSurface<false, false>(
             cone, point, direction, dist_rOuter);
 
     vecCore::MaskedAssign(distance, !done && ok_outerCone && dist_rOuter < distance, dist_rOuter);
@@ -328,7 +328,7 @@ struct ConeImplementation {
     Real_v dist_rInner(kInfLength);
     if (checkRminTreatment<coneTypeT>(cone)) {
       Bool_t ok_innerCone =
-          ConeHelpers<Real_v, coneTypeT>::template DetectIntersectionAndCalculateDistanceToConicalSurface<false, true>(
+          ConeHelpers<Real_v, coneTypeT> DetectIntersectionAndCalculateDistanceToConicalSurface<false, true>(
               cone, point, direction, dist_rInner);
       vecCore::MaskedAssign(distance, !done && ok_innerCone && dist_rInner < distance, dist_rInner);
     }
diff --git a/VecGeom/volumes/kernel/GenericPolyconeImplementation.h b/VecGeom/volumes/kernel/GenericPolyconeImplementation.h
index 20ca9f669..de3b2900b 100644
--- a/VecGeom/volumes/kernel/GenericPolyconeImplementation.h
+++ b/VecGeom/volumes/kernel/GenericPolyconeImplementation.h
@@ -81,7 +81,7 @@ struct GenericPolyconeImplementation {
     if (sec.fSolid) sec.fSolid->Print();
 #endif
 
-    CoaxialConesImplementation::template GenericKernelForContainsAndInside<Real_v, typename vecCore::Mask_v<Real_v>,
+    CoaxialConesImplementation GenericKernelForContainsAndInside<Real_v, typename vecCore::Mask_v<Real_v>,
                                                                            ForInside>(*sec.fCoaxialCones, secLocalp,
                                                                                       secFullyInside, secFullyOutside);
   }
@@ -166,9 +166,9 @@ struct GenericPolyconeImplementation {
         GenericPolyconeSection const &sectionHigh = unplaced.GetSection(indexHigh);
 
         Bool_t onRing(false);
-        onRing |= (CoaxialConesImplementation::template IsOnRing<Real_v, false>(
+        onRing |= (CoaxialConesImplementation IsOnRing<Real_v, false>(
                        *sectionLow.fCoaxialCones, localPoint - Vector3D<Precision>(0, 0, sectionLow.fShift)) ||
-                   CoaxialConesImplementation::template IsOnRing<Real_v, true>(
+                   CoaxialConesImplementation IsOnRing<Real_v, true>(
                        *sectionHigh.fCoaxialCones, localPoint - Vector3D<Precision>(0, 0, sectionHigh.fShift)));
 
         GenericKernelForASection<Real_v, ForInside>(unplaced, indexLow, localPoint, secInLow, secOutLow);
@@ -231,7 +231,7 @@ struct GenericPolyconeImplementation {
                 << " Rmax2=" << sec.fSolid->GetRmax2() << " -- calling Cone::DistToIn()...\n";
 #endif
 
-      CoaxialConesImplementation::template DistanceToIn<Real_v>(
+      CoaxialConesImplementation DistanceToIn<Real_v>(
           *sec.fCoaxialCones, p - Vector3D<Precision>(0, 0, sec.fShift), v, stepMax, distance);
 
 #ifdef POLYCONEDEBUG
@@ -260,7 +260,7 @@ struct GenericPolyconeImplementation {
     if (polycone.GetNSections() == 1) {
       const GenericPolyconeSection &section = polycone.GetSection(0);
 
-      CoaxialConesImplementation::template DistanceToOut<Real_v>(
+      CoaxialConesImplementation DistanceToOut<Real_v>(
           *section.fCoaxialCones, point - Vector3D<Precision>(0, 0, section.fShift), dir, stepMax, distance);
 
       return;
@@ -277,7 +277,7 @@ struct GenericPolyconeImplementation {
     if (indexLow < 0 && indexHigh >= 0 && dir.z() < 0.) {
       index                                 = indexHigh;
       const GenericPolyconeSection &section = polycone.GetSection(index);
-      CoaxialConesImplementation::template DistanceToOut<Real_v>(*section.fCoaxialCones, pn, dir, stepMax, dist);
+      CoaxialConesImplementation DistanceToOut<Real_v>(*section.fCoaxialCones, pn, dir, stepMax, dist);
       distance = dist;
       return;
     }
@@ -285,7 +285,7 @@ struct GenericPolyconeImplementation {
     if (indexLow > 0 && indexHigh < 0 && dir.z() > 0.) {
       index                                 = indexLow;
       const GenericPolyconeSection &section = polycone.GetSection(index);
-      CoaxialConesImplementation::template DistanceToOut<Real_v>(*section.fCoaxialCones, pn, dir, stepMax, dist);
+      CoaxialConesImplementation DistanceToOut<Real_v>(*section.fCoaxialCones, pn, dir, stepMax, dist);
       distance = dist;
       return;
     }
@@ -300,7 +300,7 @@ struct GenericPolyconeImplementation {
         index                                 = indexLow;
         const GenericPolyconeSection &section = polycone.GetSection(index);
         pn.z() -= section.fShift;
-        CoaxialConesImplementation::template Inside<Real_v>(*section.fCoaxialCones, pn, inside);
+        CoaxialConesImplementation Inside<Real_v>(*section.fCoaxialCones, pn, inside);
         if (inside == EInside::kOutside) {
           if (count == 1) {
             distance = -1;
@@ -310,7 +310,7 @@ struct GenericPolyconeImplementation {
             return;
           }
         } else {
-          CoaxialConesImplementation::template DistanceToOut<Real_v>(*section.fCoaxialCones, pn, dir, stepMax, dist);
+          CoaxialConesImplementation DistanceToOut<Real_v>(*section.fCoaxialCones, pn, dir, stepMax, dist);
           if (dist < 0.) break;
           totalDistance += dist;
           pn += dir * dist;
@@ -343,11 +343,11 @@ struct GenericPolyconeImplementation {
     GenericPolyconeSection const &sec = polycone.GetSection(index);
     // safety to current segment
     if (needZ) {
-      CoaxialConesImplementation::template SafetyToIn<Real_v>(*sec.fCoaxialCones,
+      CoaxialConesImplementation SafetyToIn<Real_v>(*sec.fCoaxialCones,
                                                               p - Vector3D<Precision>(0, 0, sec.fShift), safety);
     } else
 
-      CoaxialConesImplementation::template SafetyToIn<Real_v>(*sec.fCoaxialCones,
+      CoaxialConesImplementation SafetyToIn<Real_v>(*sec.fCoaxialCones,
                                                               p - Vector3D<Precision>(0, 0, sec.fShift), safety);
 
     if (safety < kTolerance) return;
@@ -359,7 +359,7 @@ struct GenericPolyconeImplementation {
       if (dz >= minSafety) break;
 
       GenericPolyconeSection const &sect = polycone.GetSection(i);
-      CoaxialConesImplementation::template SafetyToIn<Real_v>(*sect.fCoaxialCones,
+      CoaxialConesImplementation SafetyToIn<Real_v>(*sect.fCoaxialCones,
                                                               p - Vector3D<Precision>(0, 0, sect.fShift), safety);
       if (safety < minSafety) minSafety = safety;
     }
@@ -372,7 +372,7 @@ struct GenericPolyconeImplementation {
         if (dz >= minSafety) break;
         GenericPolyconeSection const &sect = polycone.GetSection(i);
 
-        CoaxialConesImplementation::template SafetyToIn<Real_v>(*sect.fCoaxialCones,
+        CoaxialConesImplementation SafetyToIn<Real_v>(*sect.fCoaxialCones,
                                                                 p - Vector3D<Precision>(0, 0, sect.fShift), safety);
 
         if (safety < minSafety) minSafety = safety;
@@ -410,7 +410,7 @@ struct GenericPolyconeImplementation {
     GenericPolyconeSection const &sec = polycone.GetSection(index);
 
     Vector3D<Real_v> p = point - Vector3D<Precision>(0, 0, sec.fShift);
-    CoaxialConesImplementation::template SafetyToOut<Real_v>(*sec.fCoaxialCones, p, safety);
+    CoaxialConesImplementation SafetyToOut<Real_v>(*sec.fCoaxialCones, p, safety);
 
     Precision minSafety = safety;
     if (minSafety == kInfLength) {
@@ -429,7 +429,7 @@ struct GenericPolyconeImplementation {
       GenericPolyconeSection const &sect = polycone.GetSection(i);
       p                                  = point - Vector3D<Precision>(0, 0, sect.fShift);
 
-      CoaxialConesImplementation::template SafetyToIn<Real_v>(*sect.fCoaxialCones, p, safety);
+      CoaxialConesImplementation SafetyToIn<Real_v>(*sect.fCoaxialCones, p, safety);
 
       if (safety < minSafety) minSafety = safety;
     }
@@ -442,7 +442,7 @@ struct GenericPolyconeImplementation {
         GenericPolyconeSection const &sect = polycone.GetSection(i);
         p                                  = point - Vector3D<Precision>(0, 0, sect.fShift);
 
-        CoaxialConesImplementation::template SafetyToIn<Real_v>(*sect.fCoaxialCones, p, safety);
+        CoaxialConesImplementation SafetyToIn<Real_v>(*sect.fCoaxialCones, p, safety);
 
         if (safety < minSafety) minSafety = safety;
       }
diff --git a/VecGeom/volumes/kernel/ImplAsImplementation.h b/VecGeom/volumes/kernel/ImplAsImplementation.h
index a9d2cae90..dbe2a985b 100644
--- a/VecGeom/volumes/kernel/ImplAsImplementation.h
+++ b/VecGeom/volumes/kernel/ImplAsImplementation.h
@@ -51,7 +51,7 @@ struct IndirectImplementation {
   VECCORE_ATT_HOST_DEVICE
   static void Contains(UnplacedStruct_t const &s, Vector3D<Real_v> const &point, Bool_v &inside)
   {
-    DispatchingImplementation::template Contains(s, point, inside);
+    DispatchingImplementation Contains(s, point, inside);
   }
 
   template <typename Real_v, typename Inside_t>
@@ -59,7 +59,7 @@ struct IndirectImplementation {
   VECCORE_ATT_HOST_DEVICE
   static void Inside(UnplacedStruct_t const &s, Vector3D<Real_v> const &point, Inside_t &inside)
   {
-    DispatchingImplementation::template Inside(s, point, inside);
+    DispatchingImplementation Inside(s, point, inside);
   }
 
   template <typename Real_v>
@@ -68,7 +68,7 @@ struct IndirectImplementation {
   static void DistanceToIn(UnplacedStruct_t const &s, Vector3D<Real_v> const &point, Vector3D<Real_v> const &direction,
                            Real_v const &stepMax, Real_v &distance)
   {
-    DispatchingImplementation::template DistanceToIn(s, point, direction, stepMax, distance);
+    DispatchingImplementation DistanceToIn(s, point, direction, stepMax, distance);
   }
 
   template <typename Real_v>
@@ -77,7 +77,7 @@ struct IndirectImplementation {
   static void DistanceToOut(UnplacedStruct_t const &s, Vector3D<Real_v> const &point, Vector3D<Real_v> const &direction,
                             Real_v const &stepMax, Real_v &distance)
   {
-    DispatchingImplementation::template DistanceToOut(s, point, direction, stepMax, distance);
+    DispatchingImplementation DistanceToOut(s, point, direction, stepMax, distance);
   }
 
   template <typename Real_v>
@@ -85,7 +85,7 @@ struct IndirectImplementation {
   VECCORE_ATT_HOST_DEVICE
   static void SafetyToIn(UnplacedStruct_t const &s, Vector3D<Real_v> const &point, Real_v &safety)
   {
-    DispatchingImplementation::template SafetyToIn(s, point, safety);
+    DispatchingImplementation SafetyToIn(s, point, safety);
   }
 
   template <typename Real_v>
@@ -93,7 +93,7 @@ struct IndirectImplementation {
   VECCORE_ATT_HOST_DEVICE
   static void SafetyToOut(UnplacedStruct_t const &s, Vector3D<Real_v> const &point, Real_v &safety)
   {
-    DispatchingImplementation::template SafetyToOut(s, point, safety);
+    DispatchingImplementation SafetyToOut(s, point, safety);
   }
 
   template <typename Real_v>
@@ -102,7 +102,7 @@ struct IndirectImplementation {
   static Vector3D<Real_v> NormalKernel(UnplacedStruct_t const &s, Vector3D<Real_v> const &point,
                                        typename vecCore::Mask_v<Real_v> &valid)
   {
-    DispatchingImplementation::template NormalKernel(s, point, valid);
+    DispatchingImplementation NormalKernel(s, point, valid);
   }
 };
 
diff --git a/VecGeom/volumes/kernel/PolyconeImplementation.h b/VecGeom/volumes/kernel/PolyconeImplementation.h
index 52dc200fc..7509a3d53 100644
--- a/VecGeom/volumes/kernel/PolyconeImplementation.h
+++ b/VecGeom/volumes/kernel/PolyconeImplementation.h
@@ -92,7 +92,7 @@ struct PolyconeImplementation {
     if (sec.fSolid) sec.fSolid->Print();
 #endif
 
-    ConeHelpers<Real_v, polyconeTypeT>::template GenericKernelForContainsAndInside<ForInside>(
+    ConeHelpers<Real_v, polyconeTypeT> GenericKernelForContainsAndInside<ForInside>(
         *sec.fSolid, secLocalp, secFullyInside, secFullyOutside);
   }
 
@@ -222,7 +222,7 @@ struct PolyconeImplementation {
                 << " Rmax2=" << sec.fSolid->GetRmax2() << " -- calling Cone::DistToIn()...\n";
 #endif
 
-      ConeImplementation<polyconeTypeT>::template DistanceToIn<Real_v>(
+      ConeImplementation<polyconeTypeT> DistanceToIn<Real_v>(
           *sec.fSolid, p - Vector3D<Precision>(0, 0, sec.fShift), v, stepMax, distance);
 
 #ifdef POLYCONEDEBUG
@@ -250,7 +250,7 @@ struct PolyconeImplementation {
     if (polycone.GetNSections() == 1) {
       const PolyconeSection &section = polycone.GetSection(0);
 
-      ConeImplementation<polyconeTypeT>::template DistanceToOut<Real_v>(
+      ConeImplementation<polyconeTypeT> DistanceToOut<Real_v>(
           *section.fSolid, point - Vector3D<Precision>(0, 0, section.fShift), dir, stepMax, distance);
 
       return;
@@ -273,7 +273,7 @@ struct PolyconeImplementation {
       Inside_t inside;
       //      ConeImplementation<ConeTypes::UniversalCone>::Inside<Real_v>(
       //          *section.fSolid, point - Vector3D<Precision>(0, 0, section.fShift), inside);
-      ConeImplementation<polyconeTypeT>::template Inside<Real_v>(
+      ConeImplementation<polyconeTypeT> Inside<Real_v>(
           *section.fSolid, point - Vector3D<Precision>(0, 0, section.fShift), inside);
       if (inside == EInside::kOutside) {
         distance = -1;
@@ -287,7 +287,7 @@ struct PolyconeImplementation {
       //      ConeImplementation<ConeTypes::UniversalCone>::Inside<Real_v>(
       //        *section.fSolid, point - Vector3D<Precision>(0, 0, section.fShift), inside);
 
-      ConeImplementation<polyconeTypeT>::template Inside<Real_v>(
+      ConeImplementation<polyconeTypeT> Inside<Real_v>(
           *section.fSolid, point - Vector3D<Precision>(0, 0, section.fShift), inside);
 
       if (inside == EInside::kOutside) {
@@ -310,7 +310,7 @@ struct PolyconeImplementation {
       Inside_t inside;
       //      ConeImplementation<ConeTypes::UniversalCone>::Inside<Real_v>(
       //          *section.fSolid, point - Vector3D<Precision>(0, 0, section.fShift), inside);
-      ConeImplementation<polyconeTypeT>::template Inside<Real_v>(
+      ConeImplementation<polyconeTypeT> Inside<Real_v>(
           *section.fSolid, point - Vector3D<Precision>(0, 0, section.fShift), inside);
       if (inside == EInside::kOutside) {
         distance = -1;
@@ -333,7 +333,7 @@ struct PolyconeImplementation {
         pn.z() -= section.fShift;
         Inside_t inside;
         //        ConeImplementation<ConeTypes::UniversalCone>::Inside<Real_v>(*section.fSolid, pn, inside);
-        ConeImplementation<polyconeTypeT>::template Inside<Real_v>(*section.fSolid, pn, inside);
+        ConeImplementation<polyconeTypeT> Inside<Real_v>(*section.fSolid, pn, inside);
 
         if (inside == EInside::kOutside) {
           break;
@@ -344,7 +344,7 @@ struct PolyconeImplementation {
       istep++;
 
       // ConeImplementation<ConeTypes::UniversalCone>::DistanceToOut<Real_v>(*section.fSolid, pn, dir, stepMax, dist);
-      ConeImplementation<polyconeTypeT>::template DistanceToOut<Real_v>(*section.fSolid, pn, dir, stepMax, dist);
+      ConeImplementation<polyconeTypeT> DistanceToOut<Real_v>(*section.fSolid, pn, dir, stepMax, dist);
       if (dist == -1) return;
 
       // Section Surface case
@@ -363,7 +363,7 @@ struct PolyconeImplementation {
         Vector3D<Precision> localp;
         Inside_t inside22;
         // ConeImplementation<ConeTypes::UniversalCone>::Inside<Real_v>(*section1.fSolid, pte, inside22);
-        ConeImplementation<polyconeTypeT>::template Inside<Real_v>(*section1.fSolid, pte, inside22);
+        ConeImplementation<polyconeTypeT> Inside<Real_v>(*section1.fSolid, pte, inside22);
         if (inside22 == 3 || (increment == 0)) {
           break;
         }
@@ -399,13 +399,13 @@ struct PolyconeImplementation {
     if (needZ) {
       //      ConeImplementation<ConeTypes::UniversalCone>::SafetyToIn<Real_v>(
       //          *sec.fSolid, p - Vector3D<Precision>(0, 0, sec.fShift), safety);
-      ConeImplementation<polyconeTypeT>::template SafetyToIn<Real_v>(*sec.fSolid,
+      ConeImplementation<polyconeTypeT> SafetyToIn<Real_v>(*sec.fSolid,
                                                                      p - Vector3D<Precision>(0, 0, sec.fShift), safety);
     } else {
 
       //      ConeImplementation<ConeTypes::UniversalCone>::SafetyToIn<Real_v>(
       //          *sec.fSolid, p - Vector3D<Precision>(0, 0, sec.fShift), safety);
-      ConeImplementation<polyconeTypeT>::template SafetyToIn<Real_v>(*sec.fSolid,
+      ConeImplementation<polyconeTypeT> SafetyToIn<Real_v>(*sec.fSolid,
                                                                      p - Vector3D<Precision>(0, 0, sec.fShift), safety);
 
       if (safety < kTolerance) return;
@@ -421,7 +421,7 @@ struct PolyconeImplementation {
         //      ConeImplementation<ConeTypes::UniversalCone>::SafetyToIn<Real_v>(
         //          *sect.fSolid, p - Vector3D<Precision>(0, 0, sect.fShift), safety);
 
-        ConeImplementation<polyconeTypeT>::template SafetyToIn<Real_v>(
+        ConeImplementation<polyconeTypeT> SafetyToIn<Real_v>(
             *sect.fSolid, p - Vector3D<Precision>(0, 0, sect.fShift), safety);
 
         if (safety < minSafety) minSafety = safety;
@@ -438,7 +438,7 @@ struct PolyconeImplementation {
           //        ConeImplementation<ConeTypes::UniversalCone>::SafetyToIn<Real_v>(
           //            *sect.fSolid, p - Vector3D<Precision>(0, 0, sect.fShift), safety);
 
-          ConeImplementation<polyconeTypeT>::template SafetyToIn<Real_v>(
+          ConeImplementation<polyconeTypeT> SafetyToIn<Real_v>(
               *sect.fSolid, p - Vector3D<Precision>(0, 0, sect.fShift), safety);
 
           if (safety < minSafety) minSafety = safety;
@@ -529,7 +529,7 @@ struct PolyconeImplementation {
 
     Vector3D<Real_v> p = point - Vector3D<Precision>(0, 0, sec.fShift);
     // ConeImplementation<ConeTypes::UniversalCone>::SafetyToOut<Real_v>(*sec.fSolid, p, safety);
-    ConeImplementation<polyconeTypeT>::template SafetyToOut<Real_v>(*sec.fSolid, p, safety);
+    ConeImplementation<polyconeTypeT> SafetyToOut<Real_v>(*sec.fSolid, p, safety);
 
     Precision minSafety = safety;
     if (minSafety == kInfLength) {
@@ -549,7 +549,7 @@ struct PolyconeImplementation {
       p                           = point - Vector3D<Precision>(0, 0, sect.fShift);
 
       // ConeImplementation<ConeTypes::UniversalCone>::SafetyToIn<Real_v>(*sect.fSolid, p, safety);
-      ConeImplementation<polyconeTypeT>::template SafetyToIn<Real_v>(*sect.fSolid, p, safety);
+      ConeImplementation<polyconeTypeT> SafetyToIn<Real_v>(*sect.fSolid, p, safety);
 
       if (safety < minSafety) minSafety = safety;
     }
@@ -563,7 +563,7 @@ struct PolyconeImplementation {
         p                           = point - Vector3D<Precision>(0, 0, sect.fShift);
 
         // ConeImplementation<ConeTypes::UniversalCone>::SafetyToIn<Real_v>(*sect.fSolid, p, safety);
-        ConeImplementation<polyconeTypeT>::template SafetyToIn<Real_v>(*sect.fSolid, p, safety);
+        ConeImplementation<polyconeTypeT> SafetyToIn<Real_v>(*sect.fSolid, p, safety);
 
         if (safety < minSafety) minSafety = safety;
       }
diff --git a/VecGeom/volumes/kernel/PolyhedronImplementation.h b/VecGeom/volumes/kernel/PolyhedronImplementation.h
index 9a1a0161b..e9064887d 100644
--- a/VecGeom/volumes/kernel/PolyhedronImplementation.h
+++ b/VecGeom/volumes/kernel/PolyhedronImplementation.h
@@ -689,7 +689,7 @@ bool PolyhedronImplementation<innerRadiiT, phiCutoutT>::ScalarContainsKernel(Unp
   {
     bool inBounds;
     // Correct tube algorithm obtained from trait class
-    HasInnerRadiiTraits<innerRadiiT>::TubeKernels::template Contains(
+    HasInnerRadiiTraits<innerRadiiT>::TubeKernels Contains(
         unplaced.fBoundingTube, Vector3D<Precision>(point[0], point[1], point[2] - unplaced.fBoundingTubeOffset),
         inBounds);
     if (!inBounds) return false;
@@ -753,7 +753,7 @@ Inside_t PolyhedronImplementation<innerRadiiT, phiCutoutT>::ScalarInsideKernel(U
     // FIX: the bounding tube was wrong. Since the fast UnplacedContains is
     // used for early return, the bounding tube has to be larger than the
     // ideal bounding tube to account for the tolerance (offset was wrong)
-    HasInnerRadiiTraits<innerRadiiT>::TubeKernels::template Contains(
+    HasInnerRadiiTraits<innerRadiiT>::TubeKernels Contains(
         unplaced.fBoundingTube, Vector3D<Precision>(point[0], point[1], point[2] - unplaced.fBoundingTubeOffset),
         inBounds);
     if (!inBounds) return EInside::kOutside;
@@ -904,7 +904,7 @@ Precision PolyhedronImplementation<innerRadiiT, phiCutoutT>::ScalarDistanceToInK
   Precision tubeDistance = 0.;
   {
     Vector3D<Precision> boundsPoint(point[0], point[1], point[2] - unplaced.fBoundingTubeOffset);
-    HasInnerRadiiTraits<innerRadiiT>::TubeKernels::template Contains(unplaced.fBoundingTube, boundsPoint, inBounds);
+    HasInnerRadiiTraits<innerRadiiT>::TubeKernels Contains(unplaced.fBoundingTube, boundsPoint, inBounds);
     // If the point is inside the bounding tube, the result of DistanceToIn is
     // unreliable and cannot be used to reject rays.
     // TODO: adjust tube DistanceToIn function to correctly return a negative
@@ -913,7 +913,7 @@ Precision PolyhedronImplementation<innerRadiiT, phiCutoutT>::ScalarDistanceToInK
     if (!inBounds) {
       // If the point is outside the bounding tube, check if the ray misses
       // the bounds
-      HasInnerRadiiTraits<innerRadiiT>::TubeKernels::template DistanceToIn(unplaced.fBoundingTube, boundsPoint,
+      HasInnerRadiiTraits<innerRadiiT>::TubeKernels DistanceToIn(unplaced.fBoundingTube, boundsPoint,
                                                                            direction, stepMax, tubeDistance);
       if (tubeDistance == InfinityLength<Precision>()) {
         return InfinityLength<Precision>();
diff --git a/VecGeom/volumes/kernel/TBooleanMinusImplementation.h b/VecGeom/volumes/kernel/TBooleanMinusImplementation.h
index 966a295eb..664795b43 100644
--- a/VecGeom/volumes/kernel/TBooleanMinusImplementation.h
+++ b/VecGeom/volumes/kernel/TBooleanMinusImplementation.h
@@ -218,7 +218,7 @@ void TBooleanMinusImplementation<LeftPlacedType_t, RightPlacedType_t, transCodeT
 
   // have to figure this out
   Vector3D<typename Backend::precision_v> tmp;
-  LeftPlacedType_t::Implementation::template Contains<Backend>(
+  LeftPlacedType_t::Implementation Contains<Backend>(
       *((LeftPlacedType_t *)unplaced.fLeftVolume)->GetUnplacedVolume(), *unplaced.fLeftVolume->transformation(),
       localPoint, tmp, inside);
 
@@ -232,7 +232,7 @@ void TBooleanMinusImplementation<LeftPlacedType_t, RightPlacedType_t, transCodeT
   if (vecCore::MaskEmpty(inside)) return;
 
   typename Backend::bool_v rightInside;
-  RightPlacedType_t::Implementation::template Contains<Backend>(
+  RightPlacedType_t::Implementation Contains<Backend>(
       *((RightPlacedType_t *)unplaced.fRightVolume)->GetUnplacedVolume(), *unplaced.fRightVolume->transformation(),
       localPoint, tmp, rightInside);
 
@@ -338,10 +338,10 @@ void TBooleanMinusImplementation<LeftPlacedType_t, RightPlacedType_t, transCodeT
   // we need a template specialization for this in case we have LeftType or RightType equals to
   // VPlacedVolume
 
-  LeftPlacedType_t::Implementation::template DistanceToOut<Backend>(
+  LeftPlacedType_t::Implementation DistanceToOut<Backend>(
       *((LeftPlacedType_t *)unplaced.fLeftVolume)->GetUnplacedVolume(), point, direction, stepMax, distance);
   Float_t dinright(kInfLength);
-  RightPlacedType_t::Implementation::template DistanceToIn<Backend>(
+  RightPlacedType_t::Implementation DistanceToIn<Backend>(
       *((RightPlacedType_t *)unplaced.fRightVolume)->GetUnplacedVolume(), *unplaced.fRightVolume->transformation(),
       point, direction, stepMax, dinright);
   distance = Min(distance, dinright);
@@ -384,10 +384,10 @@ void TBooleanMinusImplementation<LeftPlacedType_t, RightPlacedType_t, transCodeT
   typedef typename Backend::bool_v Bool_t;
   typedef typename Backend::precision_v Float_t;
 
-  LeftPlacedType_t::Implementation::template SafetyToOut<Backend>(
+  LeftPlacedType_t::Implementation SafetyToOut<Backend>(
       *((LeftPlacedType_t *)unplaced.fLeftVolume)->GetUnplacedVolume(), point, safety);
   Float_t safetyright(kInfLength);
-  RightPlacedType_t::Implementation::template SafetyToIn<Backend>(
+  RightPlacedType_t::Implementation SafetyToIn<Backend>(
       *((RightPlacedType_t *)unplaced.fRightVolume)->GetUnplacedVolume(), *unplaced.fRightVolume->transformation(),
       point, safetyright);
   safety = Min(safety, safetyright);
diff --git a/scripts/generate_specializations.py b/scripts/generate_specializations.py
index 7f13c0e10..8a2b10b87 100644
--- a/scripts/generate_specializations.py
+++ b/scripts/generate_specializations.py
@@ -13,7 +13,7 @@ header_string = """\
 
 specialization_string = """\
   if (trans_code == {:s} && rot_code == {:#05x}) {{
-    return VolumeType::template Create<{:s}, {:#05x}>(
+    return VolumeType Create<{:s}, {:#05x}>(
       logical_volume, transformation,
 #ifdef VECCORE_CUDA
            id, copy_no, child_id,
@@ -25,7 +25,7 @@ specialization_string = """\
 generic_string = """\
 #endif // No specialization
 
-  return VolumeType::template Create<translation::kGeneric, rotation::kGeneric>(
+  return VolumeType Create<translation::kGeneric, rotation::kGeneric>(
       logical_volume, transformation,
 #ifdef VECCORE_CUDA
            id, copy_no, child_id,
